webpackJsonp([0xd3921852415f],{451:function(n,s){n.exports={pathContext:{postsByTag:[{excerpt:"더 좋은 테스트를 위한 번역 시리즈 그래서, 자바스크립트 테스트가 뭔가요? 테스트를 작성하라. 너무 많이는 말고. 통합 테스트를 많이 써라. 리덕스 앱을 저비용 고효율로 통합 테스트 하기 리액트 + 리덕스 앱을 Jest와 Enzyme…",html:'<p><strong>더 좋은 테스트를 위한 번역 시리즈</strong></p>\n<ol>\n<li><a href="/posts/what-is-testing-javascript-kr">그래서, 자바스크립트 테스트가 뭔가요?</a></li>\n<li><a href="/posts/write-mostly-integration-test-kr">테스트를 작성하라. 너무 많이는 말고. 통합 테스트를 많이 써라.</a></li>\n<li><a href="/posts/integration-tests-in-redux-apps-kr">리덕스 앱을 저비용 고효율로 통합 테스트 하기</a></li>\n<li><a href="/posts/lessons-learned-testing-react-redux-apps-with-jest-and-enzyme-kr">리액트 + 리덕스 앱을 Jest와 Enzyme으로 테스트하며 얻은 교훈</a></li>\n</ol>\n<h2 id="들어가며번역-서문"><a href="#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0%EB%B2%88%EC%97%AD-%EC%84%9C%EB%AC%B8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>들어가며(번역 서문)</h2>\n<p>“더 좋은 테스트를 위한 번역 시리즈” 두 번째입니다. 테스트를 작성하는게 좋다는 공감대는 얻었을 지 몰라도 막상 코드 에디터 앞에서는 대략 정신이 멍해지기 일쑤입니다. 전부 다 테스트를 하자니 너무 광범위하고, 함수 단위로 유닛 테스트만 작성하자니 너무 세세해서 실제 제대로 애플리케이션이 동작하는지 파악하기도 어렵거니와 노력 대비 별로 쓸모가 없어보이기도 합니다.</p>\n<p>그 고민을 조금이나마 덜어드리고자 좋은 조언을 가져와서 번역해 보았습니다.</p>\n<p><a href="https://blog.kentcdodds.com/write-tests-not-too-many-mostly-integration-5e8c7fff591c">원문은 여기서 보실 수 있습니다.</a></p>\n<hr>\n<p>얼마 전에 <a href="https://medium.com/@rauchg">Guillermo Rauch</a>(<a href="https://socket.io">Socket.io</a>의 창시자이자 <a href="https://zeit.co">Zeit.co</a>의 설립자입니다)가 위 제목으로 <a href="https://twitter.com/rauchg/status/807626710350839808">심오한 트윗</a>을 하나 작성했습니다. </p>\n<p><img src="https://cl.ly/1w0Q053W1B1O/write-integration-test-2.png"></p>\n<blockquote>\n<p><strong>테스트를 작성하라. 너무 많이는 말고. 통합 테스트를 많이 써라.</strong></p>\n</blockquote>\n<p>짧지만 긴 내용입니다. 더 자세히 들어가보죠.</p>\n<blockquote>\n<p><strong>테스트를 작성하라.</strong></p>\n</blockquote>\n<p>네, 여러분은 대부분의 프로젝트에 자동화된 테스트를 작성해야 합니다. 특히 자신의 시간을 소중히 여긴다면요. 새벽 두 시에 버그 때문에 불려나가는 것 보다 로컬에서 버그를 잡아내는게 훨씬 낫습니다. <strong>저는 테스트를 작성하는데 시간을 들일 때 오히려 시간을 절약한다고 느낍니다.</strong> 테스트를 작성하다 보면 제가 실제로 만들고자 하는 것 보다 더 오래 걸릴 수도 있고, 그렇지 않을 수도 있지만, 저는(그리고 다른 사람들도) 거의 확실히 유지보수 하는데 드는 시간을 절약하고 있습니다.</p>\n<p>테스트를 작성할 때는 이 테스트가 프로젝트의 버그를 얼마나 줄여줄 자신이 있는지 신경쓰셔야 합니다. <a href="https://flow.org/">Flow</a>, <a href="https://eslint.org/">ESLint</a> 같은 정적 타이핑이나 린트는 의미있는 수준의 자신감을 가져다 줍니다. 혹시 써보지 않으셨다면 반드시 살펴보시길 권합니다. 하지만 <strong>아무리 강한 타입을 적용한 프로그래밍 언어라도 테스트가 있어야 합니다.</strong> 타입과 린트는 여러분의 비지니스 로직에 버그가 없도록 만들어주지 않습니다. 그러니 좋은 테스트를 작성해서 (버그를 줄인다는)자신감을 크게 끌어올릴 필요가 있습니다.</p>\n<blockquote>\n<p><strong>너무 많이는 말고.</strong></p>\n</blockquote>\n<p>저는 애플리케이션에 100%의 코드 커버리지를 달성하려는 매니저나 팀이 있다고 들었습니다. 이는 굉장히 안 좋은 생각입니다. 커버리지가 70%(제 추측입니다.. 과학적인 증거는 없어요)를 넘어가게 되면서부터 여러분이 테스트로 얻는 이익이 점감하게 되는 문제가 있습니다. 왜 그럴까요? 음, 언제나 100%를 달성하기 위해 힘을 쏟다 보면 막상 테스트 할 필요 없는 것을 테스트하는데 시간을 소모하게 됩니다. 실제 신경써야 할 로직이 없는 것들 말이죠(ESLint나 Flow로도 충분히 잡아낼 수 있는 모든 버그들). <em>이런 규모의 테스트를 유지보수하는데 엄청난 시간이 들고 여러분의 팀을 힘들게 만들 겁니다.</em></p>\n<p>그리고 테스트 환경에서 재현하기 어려운 한 줄의 코드를 위해 테스트를 작성할 때도 있습니다. 이런 경우는 <em>진짜로</em> 피하고 싶을겁니다. 왜냐면 이 테스트는 애플리케이션이 제대로 작동한다는 자신감을 별로 주지도 못하고, 리팩터링 할 때 속도를 늦출 뿐이기 때문입니다. <strong>코드를 리팩터링 할 때 테스트를 변경해야 하는 경우는 거의 없습니다.</strong></p>\n<p>제가 작성한 대부분의 오픈 소스 프로젝트는 거의 100%의 코드 커버리지를 가지고 있다는 말씀을 드려야겠군요. 대부분의 프로젝트들은 작은 라이브러리나 툴이며, 여러 다른 상황(코드가 깨진다면 심각한 상황으로 이어질 수 있는 프로젝트들이 사용하는 상황)에서 재사용하기 쉽도록 작성되었습니다. 그래서 어찌저찌 상대적으로 100%의 커버리지를 얻을 수 있었습니다.</p>\n<blockquote>\n<p><strong>통합 테스트를 많이 써라.</strong></p>\n</blockquote>\n<p>테스트의 종류는 아주 다양합니다(제가 Fluent Conf에서 <a href="https://youtu.be/Da9wfQ0frGA">“바퀴를 테스트하면서 배울 수 있는 것들”</a>이라는 제목으로 5분짜리 발표를 했습니다). 각각의 테스트는 장단점이 있습니다. 보통 자동화된 테스트를 이야기 할 때 많이 거론되는 테스트는 단위(Unit) 테스트, 통합(Integration) 테스트, E2E(End to End) 테스트입니다.</p>\n<p>여기 제가 <a href="https://frontendmasters.com/courses/testing-javascript/">“자바스크립트 애플리케이션 테스트하기”</a> 라는 Frontend Masters 워크샵에서 선보인 <a href="http://slides.com/kentcdodds/testing-workshop#/4/8">슬라이드</a>를 잠시 보시죠.</p>\n<p><img src="https://cl.ly/3x273a0A343P/write-integration-test-1.png"></p>\n<p>테스팅 피라미드는 <a href="https://martinfowler.com/bliki/TestPyramid.html">마틴 파울러의 블로그</a>와 <a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html">구글 테스팅 블로그</a>에서 얻은 개념을 한데 합친 것입니다.</p>\n<p>앞서 말씀드린대로 이 피라미드는 바닥부터 꼭대기까지 단위 테스트, 통합 테스트, E2E 테스트로 이루어져 있습니다. 피라미드의 위로 올라갈수록 테스트를 실행하고 작성하는데 더 많은 시간이 들고, 실행하고 유지보수하는데 비용(시간과 자원 측면에서)이 많이 듭니다. 그림만 보면 유닛 테스트를 작성하는데 시간을 더 투자해야 하는 것 처럼 보입니다.</p>\n<p>미처 언급되지 않은 점이 있는데, 피라미드 위로 올라갈 수록 각 테스트의 신뢰성이 증가한다는 겁니다. 여러분이 생각한 것 보다 훨씬 큰 이득을 얻을 수 있습니다(You get more bang for your buck). 따라서 E2E 테스트가 단위 테스트보다 느리고 비용이 많이 들지라도, 애플리케이션이 의도대로 동작한다는 자신감은 더 크게 제공합니다.</p>\n<p><a href="https://twitter.com/kentcdodds/status/628658648001048577">제 트윗 중 가장 많이 리트윗된 트윗</a>이 단위 테스트의 주요 문제를 다루고 있습니다.</p>\n<blockquote>\n<p>아직도 이 사진을 좋아해요. 유닛 테스트만 좋아하는 사람들은 이렇게 “작동하는 것 같다” 라고 말하죠.  </p>\n</blockquote>\n<p><img src="https://cl.ly/093u1O2j0k1Y/write-integration-test-3.gif"></p>\n<p>이 사람이 방에서 달릴 수 있고, 팔굽혀펴기를 하고, 독서를 할 수 있는지 확인하기 위해 단위 테스트를 작성했지만, 이 사람은 자신의 다양한 신체 부위를 아주 효율적으로 사용하지 못하는데다 통합하지 않고 있습니다. 만약 버튼 컴포넌트가 <code>onClick</code> 핸들러를 호출할 때 핸들러가 올바른 데이터를 제대로 요청하지 않는다면, 핸들러의 호출이 잘 되는지 확인하는 일은 그닥 중요한게 아닙니다! 각각 분리 된 부분이 자신의 역할을 제대로 수행하는지 확인하기 위해 단위 테스트를 작성하는 것은 그리 나쁜 일은 아닙니다. *분리 된 부분이 <strong>함께</strong> 제 역할을 수행하는지 확인하지 않는다면 아무 소용 없습니다.*</p>\n<p><strong>통합 테스트는 자신감을 심어주는 역할 대비 속도/비용을 부담하는 정도를 아주 균형있게 가지고 있습니다.</strong> 그래서 여러분이 <em>대부분</em>(혹시 몰라 말씀드리지만 전부는 아닙니다)의 시간을 통합 테스트에 투자하라는 조언을 드리는 겁니다.</p>\n<hr>\n<p><strong>통합 테스트를 더 많이 작성하는 방법</strong></p>\n<p>통합 테스트와 단위 테스트 사이의 경계는 약간 모호합니다. 어느 쪽이든 더 많은 통합 테스트를 작성하기 위해 가장 도움되는 것이 무엇이냐 물으신다면 <strong>일단 너무 많은 것을 모킹(mocking)하지 않기를 권합니다.</strong> <em>무언가를 모킹할 때, 테스트하고자 하는 것과 모킹된 것 사이의 통합테스트 신뢰도는 떨어지게 됩니다.</em> 때로는 이 방법이 도움 되지 않을 수 있습니다(<a href="https://www.youtube.com/watch?v=EaxDl5NPuCA&#x26;feature=youtu.be">반대하는 사람도 있지만요</a>). 실제로 매 테스트마다 이메일을 발송하거나 신용카드 결제를 할 필요는 없지만, 대부분의 경우 모킹을 피하면 테스팅을 더 잘 하게 되리라 생각합니다.</p>\n<p><strong>만약 리액트로 개발을 하고 계시다면, 얕은 랜더링(<a href="http://airbnb.io/enzyme/docs/api/shallow.html">shallow rendering</a>)도 포함됩니다.</strong> 저는 오랜 시간동안 얕은 랜더링은 세부 구현을 테스트하는 것이나 마찬가지라고 이야기해왔습니다. 이 부분을 <a href="https://www.briefs.fm/3-minutes-with-kent/49">3분 짜리 팟캐스트</a>에서(그리고 리액트 테스팅에 대한 다른 팁도 포함해서) 다루고 있습니다.</p>\n<p>도움이 되셨길 바라며 모두 행운을 빕니다! 👍</p>',id:"/Users/rinae/Dev/blog/src/pages/posts/2018-01-15-write-mostly-integration-test-kr/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2018-01-15",path:"/posts/write-mostly-integration-test-kr",title:"[번역] 테스트를 작성하라. 너무 많이는 말고. 통합 테스트를 많이 써라.",tags:["Translation","Testing","TDD"],category:"Testing"}},{excerpt:"더 좋은 테스트를 위한 번역 시리즈 그래서, 자바스크립트 테스트가 뭔가요? 테스트를 작성하라. 너무 많이는 말고. 통합 테스트를 많이 써라. 리덕스 앱을 저비용 고효율로 통합 테스트 하기 리액트 + 리덕스 앱을 Jest와 Enzyme…",html:'<p><strong>더 좋은 테스트를 위한 번역 시리즈</strong></p>\n<ol>\n<li><a href="/posts/what-is-testing-javascript-kr">그래서, 자바스크립트 테스트가 뭔가요?</a></li>\n<li><a href="/posts/write-mostly-integration-test-kr">테스트를 작성하라. 너무 많이는 말고. 통합 테스트를 많이 써라.</a></li>\n<li><a href="/posts/integration-tests-in-redux-apps-kr">리덕스 앱을 저비용 고효율로 통합 테스트 하기</a></li>\n<li><a href="/posts/lessons-learned-testing-react-redux-apps-with-jest-and-enzyme-kr">리액트 + 리덕스 앱을 Jest와 Enzyme으로 테스트하며 얻은 교훈</a></li>\n</ol>\n<h2 id="들어가며"><a href="#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>들어가며</h2>\n<p>요즘 개인적으로 “가능한한 내 코드에 모두 테스트를 작성하겠다” 라는 목표를 가지고 있습니다. 하지만 테스트에 대해 두루뭉술한 개념만 가지고 있고, 지금은 상대적으로 쉬운 함수만 테스트를 작성할 수 있는 수준입니다.</p>\n<p>하지만 실제 개발하고 있는 애플리케이션은 ‘리액트 + 리덕스(혹은 MobX) + 기타등등’ 의 구성으로 되어있기 때문에 조금만 테스트를 제대로 해 보려고 하면 어디부터 손을 대야할지 전혀 감을 못 잡는 상태입니다.</p>\n<p>그래서 실전에 최대한 도움이 될 수 있도록 유용한 글을 몇개 추려서 단계별로 보기 좋은 참고서가 될 수있도록 번역하는 사이드 프로젝트를 진행하고 있습니다. 이 글을 보시는 분들도 리액트로 만드는 애플리케이션을 테스트하는데 도움이 되었으면 좋겠습니다.</p>\n<p>그 첫 번째 단계로 <strong>테스트가 대체 뭐냐?</strong> 라는 질문에 가벼운 답이 될 수 있는 글의 번역부터 시작합니다.</p>\n<p><a href="https://blog.kentcdodds.com/but-really-what-is-a-javascript-test-46fe5f3fad77">원문은 여기서 읽어보실 수 있습니다.</a></p>\n<hr>\n<p><em>일단 한 발짝 물러서서 시작부터 자바스크립트 자동화 테스트를 이해해 보도록 하겠습니다.</em></p>\n<p>소프트웨어를 테스트하는 이유는 수도 없이 많습니다. 저는 크게 두 가지 이유를 가지고 있습니다.</p>\n<ol>\n<li>전체 작업 흐름의 속도를 올려서 개발을 빠르게 한다.</li>\n<li>변경 사항이 있을 때 기존 코드를 무너트리지 않는다는 확신을 갖도록 도와준다.</li>\n</ol>\n<p>그래서 그런데, 저는 여러분에게 몇 가지 여쭈어 보고 싶은게 있습니다. (트위터 투표로 미리 물어보았죠)</p>\n<ul>\n<li><a href="https://twitter.com/kentcdodds/status/942625485829181441">자바스크립트 테스트를 작성해 보신 적 있습니까?</a></li>\n<li><a href="https://twitter.com/kentcdodds/status/942625486638759938">자바스크립트 테스팅 프레임워크를 사용해 보신 적 있습니까?</a></li>\n<li><a href="https://twitter.com/kentcdodds/status/942625487511154688">자바스크립트 테스팅 프레임워크를 밑바닥부터 설정해 보신 적 있습니까?</a></li>\n<li><a href="https://twitter.com/kentcdodds/status/942625489348280320">테스팅 프레임워크를 충분히 이해하고 있고, 아주 간단한 테스팅 프레임워크라도 직접 만들어 보실 수 있습니까?</a></li>\n</ul>\n<p>이 글의 목적은 당신이 마지막 질문에 “네” 라고 대답할 수 있도록 돕는 것입니다. 결과적으로 자바스크립트를 테스트한다는게 무엇인지 알아야 더 좋은 테스트를 작성할 수 있으니까요.</p>\n<p>이제 간단한 <code>math.js</code> 모듈을 만들어서 그 안에 두 함수를 작성한 다음에 내보내겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">+</span> b\n<span class="token keyword">const</span> <span class="token function-variable function">subtract</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">-</span> b\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span> sum<span class="token punctuation">,</span> subtract <span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p><strong>작성하는 모든 코드는 <a href="https://github.com/kentcdodds/js-test-example">Github에</a> 올려두었으니 참고하시면 됩니다</strong> 🐙😸</p>\n<h2 id="1단계"><a href="#1%EB%8B%A8%EA%B3%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1단계</h2>\n<p>제가 생각할 수 있는 가장 기본적인 테스트 형식을 보여드리겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token comment">// basic-test.js</span>\n<span class="token keyword">const</span> actual <span class="token operator">=</span> <span class="token boolean">true</span>\n<span class="token keyword">const</span> expected <span class="token operator">=</span> <span class="token boolean">false</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>actual <span class="token operator">!==</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">\'${actual} is not ${expected}\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>터미널에서 <code>node basic-test.js</code> 라고 입력하시면 이 테스트 코드를 실행할 수 있습니다. 이게 테스트입니다!</p>\n<p><strong>테스트는 기대하던 결과값과 실제 출력된 값이 맞지 않으면 에러를 일으키는 코드입니다.</strong> 만약 특정한 상태값 설정을 해야하는 등(예를 들자면 컴포넌트가 테스트 실행 전에 그려져야(Rendered on Document) 브라우저 이벤트를 확인해볼 수 있다던가, 데이터베이스에 있는 사용자를 가져온다던가) 특수한 경우에는 더 복잡해질 수 있습니다. 하지만 <code>math.js</code> 모듈 같은 순수한 함수(Pure function - 입력값에 따른 출력값이 동일하며 외부의 상태에 영향을 미치지 않는 함수)은 상대적으로 쉽습니다.</p>\n<p><strong>코드의 <code>actual !== expected</code> 부분을 “단언(assertion)” 이라고 합니다.</strong> 단언은 어떤 것이 특정한 값으로 되어있어야 한다거나 특정 테스트를 통과해야한다고 코드로 표현하는 것을 뜻합니다. <code>actual</code> 부분이 어떠한 정규표현식에 일치해야하거나, 배열이 특정한 길이를 가지고 있어야 한다고 표현하는 것이 단언이 됩니다. 중요한 점은 만약 우리가 작성한 단언이 실패하면 에러가 일어나야 한다는 것입니다.</p>\n<p>그래서 <code>math.js</code> 를 가장 기본적인 형태로 테스트 해 본다면 이렇게 됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token comment">// 1.js</span>\n<span class="token keyword">const</span> <span class="token punctuation">{</span>sum<span class="token punctuation">,</span> subtract<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'./math\'</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> result<span class="token punctuation">,</span> expected\nresult <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>\nexpected <span class="token operator">=</span> <span class="token number">10</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!==</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is not equal to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>expected<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\nresult <span class="token operator">=</span> <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>\nexpected <span class="token operator">=</span> <span class="token number">4</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!==</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is not equal to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>expected<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>짜잔! 이 파일을 <code>node</code> 커맨드로 실행해보면 에러 없이 실행되고 종료됩니다. 이제 <code>sum</code> 함수의 <code>+</code> 연산을 <code>-</code> 연산으로 바꾸고 다시 실행해서 테스트를 깨지도록 만들어보겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>$ node 1.js\n/Users/kdodds/Desktop/js-test-example/1.js:8\n  throw new Error(`${result} is not equal to ${expected}`)\n  ^\nError: -4 is not equal to 10\n    at Object.<anonymous> (/Users/kdodds/Desktop/js-test-example/1.js:8:9)\n    at Module._compile (module.js:635:30)\n    at Object.Module._extensions..js (module.js:646:10)\n    at Module.load (module.js:554:32)\n    at tryModuleLoad (module.js:497:12)\n    at Function.Module._load (module.js:489:3)\n    at Function.Module.runMain (module.js:676:10)\n    at startup (bootstrap_node.js:187:16)\n    at bootstrap_node.js:608:3</code></pre>\n      </div>\n<p>좋습니다! 우리는 벌써 기본적인 테스트를 사용해서 이득을 보고 있어요! 이제 테스트를 변경하지 않는 이상 <code>sum</code> 함수를 마음대로 바꿀 수 없습니다. 쩌네요(Neato)!</p>\n<p><strong>테스팅 프레임워크(혹은 단언 라이브러리)의 가장 중요한 부분은 에러 메세지를 최대한 도움이 되도록 표현하는 겁니다.</strong> 테스트가 실패할 때마다 여러분이 제일 먼저 에러 메세지를 보게 됩니다. 만약 에러 메세지를 보고 어떤 문제가 밑에 깔려있는지 단박에 파악하지 못한다면, 몇분씩 코드를 직접 들여다보면서 뭐가 잘못됐는지 찾아야 합니다. 에러 메세지의 질은 여러분이 주어진 테스팅 프레임워크를 얼마나 잘 이해하고 적절한 단언을 사용하느냐에 따라서 크게 달라집니다.</p>\n<h2 id="2단계"><a href="#2%EB%8B%A8%EA%B3%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2단계</h2>\n<p>사실 Node.js 가 위에서 만들어본 <a href="https://nodejs.org/api/assert.html#assert_assert"><code>assert</code></a> 모듈을 내장하고 있다는 걸 알고 계셨나요🤔? 이 모듈을 써서 리팩터링을 해 보겠습니다!</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token comment">// 2.js</span>\n<span class="token keyword">const</span> assert <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'assert\'</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> <span class="token punctuation">{</span>sum<span class="token punctuation">,</span> subtract<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'./math\'</span><span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> result<span class="token punctuation">,</span> expected\n\nresult <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>\nexpected <span class="token operator">=</span> <span class="token number">10</span>\nassert<span class="token punctuation">.</span><span class="token function">strictEqual</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> expected<span class="token punctuation">)</span>\n\nresult <span class="token operator">=</span> <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>\nexpected <span class="token operator">=</span> <span class="token number">4</span>\nassert<span class="token punctuation">.</span><span class="token function">strictEqual</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> expected<span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>좋아요! 저번에 작성했던 코드와 기능적으로 완전히 동일한 테스트 모듈을 작성해보았습니다. 딱 하나 다른게 있다면 에러 메세지입니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>$ node 2.js\nassert.js:42\n  throw new errors.AssertionError({\n  ^\nAssertionError [ERR_ASSERTION]: -4 === 10\n    at Object.<anonymous> (/Users/kdodds/Desktop/js-test-example/2.js:8:8)\n    at Module._compile (module.js:635:30)\n    at Object.Module._extensions..js (module.js:646:10)\n    at Module.load (module.js:554:32)\n    at tryModuleLoad (module.js:497:12)\n    at Function.Module._load (module.js:489:3)\n    at Function.Module.runMain (module.js:676:10)\n    at startup (bootstrap_node.js:187:16)\n    at bootstrap_node.js:608:3</code></pre>\n      </div>\n<p>내용을 보시면 아쉽게도 에러가 더 이상 코드 내용을 보여주지 않고 있습니다. 😦 일단 계속 가보죠.</p>\n<h2 id="3단계"><a href="#3%EB%8B%A8%EA%B3%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3단계</h2>\n<p>더 나아가서 직접 테스팅 “프레임워크” 와 단언 라이브러리를 작성해보겠습니다. 먼저 단언 라이브러리부터 시작해보죠. Node의 내장 <code>assert</code> 모듈 대신에 <code>expect</code> 라는 라이브러리를 만들어보겠습니다. 변경된 코드는 아래와 같습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token comment">// 3.js</span>\n<span class="token keyword">const</span> <span class="token punctuation">{</span>sum<span class="token punctuation">,</span> subtract<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'./math\'</span><span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> result<span class="token punctuation">,</span> expected\n\nresult <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>\nexpected <span class="token operator">=</span> <span class="token number">10</span>\n<span class="token function">expect</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span>\n\nresult <span class="token operator">=</span> <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>\nexpected <span class="token operator">=</span> <span class="token number">4</span>\n<span class="token function">expect</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span>\n\n<span class="token keyword">function</span> <span class="token function">expect</span><span class="token punctuation">(</span>actual<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token function">toBe</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>actual <span class="token operator">!==</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>actual<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is not equal to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>expected<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>이제 원하는대로 단언을 추가하고 객체를 리턴하도록 만들 수 있습니다(<code>toMatchRegex</code>, <code>toHaveLength</code>).</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>$ node 3.js\n/Users/kdodds/Desktop/js-test-example/3.js:17\n        throw new Error(`${actual} is not equal to ${expected}`)\n        ^\nError: -4 is not equal to 10\n    at Object.toBe (/Users/kdodds/Desktop/js-test-example/3.js:17:15)\n    at Object.<anonymous> (/Users/kdodds/Desktop/js-test-example/3.js:7:16)\n    at Module._compile (module.js:635:30)\n    at Object.Module._extensions..js (module.js:646:10)\n    at Module.load (module.js:554:32)\n    at tryModuleLoad (module.js:497:12)\n    at Function.Module._load (module.js:489:3)\n    at Function.Module.runMain (module.js:676:10)\n    at startup (bootstrap_node.js:187:16)\n    at bootstrap_node.js:608:3</code></pre>\n      </div>\n<p>훨씬 보기 좋아졌네요.</p>\n<h2 id="4단계"><a href="#4%EB%8B%A8%EA%B3%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4단계</h2>\n<p>그런데 만약 에러 메세지가 나온다 해도 정확하게 <code>sum</code> 함수에 문제가 생겼다고 파악하려면 어떻게 해야할까요😖? 저 파일 안에는 <code>subtract</code> 함수도 있는데 말이죠. 게다가 테스트 파일의 코드는 각각의 테스트를 적절히 분리하지 못하고 있습니다(시각적으로 + 기능적으로). </p>\n<p>그래서 헬퍼 함수를 만들어서 분리해보았습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token comment">// 4.js</span>\n<span class="token keyword">const</span> <span class="token punctuation">{</span>sum<span class="token punctuation">,</span> subtract<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'./math\'</span><span class="token punctuation">)</span>\n<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">\'sum adds numbers\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> expected <span class="token operator">=</span> <span class="token number">10</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">\'subtract subtracts numbers\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> expected <span class="token operator">=</span> <span class="token number">4</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`- [x] </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>title<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`✕ </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>title<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>\n    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">expect</span><span class="token punctuation">(</span>actual<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token function">toBe</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>actual <span class="token operator">!==</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>actual<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is not equal to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>expected<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>이제 특정 테스트에 관련된 내용은 전부 “test” 콜백 안에 집어넣고, 테스트에 제목을 매길 수 있습니다. 그리고 <code>test</code> 함수에 유용한 에러 메세지를 출력하도록 할 뿐만 아니라 모든 테스트를 한번에 실행할 수 있게 되었습니다(첫 번째 테스트에서 에러가 발생한다고 멈추지 않구요)!</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>$ node 4.js\n✕ sum adds numbers\nError: -4 is not equal to 10\n    at Object.toBe (/Users/kdodds/Desktop/js-test-example/4.js:29:15)\n    at test (/Users/kdodds/Desktop/js-test-example/4.js:6:18)\n    at test (/Users/kdodds/Desktop/js-test-example/4.js:17:5)\n    at Object.<anonymous> (/Users/kdodds/Desktop/js-test-example/4.js:3:1)\n    at Module._compile (module.js:635:30)\n    at Object.Module._extensions..js (module.js:646:10)\n    at Module.load (module.js:554:32)\n    at tryModuleLoad (module.js:497:12)\n    at Function.Module._load (module.js:489:3)\n    at Function.Module.runMain (module.js:676:10)\n- [x] subtract subtracts numbers</code></pre>\n      </div>\n<p>좋아요! 이제 에러 메세지 <em>뿐만 아니라</em> 어떤 부분을 고쳐야하는지 테스트 제목을 보고 찾아갈 수 있습니다.</p>\n<h2 id="5단계"><a href="#5%EB%8B%A8%EA%B3%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5단계</h2>\n<p>마지막 단계로 모든 테스트 파일을 찾아서 실행하는 <a href="https://blog.kentcdodds.com/tips-for-making-a-cli-based-tool-with-node-9903255c2a3b">CLI 도구를 작성하기만 하면 됩니다!</a> 처음엔 쉽겠지만 그 위에 해야하는 일들이 굉장히 많아서 좀 어렵습니다 . 😅</p>\n<p>현재 시점에서 우리는 테스팅 프레임워크와 테스트 실행기(runner)를 만들었습니다. 다행히도 이미 만들어진 도구가 산더미같이 많습니다! 저는 모든 테스팅 도구를 사용해보았고 다 괜찮았습니다. 그래도 제 요구 사항을 가장 만족하는 도구는 Jest 뿐이었습니다. Jest는 아주 대단한 도구입니다. (<a href="http://kcd.im/egghead-jest">Jest를 더 알아보시려면 이 링크를 확인하세요</a>)</p>\n<p>그러니 이제 직접 프레임워크를 작성하는 대신 테스트 파일을 Jest 용으로 바꾸어 보겠습니다. 이를 어쩌죠? 안바꿔도 되는데요!? Jest는 <code>test</code>, <code>expect</code> 를 글로벌 객체로 가지고 있기 때문에 그냥 이전에 작성한 <code>test</code> 와 <code>expect</code> 의 구현체를 지우기만 하면 됩니다!</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code><span class="token comment">// 5.js</span>\n<span class="token keyword">const</span> <span class="token punctuation">{</span>sum<span class="token punctuation">,</span> subtract<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'./math\'</span><span class="token punctuation">)</span>\n<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">\'sum adds numbers\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> expected <span class="token operator">=</span> <span class="token number">10</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">\'subtract subtracts numbers\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> expected <span class="token operator">=</span> <span class="token number">4</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>Jest로 이 파일을 실행하면 다음과 같은 결과가 출력됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>$ jest\n FAIL  ./5.js\n  ✕ sum adds numbers (5ms)\n  - [x] subtract subtracts numbers (1ms)\n● sum adds numbers\nexpect(received).toBe(expected)\n    \n    Expected value to be (using Object.is):\n      10\n    Received:\n      -4\n      4 |   const result = sum(3, 7)\n      5 |   const expected = 10\n    > 6 |   expect(result).toBe(expected)\n      7 | })\n      8 | \n      9 | test(\'subtract subtracts numbers\', () => {\n      \n      at Object.<anonymous>.test (5.js:6:18)\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 1 passed, 2 total\nSnapshots:   0 total\nTime:        0.6s, estimated 1s\nRan all test suites.</code></pre>\n      </div>\n<p>텍스트만 보아서는 알 수 없지만 사실 결과는 컬러로 출력됩니다. 이미지로 보시면 이렇게 나옵니다.</p>\n<p><img src="https://cl.ly/302i0B3V0J45/what-is-javascript-testing-1.png"></p>\n<p>컬러로 출력되면 관련된 부분을 살펴볼 때 큰 도움이 됩니다. <strong>그리고 에러가 발생하는 부분의 코드를 직접 보여줍니다! 이게 “도움이 되는” 에러 메세지죠!</strong></p>\n<h2 id="결론"><a href="#%EA%B2%B0%EB%A1%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>결론</h2>\n<p>그래서 자바스크립트 테스트가 뭐라고 했죠? 단순히 특정 상태를 설정해놓은 코드를 가지고 특정 동작을 수행한 뒤, 새 상태를 확인하는 단언을 만드는 겁니다. 이번 시간에는 <a href="https://facebook.github.io/jest/docs/en/api.html#beforeeachfn-timeout"><code>beforeEach</code></a>, <a href="https://facebook.github.io/jest/docs/en/api.html#describename-fn"><code>describe</code></a> 같은 <a href="https://facebook.github.io/jest/docs/en/api.html">프레임워크 공용으로 사용되는 헬퍼 함수</a>에 대한 이야기는 하지 않았지만, <a href="https://facebook.github.io/jest/docs/en/expect.html#tomatchobjectobject"><code>toMatchObject</code></a>, <a href="https://facebook.github.io/jest/docs/en/expect.html#tocontainitem"><code>toContain</code></a> 같이 사용할 수 있는 단언이 아주 많이 있습니다. 적어도 이 글이 여러분들에게 자바스크립트로 테스트하는데 기본적인 개념을 제시해주길 바랍니다.</p>\n<p>도움이 되었으면 좋겠군요. 행운을 빕니다! 👍</p>\n<p><strong>놓치지 말고 참고할만한 글 목록(영어 자료)</strong></p>\n<ul>\n<li><a href="https://twitter.com/horse_js/status/942658114209316864">Horse JS on Twitter: “But really, what is a JavaScript”</a> - 문맥을 빗겨가게 끊어진 글을 트윗하는 아주 재밌는 계정입니다.</li>\n<li><a href="https://twitter.com/NTulswani/status/942079674527518720">Introducing React Performance Devtool!! - by Nitin Tulswani</a></li>\n<li><a href="https://www.javascriptjanuary.com">JavaScript January</a></li>\n</ul>',
id:"/Users/rinae/Dev/blog/src/pages/posts/2018-01-14-what-is-testing-javascript-kr/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2018-01-14",path:"/posts/what-is-testing-javascript-kr",title:"[번역] 그래서, 자바스크립트 테스트가 뭔가요?",tags:["Translation","Javascript","Testing"],category:"Testing"}},{excerpt:"이 포스팅은 Boostnote 팀의 요청에 의하여 번역되었습니다. 원문을 보시려면  이 링크 를 클릭해주세요. 안녕하세요, Boostnote 개발자  kazup  입니다. 예상 외로 맥의 순정 메모 어플리케이션에서 Boostnote로 갈아타는 분들이 많아보여서, 이번 기회에 두 앱을 간단히 비교하는 글을 작성해보았습니다. What is Boostnote? 프로그래머를 위한 오픈 소스 노트입니다. 마크다운을 기본적으로 지원하고 15…",html:'<ul>\n<li>이 포스팅은 Boostnote 팀의 요청에 의하여 번역되었습니다.</li>\n<li>원문을 보시려면 <a href="http://boostnote.hatenablog.com/entry/2017/08/09/130721">이 링크</a>를 클릭해주세요.</li>\n</ul>\n<hr>\n<p>안녕하세요, Boostnote 개발자 <a href="https://twitter.com/kazup_bot">kazup</a> 입니다.</p>\n<p>예상 외로 맥의 순정 메모 어플리케이션에서 Boostnote로 갈아타는 분들이 많아보여서, 이번 기회에 두 앱을 간단히 비교하는 글을 작성해보았습니다.</p>\n<h2 id="what-is-boostnote"><a href="#what-is-boostnote" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is Boostnote?</h2>\n<p>프로그래머를 위한 오픈 소스 노트입니다. 마크다운을 기본적으로 지원하고 150가지가 넘는 언어의 Syntax Highlighting 및 스니펫을 저장하는 기능도 있습니다.</p>\n<p>개발자를 위한 특화 기능으로 vim 키맵을 사용하거나 마크다운 안에 작성해둔 코드를 원터치로 저장하는 등 개발자들이 즐겁게 사용할만한 기능들이 포함되어 있습니다.</p>\n<p>또한 에버노트에서 데이터를 가져오는 <a href="https://github.com/BoostIO/ever2boost">ever2boost</a> 등의 서드파티 도구들도 여럿 있어서 간단하게 이용하실 수 있습니다.</p>\n<h2 id="what-is-notes"><a href="#what-is-notes" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is Notes?</h2>\n<p>여러분의 친숙한 애플 순정 메모 어플리케이션입니다. Boostnote와 달리 누구나 즐겁게 사용할 수 있게 만들어져 있습니다.</p>\n<p>가볍게 동작하기 때문에 사소한 메모를 남겨두고 싶을 때 편리하게 이용할 수 있습니다.</p>\n<h2 id="the-key-differences-of-boostnote-vs-notes"><a href="#the-key-differences-of-boostnote-vs-notes" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The key differences of Boostnote vs Notes</h2>\n<p>가장 큰 차이점은 대상 사용자입니다. Boostnote는 명확하게 개발자를 대상으로 삼고 있지만 Notes는 누구나 부담없이 사용할 수 있게 만들어져 있습니다.</p>\n<p>예를 들어 Notes는 플레인 텍스트(Plain text)만 지원하는 반면, Boostnote는 마크다운과 스니펫을 저장할 수 있습니다.</p>\n<p>또한 커스터마이즈 가능한 부분도 큰 차이가 나는데, Boostnote가 단축키부터 컬러 테마, 앞서 말씀드린 키맵(vim 등)의 변경이 가능한 반면 Notes는 어디까지나 간단하면서 일관된 경험을 제공합니다.</p>\n<h2 id="a-comparison-of-boostnote-vs-notes"><a href="#a-comparison-of-boostnote-vs-notes" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A comparison of Boostnote vs Notes</h2>\n<p>주요 차이점을 정리해보았습니다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Boostnote</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>노트북 포맷</td>\n<td>Markdown and snippet</td>\n<td>Plain text</td>\n</tr>\n<tr>\n<td>가격</td>\n<td>무료</td>\n<td>무료</td>\n</tr>\n<tr>\n<td>데이터 저장소</td>\n<td>Local, Dropbox, Google Drive 등</td>\n<td>Local, iCloud, Google</td>\n</tr>\n<tr>\n<td>플랫폼</td>\n<td>Windows, Mac, Linux (iOS, Android 출시 예정)</td>\n<td>Mac, iOS</td>\n</tr>\n<tr>\n<td>주요 대상</td>\n<td>Developer</td>\n<td>Everyone</td>\n</tr>\n<tr>\n<td>사용자 정의</td>\n<td>Color, Code Block and Editor theme, Keymap, Hotkey</td>\n<td>X</td>\n</tr>\n<tr>\n<td>노트 공유</td>\n<td><a href="https://10hz.io/">10hz</a></td>\n<td>via iCloud</td>\n</tr>\n</tbody>\n</table>\n<h2 id="wrapping-it-up"><a href="#wrapping-it-up" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wrapping it up.</h2>\n<p>이상 Boostnote와 Notes를 비교해보았습니다. 둘 다 겉으로 보기에는 아주 단순해보이지만, 그 단순함 속에 숨겨진 기능이나 구조의 차이가 있어서 비교해보니 꽤 재밌었습니다.</p>\n<p>Boostnote는 훨씬 더 개발자지향적이고 무엇보다 <a href="https://github.com/BoostIO/Boostnote">오픈소스입니다</a>! 널리 개발자들에게 사용되어 다양한 수정을 거쳐 기회가 된다면 풀 리퀘스트를 주고받고 싶습니다.</p>\n<p>서두에서 말씀드린대로 Notes에서 갈아타는 분들이 많이 보이고 있으니 주변에 쓸만한 노트 앱을 찾고 계신 개발자분들이 계시다면 Boostnote를 추천해 주세요!</p>\n<p>또한 <a href="https://boostnote.io/team/">팀 단위로 노트로 기획된 10hz</a>도 현재 베타버전으로 배포되고 있으니 한번 살펴봐주시기 바랍니다.</p>\n<hr>\n<p>사실 일본어는 간단하게 말을 주고받는 정도만 할 수 있을 뿐이지, 실제로 잘 읽을 수 있는 수준은 아니라 번역기와 사전의 도움을 받아가며 작업했습니다. 그래도 내용이 어렵지 않아서 오래 걸리지 않았네요.</p>\n<p>노트를 다양한 플랫폼으로 여기저기 작성해보면서 가장 맞는 스타일의 앱을 찾고 있는데 현재로서 Boostnote가 제가 생각하는 개발노트용 앱으로 가장 알맞다고 생각하여 이렇게 소개하는 글을 번역해 보았습니다.</p>\n<p>마크다운 문법만 익숙하시다면 사용하는게 그리 어렵지 않을테니 가벼운 마음으로 한번 시도해보세요 :)</p>',id:"/Users/rinae/Dev/blog/src/pages/posts/2017-08-09-boostnote-vs-notes-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-08-09",path:"/posts/boostnote-vs-notes-kor",title:"[번역] Boostnote vs Notes: Choosing a note-taking Tool",tags:["Markdown","Tools","OSS","Translation"],category:"Translation"}},{excerpt:"이 글의 원문은  Michał Konarski…",html:'<ul>\n<li>이 글의 원문은 <a href="http://mjk.space/how-to-avoid-inheritance-in-ruby/">Michał Konarski</a>가 작성하였습니다.</li>\n<li>번역 실수 및 용어 사용의 지적 등은 언제나 환영합니다.</li>\n</ul>\n<hr>\n<p>상속이 왜 문제가 될까요? 예를 하나 들어드리겠습니다.</p>\n<p>여러분의 고객이 \'교통 상황 시뮬레이터\'를 만들어달라고 요청했다고 해보죠. 고객은 몇몇 자동차가 움직이는 모습을 실험해보고 싶어합니다. 만약 루비같은 객체지향 언어를 사용한다면 먼저 모든 로직과 속성을 담고 있는 모델 클래스를 떠올리게 됩니다. 이렇게요.</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 136px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50.73529411764706%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAAB0klEQVQoz7WRXUsbQRSG7Y3QqxS80N/Qv9P/UCP4F1qwd6VKg94oWCpFa6CJ8QO7iR/Jmo+NqasxJjP7kexutEWjMbEqWNRZj2cmGy3ojRcOPJwzO++8+85MR8dzjJnCxOsoDfdLNNSL+CUa9ksk1IKGHvZ8nd7PoyTsj2x/eyvZUy+FYdqK9x9c70PlpAz2qXWHhVT+VsDinHrV404jehvUP1lI7y73CMOUtdpbPjGhdFC8IrUS49BDwrQ6ZfidmQ2D6XWNGQ1dUG4arK3DPail17lq+iLpxLrbhn6exhMAboZkaQ0iiRmQsj9hPjkHsVwUEttx0cfzq1zLA0CpVrzRDqm7Xk1dYsKHhsX9HcAUEM1JEPgSgPcf38HY9CgExj/DyMQwfBgagMHRT2Ac68C1aPqooTgyGl6hwMXqFn7nXUXPuMvqkrtV3XTlQkKA6QT0iLhciwkZrRGGhv9S7SNnHLlv72IPtCOKfzYEZsMUF+6cO1Bumt4j2OCcteAJuU6v62Aem/BrV2FyRWo9SkyLvFFsmWRseUNx1tQWsopzNWMlVMWr/5Nt63CN9yv6wvoiCXYJw1nta+fczuSrBfLdt6gFnwadRoK+H/lxXxPIi1t5GBmgA5JzOAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="Vehicle Class"\n        title=""\n        src="/static/2017-07-16-sc1-2e83a320a96db4a01c9b4553157907f6-9805c.png"\n        srcset="/static/2017-07-16-sc1-2e83a320a96db4a01c9b4553157907f6-9805c.png 136w"\n        sizes="(max-width: 136px) 100vw, 136px"\n      />\n    </span>\n  </span>\n  </p>\n<p>완성된 결과물을 고객에게 보여주었습니다. 다 괜찮았는데 이제 고객이 자동차가 \'승용차\' 혹은 \'트럭\' 으로 나뉘었으면 좋겠다고 합니다. 이런 경우 두 차종은 최소한 일부 행동을 공유하고 있있는데다, 코드를 반복해서 작성하는 것도 별로 내키지 않습니다. 문제 없어요! 상속을 활용하면 되죠! 지금 마주친 경우는 아주 적절한 \'-이다(is-a)\' 관계입니다. 안 될 것 있나요?</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 424px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 38.443396226415096%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAAA1klEQVQoz2NgwAGOPtincfbxyXp0fOTuPhsGcsCpR0cDr7648n/Pmd3/Nx7c8H/78W3/Qfwzj05UkGXgsfv7vS48Pffi/JOzLy88PfviwpOzYPaJB4dzGSgATEAsCWWzA7EoKZoFgZgHC0YGXFjkhVFUAL1zBITPPDh5HMY+en+fJT6bt19bLQNTe/bhKbi+kw+PNjCAAvrUnZP/Nx3aCA50ED5+/6A3PgP33NqoAlJ38fEFsL695/aA9Z17cnoZA5BYgo4P391tgM/AXTfXimPTB4ywbAByZrvmOVUShwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="Vehicle with inheritance"\n        title=""\n        src="/static/2017-07-16-sc2-fa7f9df8054d6743399cc2574b2c80e3-11014.png"\n        srcset="/static/2017-07-16-sc2-fa7f9df8054d6743399cc2574b2c80e3-20168.png 198w,\n/static/2017-07-16-sc2-fa7f9df8054d6743399cc2574b2c80e3-b3d3b.png 395w,\n/static/2017-07-16-sc2-fa7f9df8054d6743399cc2574b2c80e3-11014.png 424w"\n        sizes="(max-width: 424px) 100vw, 424px"\n      />\n    </span>\n  </span>\n  </p>\n<p>고객은 결과물에 또 만족했지만, 또 다른 추가사항을 요구했습니다. 이 자동차들이 다른 종류의 엔진을 탑재했으면 한다고 합니다. 예를 들어 석유 엔진과 전기 엔진으로요. 다시 한번 상속을 사용해서 문제를 해결해보겠습니다!</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 562px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABjklEQVQoz2NgwAPmn+rmuPjs/GJkvPHSEj4GcsGsQ228V19c+b/v/N7/e8/t+Q9ib7q0TIwcszhBmF+ElysyK1h90rp2iQV7J4uFZwRqyChLcMHk8Zqw79YWntOPjjtvP7PZC0SfenTEAZfaEw8O24HU7Di7Baz26KO9mMFw4uFBXZCXjl478v/sgzP/Lz278AWXgUC51yduHf9/8NIBcDCcenzUDEPRgVs7RM8/OV266+z2JhA+8/hEAS4Dzzw6kQNTB9Jz5N4eSWzq2KDhwgHEsHBiwaKOBSrHhaSHHS47YW8Fe//uCu7ALBdhED33bDProivtKGLLb3ezzDxRz4IsNvVwDcfE/ZWsyGIzTtSzM4DS1sHLB/7vOrXz//Ebx/5feHq2Dii2befJHf93n9n9/8jVw/+B3so+9+R00qErh/7vOr3z/96ze/5ffHpu//mnZ0p3noLwQfj0/RNrQeGRf+HpubUXnpxdC6JPPzwWdubRyRqwGBSfenjU88zj407IYmcfnwSFsz+aWCkA5cIfg20hiMcAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="Vehicle with even more inheritance"\n        title=""\n        src="/static/2017-07-16-sc3-ea0481feb5f8dca30a8d25a48403b0b1-7f0b2.png"\n        srcset="/static/2017-07-16-sc3-ea0481feb5f8dca30a8d25a48403b0b1-8c8bd.png 198w,\n/static/2017-07-16-sc3-ea0481feb5f8dca30a8d25a48403b0b1-e07aa.png 395w,\n/static/2017-07-16-sc3-ea0481feb5f8dca30a8d25a48403b0b1-7f0b2.png 562w"\n        sizes="(max-width: 562px) 100vw, 562px"\n      />\n    </span>\n  </span>\n  </p>\n<p>여러분의 고객은 \'지금은\' 아주 행복합니다. 하지만 또 세분화를 요구한다면 어떻게 될까요? 전용차라던가, 경찰차라던가, 소방트럭이나 앰뷸런스 등 이보다 더 많은 세분화를 요구한다면? 우리의 상속 트리는 점점 커지고 복잡해지게 됩니다. 반복되는 코드를 줄이는 대신에 결국 같은 로직을 여러군데 복사-붙여넣기 하게 될 것입니다. 심지어 <a href="https://en.wikipedia.org/wiki/Combinatorial_explosion">위키피디아에도</a> 이 현상이 기재되어 있습니다.</p>\n<p>위에서 말씀드린 사례는 제가 가볍게 지어낸 경우가 아닙니다. 저는 전문 개발자로 일하면서 오래된 코드에 새로운 기능이나 행동을 추가하려 할 때마다 이런 상황을 여러 번 접했습니다. 특히 여러분이 레일즈를 사용하면서 더 자주 접하실\n수 있습니다. <code>ApplicationRecord</code> 나 <code>ApplicationController</code> 를 상속하도록 강제하는 경우가 많기 때문입니다.</p>\n<p>상속이 발생하는 코드를 예로 보여드리겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">Vehicle</span>\n  <span class="token keyword">def</span> run\n    refill\n    load\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token operator">&lt;</span> <span class="token constant">Vehicle</span>\n  <span class="token keyword">def</span> load\n    <span class="token comment"># 승객을 싣는다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Truck</span> <span class="token operator">&lt;</span> <span class="token constant">Vehicle</span>\n  <span class="token keyword">def</span> load\n    <span class="token comment"># 화물을 싣는다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">PetrolCar</span> <span class="token operator">&lt;</span> <span class="token constant">Car</span>\n  <span class="token keyword">def</span> refill\n    <span class="token comment"># 연료를 채운다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">ElectricCar</span> <span class="token operator">&lt;</span> <span class="token constant">Car</span>\n  <span class="token keyword">def</span> refill\n    <span class="token comment"># 전지를 충전한다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">PetrolTruck</span> <span class="token operator">&lt;</span> <span class="token constant">Truck</span>\n  <span class="token keyword">def</span> refill\n    <span class="token comment"># 연료를 채운다 (반복되는 코드!)</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">ElectricTruck</span> <span class="token operator">&lt;</span> <span class="token constant">Truck</span>\n  <span class="token keyword">def</span> refill\n    <span class="token comment"># 전지를 충전한다 (반복되는 코드!)</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>이 코드를 더 낫게 만들 수 있을까요? 가능합니다.</p>\n<h2 id="아마도-믹스인mixin을-쓰면"><a href="#%EC%95%84%EB%A7%88%EB%8F%84-%EB%AF%B9%EC%8A%A4%EC%9D%B8mixin%EC%9D%84-%EC%93%B0%EB%A9%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>아마도 믹스인(Mixin)을 쓰면?</h2>\n<p>수 많은 루비 프로그래머들이 상속이 문제를 해결할 수 없다고 깨닫는 순간, 가장 먼저 떠오르는 해결책은 믹스인일 겁니다. 믹스인이 뭘까요? 기본적으로 메서드들이 정의된 모듈을 클래스에 포함하여 그 클래스의 일부로 사용하는 기법입니다. 우리는 간단히 공통된 로직을 추출하여 코드의 재사용을 피할 수 있습니다. </p>\n<p>믹스인을 사용하면 코드가 어떻게 바뀔까요? 먼저 <code>include</code> 하게 될 모듈을 만들겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">module</span> <span class="token constant">Vehicle</span>\n  <span class="token keyword">def</span> run\n    refill\n    load\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">module</span> <span class="token constant">Truck</span>\n  <span class="token keyword">def</span> load\n    <span class="token comment"># 화물을 싣는다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">module</span> <span class="token constant">Car</span>\n  <span class="token keyword">def</span> load\n    <span class="token comment"># 승객을 싣는다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">module</span> <span class="token constant">ElectricEngine</span>\n  <span class="token keyword">def</span> refill\n    <span class="token comment"># 전지를 충전한다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">module</span> <span class="token constant">PetrolEngine</span>\n  <span class="token keyword">def</span> refill\n    <span class="token comment"># 연료를 채운다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>그리고 믹스인할 대상이 되는 클래스를 만듭니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">PetrolCar</span>\n  include <span class="token constant">Vehicle</span>\n  include <span class="token constant">Car</span>\n  include <span class="token constant">PetrolEngine</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">ElectricCar</span>\n  include <span class="token constant">Vehicle</span>\n  include <span class="token constant">Car</span>\n  include <span class="token constant">ElectricEngine</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">PetrolTruck</span>\n  include <span class="token constant">Vehicle</span>\n  include <span class="token constant">Truck</span>\n  include <span class="token constant">PetrolEngine</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">ElectricTruck</span>\n  include <span class="token constant">Vehicle</span>\n  include <span class="token constant">Truck</span>\n  include <span class="token constant">ElectricEngine</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>좀 보기 좋습니다. 코드가 반복되지도 않았고, 새로운 종류의 특성을 넣어서 어떤 종류의 차량이라도 만들어낼 수 있게 되었습니다. 게다가 차량이 어떤 기능을 가지고 있는지도 눈에 잘 들어옵니다.</p>\n<p>하지만 여전히 문제가 남아있습니다. 클래스를 살펴보면 포함된 행동들이 어떻게 사용되는지 명확하지 않습니다. 믹스인으로 새로운 메서드들이 추가되었지만 이 메서드들이 무엇을 하는지, 클래스가 어떻게 메서드와 영향을 주고받는지, 실행되는 과정은 어떻게 되는지 바로 파악할 수 없습니다. 만에 하나 같은 이름을 가지고 있는 두 모듈을 가져와 사용한다면 문제가 발생하게 됩니다. 한 모듈이 다른 모듈에 있는 메서드를 \'조용히\' 가져와서 사용하게 되겠지요. 상속 할 클래스가 늘어나면서 생기는 문제와 비슷한 방식으로 코드가 엉망이 되기 시작합니다.</p>\n<p>믹스인은 확실히 좋은 사용처가 있기 때문에 그렇게 나쁜 방법은 아닙니다. 제 의견으로는 로깅, 인증, 유효성 검사 등 클래스의\n메타행위(meta behavior)를 정의할 때는 아주 잘 동작한다고 생각합니다. 믹스인은 코드를 깔끔하고 작은 규모로 유지할 수 있다는 명확한 장점이 있습니다. 여러분이 모듈에 정의되어 있는 구현을 믿고 있고, 서로 다른 로직을 무너뜨리지 않는 지점을 파악하고 있는 한 괜찮습니다. 기억하셔야 할 점은 이는 단지 <strong>루비가 은연중에 다중 상속을 구현하는 방법</strong>에 불과하다는 점입니다.</p>\n<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">In OOP there’s this thing to prefer composition over inheritance. And in Ruby people constantly forget that modules == multiple inheritance</p>&mdash; Piotr Solnica (@_solnic_) <a href="https://twitter.com/_solnic_/status/623224611212251136">July 20, 2015</a></blockquote>\n<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>\n<p>이 문제를 개선할 수 있을까요? Yes, we can!</p>\n<h2 id="조합"><a href="#%EC%A1%B0%ED%95%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>조합</h2>\n<p>조합은 저도 오래전에 알고 있었지만 최근에야 사용하기 시작한 용어입니다. 단지 조합을 충분히 편하게 사용할만큼 좋다는 <em>느낌을 받지 못했습니다.</em> 그러던 어느 날 Sandi Metz의 <a href="https://www.youtube.com/watch?v=OMPfEXIlTVE">\'Nothing is Something\'</a> 이라는 아주 환상적인 발표를 보게 되었습니다. 다른 것 보다 그녀는 조합에 대해 이야기하면서 제가 예를 들었던 문제(교통 상황 시뮬레이터)를 풀어냈습니다.</p>\n<p>조합은 어떤 방식으로 동작할까요? 클래스 사이에 <strong>같은</strong> 행위를 공유하려 하기보다, 어떤 요소가 <strong>다른</strong>지 알아낸 뒤에 이름을 붙이고, 개별 클래스로 추출해낸 뒤에 마지막에 하나의 객체로 합치는 방식으로  동작하게 됩니다.</p>\n<p>상속이 \'-이다(is-a)\' 관계를 나타낸다면 조합은 \'-를 가지고 있다(has-a)\' 관계를 나타냅니다. 그러므로 조합을 활용하기 위해서 문제의 구조를 바꾸어야 합니다. 우리의 차량은 더 이상 전기자동차가 아니라, 전기 엔진을 가진 자동차 입니다(Our vehicle <strong>is not</strong> an electric vehicle anymore but rather it <strong>has</strong> an electric engine). 트럭은 그냥 트럭이 아니고 자동차가 트럭의 몸체를 가진 것입니다(It <strong>is not</strong> a truck but it <strong>has</strong> a truck body). 이렇게 우리는 두 가지 개념을 잡아냈습니다. 바로 <strong>엔진</strong> 과 <strong>몸체</strong> 입니다.</p>\n<p>우리의 애플리케이션은 이제 아래와 같은 모습이 되었습니다. 엔진과 몸체 컨셉을 구현한 뒤에 <code>Vehicle</code> 클래스 안에 엔진과 몸체가 들어갈 자리를 마련했습니다.</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 373px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 76.67560321715818%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAABn0lEQVQ4y52Uy07CQBSG+zDqyoXPYtSlL+BGE5/AJ3DrO4g3WBhFQISCtCIdWtoSubYDIl4o3o3J77SGBp0CCZN8mXY6/XrO6WkFYYpxrvZmCvX39SCm8QnZ8vNiSrEQl25wIupI5uvsuAJSf4Yg1hKr1/RKnUSukd4ZFur0E3L5Hjm9g6zW9uaS9Q5Baoob2q2KAeFUGKHoLvbOQhhez9vS8UB4KNK5OHnYDIITjmJYmDGcJcnoeikWGy9epO5ssKh9IbErKNqUQ7EagUK3bpFEAbHcDU4zBo5iebh19YVFu4Py7TcSV1WvwG7B3XPN7nPCM+VhVq68bgTBCQsVB5elDpSqM1I4dvgp0xLDCECfVqhBsUs8bP2/ME4eF1gTbwfBpaw2X6HTDxitr5EpZ0xn2b0WzZo4jMo4YMjmvbefE8pmF/snEmJjXspAqDXfQGp9FOsvLJC3v0JiV6HSNgexLE4YuWzPJ7WnrSAEsZpYK9B8bxLswSH/0zP7K0brExfXDaSJ7fWhSOhvhFP9HJjQvTmn3yGjtryGTjPctR8HwfDuCQnP2gAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="Composition in action"\n        title=""\n        src="/static/2017-07-16-sc4-b6caad80a0028f7518410ecd07b25a64-a1aef.png"\n        srcset="/static/2017-07-16-sc4-b6caad80a0028f7518410ecd07b25a64-c12ac.png 198w,\n/static/2017-07-16-sc4-b6caad80a0028f7518410ecd07b25a64-a1aef.png 373w"\n        sizes="(max-width: 373px) 100vw, 373px"\n      />\n    </span>\n  </span>\n  </p>\n<p>실제 코드는 어떻게 될까요? 핵심 클래스부터 살펴보겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">Vehicle</span>\n  <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>engine<span class="token punctuation">:</span><span class="token punctuation">,</span> body<span class="token punctuation">:</span><span class="token punctuation">)</span>\n    <span class="token variable">@engine</span> <span class="token operator">=</span> engine\n    <span class="token variable">@body</span> <span class="token operator">=</span> body\n  <span class="token keyword">end</span>\n\n  <span class="token keyword">def</span> run\n    <span class="token variable">@engine</span><span class="token punctuation">.</span>refill\n    <span class="token variable">@body</span><span class="token punctuation">.</span>load\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>이제 우리는 컨셉에 맞는 구현을 한 뒤에 <code>Vehicle</code> 객체에 주입하면 됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">ElectricEngine</span>\n  <span class="token keyword">def</span> refill\n    <span class="token comment"># 전지를 충전한다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">PetrolEngine</span>\n  <span class="token keyword">def</span> refill\n    <span class="token comment"># 연료를 채운다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">TruckBody</span>\n  <span class="token keyword">def</span> load\n    <span class="token comment"># 화물을 싣는다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">CarBody</span>\n  <span class="token keyword">def</span> load\n    <span class="token comment"># 승객을 싣는다</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>마지막으로 모두 한 곳에 넣으면 됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code>petrol_car <span class="token operator">=</span> <span class="token constant">Vehicle</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>engine<span class="token punctuation">:</span> <span class="token constant">PetrolEngine</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">,</span> body<span class="token punctuation">:</span> <span class="token constant">CarBody</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">)</span>\nelectric_car <span class="token operator">=</span> <span class="token constant">Vehicle</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>engine<span class="token punctuation">:</span> <span class="token constant">ElectricEngine</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">,</span> body<span class="token punctuation">:</span> <span class="token constant">CarBody</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">)</span>\npetrol_truck <span class="token operator">=</span> <span class="token constant">Vehicle</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>engine<span class="token punctuation">:</span> <span class="token constant">PetrolEngine</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">,</span> body<span class="token punctuation">:</span> <span class="token constant">TruckBody</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">)</span>\nelectric_truck <span class="token operator">=</span> <span class="token constant">Vehicle</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>engine<span class="token punctuation">:</span> <span class="token constant">ElectricEngine</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">,</span> body<span class="token punctuation">:</span> <span class="token constant">TruckBody</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>이 접근방식은 많은 이점이 있습니다. <code>Vehicle</code> 클래스가 외부 로직을 사용하는 방식은 첫 눈에 명확하게 들어옵니다. 이름이 꼬이는 문제도 없습니다. 각각의 클래스는 정확히 한 가지 일을 하고 있습니다(<a href="https://ko.wikipedia.org/wiki/%EB%8B%A8%EC%9D%BC_%EC%B1%85%EC%9E%84_%EC%9B%90%EC%B9%99">단일 책임 원칙</a>을 만족합니다). 그래서 이 클래스들이 자신에게 주어진 일을 얼마나 제대로 하는지 확인하는 테스트를 쉽게 할 수 있습니다.</p>\n<p>우리는 높은 응집력(관련있는 로직을 같이 두는 것)을 달성하면서 동시에 결합도(클래스의 의존성을 낮게 만드는 것)는 낮추었습니다. 이제 인터페이스 전체를 바꾸지 않는 한, 고객의 요구에 걱정하지 않고 코드에 사용되는 엔진이나 몸체를 바꿀 수 있습니다.</p>\n<p>조합 기법에도 문제점이 있을까요? 물론 있습니다. 이 방식은 코드를 더 길게 쓰도록 합니다. 특히 모든 의존성들을 최종 객체에 주입하게 될 때 눈에 띄게 길어집니다. 여러분은 추가적인 보일러플레이트(여기서는 코드를 생산해내는 템플릿 함수)를 만들어서 참조 위치를 저장하고, 어디에 위임을 할지 설정하며 정확한 실행 흐름을 제어할 수 있도록 만들어야 합니다. 문제의 처방전으로 여러분은 여러 가지 <a href="https://en.wikipedia.org/wiki/Creational_pattern">제작 패턴</a>을 활용할 수 있습니다. 팩토리(Factory)나 빌더(Builder) 처럼요.</p>\n<p>제가 조합을 활용하려고 할 때 제일 어려웠던 점은 제 사고 방식을 조합을 응용하기에 알맞는 방식으로 고치는 것이었습니다. 예상밖으로 <strong>Go</strong> 언어를 가지고 놀 때 많은 도움을 받았습니다. 이 프로그래밍 언어는 상속을 받지 않도록 설계되어 있지만 객체지향 방식으로 코드를 작성할 수 있게 되어있습니다. 또한 프로그래머들에게 조합을 사용하도록 권장하는 기능들이 담겨있습니다. (역주: <a href="http://hackthology.com/object-oriented-inheritance-in-go.html">이 글</a>이 Go 언어에서 조합을 사용하는 예를 보여주는 좋은 글로 보입니다) 제가 Go를 조금 가지고 놀다가 갑자기 조합을 사용하는데 훨씬 익숙해졌다는 사실을 깨달았습니다. 다음 포스팅에 이 이야기를 자세히 쓰고자 합니다.</p>\n<h2 id="결론"><a href="#%EA%B2%B0%EB%A1%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>결론</h2>\n<p>저는 여러분께 코드를 구축하는 세 가지 다른 접근 방식을 보여드렸습니다. 상속, 믹스인, 조합 말씀입니다. <strong>상속</strong>은 많은 프로그래머들의 첫 번째 선택지이지만, 저에게는 심하게 과용되고 코드를 복잡하게 만드는데다 유지보수도 힘들게 만들었습니다. <strong>믹스인</strong>은 더 똑똑하고 강력한 대체제로 보이지만 사실은 다중 상속의 한 방법에 불과하고 코드의 복잡도를 늘릴 수도 있습니다. <strong>조합</strong>은 코드 양은 제일 길어지겠지만 클래스 사이에 의존성을 관리하는데 가장 직관적이며 깔끔한 접근방식을 가지고 있습니다. 조합은 코드를 작고 분리된 조각으로 유지하며 테스트하기도 쉽습니다. 그래서 제가 가장 선호하는 방법입니다.</p>\n<p>객체 지향 프로그래밍은 일부 프로그래머들이 다른 프로그래머들이 처한 문제를 조금 더 쉽게 해결하도록 돕고자 만든 하나의 협약에 지나지 않는다는 점을 잊으시면 안됩니다. 규약에 얽매이지 마세요. 여러분이 처한 상황에 가장 잘 맞는 해결책을 선택하세요.</p>\n<p>그리고 마지막으로, 이 말을 새겨두시기 바랍니다.</p>\n<blockquote>\n<p>객체 지향 소프트웨어를 설계하는 일은 어렵다. 그리고 재사용 가능한 객체 지향 소프트웨어를 설계하는 일은 훨씬 더 어렵다. - Gang of Four</p>\n</blockquote>\n<p>이 말을 경험을 통해 알게 되실 겁니다.</p>\n<h2 id="원문의-참고-자료"><a href="#%EC%9B%90%EB%AC%B8%EC%9D%98-%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>원문의 참고 자료</h2>\n<ul>\n<li>RailsConf 2015 - Nothing is Something</li>\n<li><a href="https://learnrubythehardway.org/book/ex44.html">https://learnrubythehardway.org/book/ex44.html</a></li>\n<li><a href="https://robots.thoughtbot.com/reusable-oo-inheritance">https://robots.thoughtbot.com/reusable-oo-inheritance</a></li>\n<li><a href="https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose">https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose</a></li>\n</ul>\n<hr>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>어느정도 일상과 공부와 번역 등의 밸런스가 틀이 잡혀가면서 한달에 한 개 정도 포스팅하는 방향으로 굳어지고 있나봅니다. 적어도 한달에 두어개는 작성하고 싶은데.. 좋은 글은 매일 탐독하고 있지만 제대로 써먹지 못하면서 알려봤자 뭐가 좋나? 라는 생각이 들 때도 있습니다.</p>\n<p>이전에 의존성 주입에 관한 글을 번역했을 때도 그렇지만 조합 패턴은 루비를 사용하면서, 혹은 자바스크립트를 사용하면서도 아주 중요한 패턴 중 하나라고 생각합니다. 반드시 자유자재로 다루고 싶은 패턴이긴 한데 \'평범하게\' 레일즈를 사용하게 되면 아마 쉽게 익숙해지긴 힘든 패턴이라 생각합니다. 그래서 개인적으로 루비로 API 백엔드를 구축하는 토이 프로젝트를 하시게 된다면 하나미(hanamirb)를 이용해서 만들어보시는걸 강력하게 권장하고 싶습니다. 레일즈는 구조 특성상 이런 형태의 조합을 사용하기 쉽지 않다고 생각하기 때문입니다. (<code>ActiveSupport::Concern</code>, <code>Single Inheritance Table</code> 등)</p>\n<p>자바스크립트에서 조합을 사용하는 것을 권장하는 글도 최근에 읽고 큰 감명을 받았는데, 한번 살펴보시길 권하면서 링크를 남깁니다.</p>\n<ul>\n<li><a href="https://developers.caffeina.com/object-composition-patterns-in-javascript-4853898bb9d0">https://developers.caffeina.com/object-composition-patterns-in-javascript-4853898bb9d0</a></li>\n<li><a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3">https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3</a></li>\n</ul>',
id:"/Users/rinae/Dev/blog/src/pages/posts/2017-07-16-how-to-avoid-inheritance-in-ruby-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-07-16",path:"/posts/how-to-avoid-inheritance-in-ruby-kor",title:"[번역] 루비에서 상속을 피하는 방법",tags:["Ruby","OOP","Translation"],category:"Translation"}},{excerpt:"이 글의 원문은  Yegor Bugayenko가 작성하였습니다. 오역 지적 및 더 나은 번역을 위한 제안은 언제나 환영합니다. 코드 평가 (다른 말로 동료 평가)는 모든 소프트웨어 개발 팀의 필수 원칙이 되어야합니다. 제 말에 이견이 없기를 바랍니다. 어떤 팀은 머지가 되기 전에 코드 평가를 하여 master/development…",html:'<ul>\n<li>이 글의 원문은 <a href="http://www.yegor256.com/2015/02/09/serious-code-reviewer.html">Yegor Bugayenko가 작성하였습니다.</a></li>\n<li>오역 지적 및 더 나은 번역을 위한 제안은 언제나 환영합니다.</li>\n</ul>\n<hr>\n<p><a href="http://en.wikipedia.org/wiki/Code_review">코드 평가</a>(다른 말로 동료 평가)는 모든 소프트웨어 개발 팀의 필수 원칙이 되어야합니다. 제 말에 이견이 없기를 바랍니다. 어떤 팀은 머지가 되기 전에 코드 평가를 하여 master/development 브랜치에 우연찮은 실수가 <a href="http://www.yegor256.com/2014/07/21/read-only-master-branch.html">덮어씌워지지 않도록</a> 하고, 어떤 팀은 머지가 된 후에 버그나 어긋나는 점을 발견하기 위해 코드의 작성자와 <a href="http://www.yegor256.com/2014/12/18/independent-technical-reviews.html">일반적인 평가</a>를 합니다. 어떤 팀은 둘 다 하기도 합니다. 코드 평가는 평가자가 소프트웨어 전체 소스의 접근 권한을 가지고 결점을 찾아내는 <a href="https://ko.wikipedia.org/wiki/%ED%99%94%EC%9D%B4%ED%8A%B8%EB%B0%95%EC%8A%A4_%EA%B2%80%EC%82%AC">화이트박스 평가</a> 기술과 아주 유사합니다. 어느 경우든 코드 평가는 퀄리티 향상 및 팀의 동기 부여를 위한 좋은 도구가 됩니다.</p>\n<p>하지만 코드 평가를 제대로 하기는 어렵습니다. 오히려 잘못 하기가 훨씬 쉽다고 말씀드리고 싶습니다. 제가 여태까지 본 바로는 대부분의 코드 평가와 평가자는 비슷한 실수를 반복해왔습니다. 그래서 제가 알고 있는 좋은 코드 평가자들이 가지고 있는 네 가지 기본 원칙을 정리하는 글을 작성하게 되었습니다. 이 글이 도움이 되길 바랍니다.</p>\n<h2 id="두려움을-가지지-않기no-fear"><a href="#%EB%91%90%EB%A0%A4%EC%9B%80%EC%9D%84-%EA%B0%80%EC%A7%80%EC%A7%80-%EC%95%8A%EA%B8%B0no-fear" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>두려움을 가지지 않기(No Fear)</h2>\n<p>진짜배기 코드 평가자라면 갖지 말아야 할 몇 가지 두려움이 있습니다. 첫 번째이자 가장 유명한 두려움은 코드의 작성자를 공격하는 일입니다. <em>"오늘은 그냥 눈을 감고 저 버그를 못 본척 하면 내일 작성자는 내 실수(버그를 못 봄)를 알아차리지 못할거야."</em> - 이런 태도가 만들어내는 두려움입니다. 말할 필요도 없겠지만 이는 비생산적이고 코드 퀄리티와 팀의 사기를 낮추는 일입니다. 조언을 드리자면 직설적이고, 솔직하고, 간결하게 이야기하세요. 당신이 이 코드가 맘에 들지 않는다면 말 그대로 맘에 들지 않는겁니다. 당신의 의견이 코드의 작성자에게 어떻게 받아들여질지 신경쓸 필요가 없습니다.</p>\n<p>만약 당신이 동료를 향해 신경쓰이는 기분이 든다면 회사 혹은 팀의 경영 측면에서 문제가 있는 겁니다. 되려 못하는 사람에게 "팀 플레이어가 아니다" 라는 낙인찍힐까봐 두려워하고 있는 겁니다. 평가를 해야 하는 사람은 프로젝트 스폰서입니다. 스폰서는 당신이 제품의 질을 신경쓰지 않는 다른사람을 불쾌하게 한다고 얼마나 개선이 될 지 신경쓰지 않습니다. 그저 제품을 생산하여 사용자들로부터 돈을 벌어오길 원합니다. 스폰서는 당신이 <a href="http://www.yegor256.com/2015/10/06/how-to-be-good-office-slave.html">회사에서</a> 친구를 사귀라고 급여를 주는 게 아닙니다.</p>\n<p>다른 종류의 두려움은 이런 식으로 나타납니다. <em>"내가 이 코드를 거부하면 제품 발매(release)가 늦어질거야."</em> - 다시 한 번, 이런 태도는 프로젝트 전체에 커다란 해가 된다는 말씀을 드리고 싶습니다. 당신은 코드에서 마음에 들지 않는 부분을 눈 감고 외면한 뒤에 승인을 합니다. 코드는 다음 배포판에 포함될 예정이고 더 빨리 출시할 수 있게 되었습니다. 발매를 늦추는 병목현상도 없었으며 아무도 당신에게 \'저 지멋대로인 코드 평가자 때문에 발매가 늦춰지고 돈을 덜 벌게 되었다\' 는 말을 하지 않습니다. 당신은 좋은 팀 플레이어입니다. 그럴까요? 그럴리가요!</p>\n<p>지난 번 <a href="http://www.yegor256.com/2015/01/15/how-to-cut-corners.html">제가 언급했듯이</a>, 전문적인 팀 플레이어는 자신의 역할이 다른 사람 뒤를 봐주는 일이 아니라는 것을 알고 있습니다. <a href="http://www.yegor256.com/2015/11/24/imprisonment-for-irresponsible-coding.html">나쁜 코드</a>를 거부하여 발매가 늦어진다면, 이는 코드 작성자의 잘못입니다. 전문가로서 당신의 책임은 이런 결점을 찾아내는 것입니다. 이렇게 팀의 학습과 발전을 위해 도움을 주어야 합니다.</p>\n<p>저는 팀의 학습과 성장을 위해서 가장 먼저 해야할 일이 나쁜 프로그래머를 없애고 좋은 프로그래머를 끌어올리는 것이라 생각합니다. 솔직하고 두려움 없는 코드 평가자들은 팀의 학습과 성장을 돕습니다.</p>\n<p>또 이런 두려움도 있습니다. <em>"내가 잘못 본거라면 다른 사람들에게 놀림받을 거야"</em> - 더 심하면 다른 사람들이 당신이 부족한 지식을 가지고 있다고 지적할 수도 있고, 당신이 \'내가 대체 뭘 하고 있는지 모르겠다\' 는 표정을 짓고 있는 모습을 볼 수도 있습니다. 그렇다면 그냥 조용히 앉아서 버그를 못본 척 할 수도 있습니다. 최소한 멍청한 코멘트를 달았다고 당황하진 않을 테니까요. 당신은 더 똑똑해 보이기 위해 입을 다무는게 낫겠지요. 그렇겠지요? 틀렸다니까요!</p>\n<p>프로젝트(스폰서)는 괜찮은 모습을 보이라고 급여를 주는 게 아닙니다. 당신은 팀원에게 사랑받기 때문에 급여를 받는 게 아니라 매일 제품을 만들기 위해 급여를 받는 겁니다. 전문가로서 당신의 책임은 프로젝트를 위해 최선을 다하고, 그러기 위해 모두의 의견을 무시할 수도 있어야 합니다. 상급자의 의견도 포함해서요. <a href="http://www.yegor256.com/2015/01/26/happy-boss-false-objective.html">"행복한 상급자(대표) 만들기는 잘못된 목표다"</a> 라는 글의 내용과 비슷하게, \'팀에서 존경받는 사람 되기\'는 잘못된 목표라는 말씀을 드리고 싶습니다. 존경을 구걸하는 대신 깔끔한 코드를 짜면 자연스레 존경받게 됩니다.</p>\n<p>다시 한번 말씀드리자면 다른 사람의 코드에 잘못되거나 멍청한 코멘트를 달았다고 당황하게 되는 일을 두려워하지 마십시오. 다른 사람이 당신에게 가지고 있는 기대를 위하지 말고 프로젝트를 위해 최선을 다하십시오. 팀원들은 당신이 똑똑하고 총명하게 보이길 바랄 수 있겠지만, 프로젝트는 당신이 이 코드를 어떻게 생각하는지 말해주길 바랍니다. 그러니까 그런 사람들의 의견은 무시하세요. 당신이 올바르다고 생각하는 일을 하세요.</p>\n<h2 id="타협하지-않기no-compomise"><a href="#%ED%83%80%ED%98%91%ED%95%98%EC%A7%80-%EC%95%8A%EA%B8%B0no-compomise" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>타협하지 않기(No Compomise)</h2>\n<p>자, 당신은 두려움 없이 특정 코드에 대한 생각을 말하고 거부하였습니다. 당신이 평가하고 있던 브랜치는 좋지 않았고 그 이유도 설명했습니다. 그리고 작성자에게 이 부분은 고치고(Refactor) 저 부분은 다시 쓰라고 지시하였습니다. 그 다음은요?</p>\n<p>그/그녀는 당신과 거래를 하려고 할 겁니다. 이는 자연스러운 현상이고 저희 팀에서 제가 살펴보는 대부분의 브랜치에서 일어납니다. 코드의 작성자도 마찬가지로 전문 개발자이며 마찬가지로 두려움이 없습니다. 그래서 자신의 구현 방법이 옳았고 당신의 생각이 틀렸다고 주정합니다. 전문적인 코드 평가자라면 이 경우에 어떻게 해야할까요?</p>\n<p>가장 최악의 갈등 해결 방법은 \'\'타협하기\'\' 입니다. 나쁜 코드를 작성하는 것 보다 더 빠르게 제품의 질을 망치는 길입니다. 타협은 갈등 해결을 위해 양측이 원하는 것을 갖지 않기로(혹은 하지 않기로) 합의하는 방식의 갈등 조절 기술입니다. 다른 말로 표현하자면 <em>"우리 그만 싸우고 평화롭게 지내자"</em> 인데, 문제 해결 측면에서 최악의 방식입니다.</p>\n<p>좋지도 않은 타협을 하기보다, 전문가로서 코드 자체를 위해 실천할 수 있는 세 가지 방법이 있습니다.</p>\n<ul>\n<li><em>"당신 말이 맞아요, 제 생각을 철회합니다."</em>: 보통 이런 일이 자주 일어납니다. 당신은 자신의 실수를 인정할 준비가 되어있어야 합니다. 코드가 맘에 들지 않았지만 코드의 작성자가 이 코드를 적용할 때 생기는 이익을 설명하였고 당신은 그 로직을 받아들인 겁니다. 절대로 \'싸우기 싫어서\' 가 아니라 진정 로직을 이해하고 받아들이는 겁니다. 기꺼이 \'내가 틀렸습니다.\' 라고 말하는 것은 성숙하고 진지한 개발자의 첫 번째 덕목입니다.</li>\n<li><em>"난 절대 영원히 인정할 수 없어!"</em>: 어떤 코드는 이럴 수도 있는데, 이렇게 갈등을 해결하는 방법이 잘못된 것은 아닙니다. 상대방은 이 상황을 받아들이고 전부 다시 작성하게 되겠지요. 그리고 새로운 것도 배울 수 있을겁니다.</li>\n<li><em>"설계자가 뭐라고 하는지 들어보자!"</em>: 모든 프로젝트에는 최종적인 결정을 내리는 <a href="http://www.yegor256.com/2014/10/12/who-is-software-architect.html">소프트웨어 설계자</a>가 있습니다. 이 사람에게 말하고 최종적인 결정을 내려달라고 부탁해 보세요. 토론이 벌어지고 있는 상황에서 설계자를 대려온 다음 한쪽 편을 들어달라고 이야기하는 겁니다. 그 사람이 당신이 잘못되었다고 이야기한다면 그 결정을 받아들이고, 이번 경험에서 새로이 무언가를 배우도록 노력해보세요.</li>\n</ul>\n<p>이와 같이 당신의 의견을 고수하며 싸우거나 잘못되었음을 인정하세요. 한 쪽을 고르되 절대 타협하지 마십시오!</p>\n<p>제 말을 잘못 받아들이지 마시길 바랍니다. 고집불통이 되라거나 나쁜 패를 죽어도 놓지 않는(holding your cards no matter how bad they are) 사람이 되라는 이야기가 아닙니다. 유연하게 생각하고 배울 점은 배우세요. 당신의 입장은 협의를 하면서 얼마든지 변할 수 있습니다만, 맘에 들지 않는 어떤 것이라도 받아들이면 안됩니다. 당신은 상대가 옳았음을 완전히 받아들이거나 (아니면 그 반대), 설계자가 \'이렇게 해라\' 라고 말했을 때만 갈등에서 빠져나올 수 있습니다. 중간 지점은 없습니다.</p>\n<h2 id="개소리하지-않기no-bullshit"><a href="#%EA%B0%9C%EC%86%8C%EB%A6%AC%ED%95%98%EC%A7%80-%EC%95%8A%EA%B8%B0no-bullshit" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>개소리하지 않기(No Bullshit)</h2>\n<p>이제 당신은 특정 메서드가 다르게 디자인 되어야한다고 고민없이 지적했습니다. 코드의 작성자는 그렇게 생각하지 않는다고 답변했지요. 그 코드를 다시 살펴보고 나서 자신의 주장을 굽히지 말아야겠다고 생각했다 칩시다. 당신은 여전히 자신이 옳다고 생각하고 타협할 생각도 없습니다. 이제 어떡할까요? 설계자를 부르기에 너무 이르기 때문에 상대방을 설득해보기로 했습니다.</p>\n<p>대부분의 경우 설득하는 일은 가르치는 일입니다. 당신은 상대방이 모르는 것을 알고 있기 때문에 그 메서드가 맘에 안든다고 생각했을 겁니다. 그 사람은 추가적인 교육이 필요한 상태이구요. 이제 동료를 가르칠 수 있는 기회가 왔습니다. 효과적인 가르침을 위해선 증거가 필요합니다. 당신은 자신의 논리를 단단히 하여 상대방이 이해하고 받아들일 수 있도록 해야합니다.</p>\n<p>링크나 기사, 책, 보고서, 예시 등을 준비하세요. <em>"나는 자바를 15년이나 써 왔으니 이걸 알고 있다"</em> 같은 소리는 도움이 되지 않습니다. 게다가 이런 방식의 논쟁은 당신의 설득력을 떨어뜨릴 뿐입니다.</p>\n<p>만약 설득하기 위한 증거가 충분하지 않다면 다시 생각해보세요. 당신이 틀렸을 수도 있습니다.</p>\n<p>그리고 당신이 하는 일은 평가하고 있는 코드가 잘못되었음을 증명하는 겁니다. 코드의 작성자는 아무것도 증명할 필요가 없습니다. 그/그녀의 코드는 기본적으로 훌륭하겠지요. 평가자는 어떻게, 왜 이 코드가 잘못된 경우인지 보여주어야 합니다. 다르게 말하자면 당신은 고소인이고 상대방은 피고소인이 되겠지요. 그 반대는 성립하지 않습니다(Not the other way around).</p>\n<h2 id="모욕하지-않기no-offense"><a href="#%EB%AA%A8%EC%9A%95%ED%95%98%EC%A7%80-%EC%95%8A%EA%B8%B0no-offense" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>모욕하지 않기(No Offense)</h2>\n<p>제일 마지막이자 제일 어려운 원칙을 알려드리겠습니다. 아무리 코드가 형편 없고 코드의 작성자가 고집불통이라도 전문가의 태도를 유지하세요. 솔직히 말씀드리자면 때로는 저도 이렇게 하기 아주 어렵다고 생각합니다. <a href="http://www.teamed.io/">teamd.io는</a> 광범위한 팀으로 작업을 하고 있고 매주 몇 명의 새로운 사람들을 고용합니다. 그들 중 일부는 <a href="http://www.yegor256.com/2014/10/29/how-much-do-you-cost.html">우리의 심사 기준</a>에도 불구하고 다소 어리석게 대처하는 것 처럼 보입니다.</p>\n<p>약 1년 전에, 새로 온 개발자가 이미 있는 자바 라이브러리에 작지만 새로운 기능(약 20~30줄 짜리 코드)을 추가해야 했습니다. 저는 그 때 웃긴 일을 겪었습니다. 그는 수백줄 짜리 코드를 작성한 뒤에 저에게 풀 리퀘스트를 보냈습니다(제가 코드 평가자였습니다). 그 코드는 완전 쓰레기였으며 심지어 그 사람이 작성한 것도 아니었습니다. 저는 보자마자 이 사람이 어딘가에서 찾아낸 코드를 복사했다는 사실을 간파했습니다. 그런데 제가 어떻게 했을까요? 어떻게 \'당신의 태도는 전문적인 개발자로서 용납될 수 없다\' 며 길길이 날뛰지 않고 이 코드를 거부할 수 있었을까요? 저는 시간을 좀 내서 객관적으로 그의 코드를 비판했습니다. 스타일, 디자인 등 수많은 진지한 코멘트를 달아서 그에게 전부 고치라고 말했고, 그 사람은 쓰레기를 전부 지운 뒤에 바닥부터 다시 코드를 작성했습니다. 그 작업 이후에 그 사람을 다시 보는 일은 없었습니다.</p>\n<p>제가 말씀드리고 싶은 것은 전문가를 다룰 때는 전문가다운 생각을 하기 쉽지만 <em>(역주: 제대로된 코드를 보면 사람답게 대화할 수 있다는 뜻으로 보입니다)</em>, 언제나 다른 경우를 접할 수도 있습니다. 하지만 아무리 당신이 보고 있는 코드가 형편없더라도 참을성을 가지고 설득력 있게 대하십시오.</p>\n<hr>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>정말 오랜만에 새 번역을 하게 되었습니다. 진작에 한번 읽어놓고 \'다음에 번역할 글은 너로 정했다!\' 라고 생각해놓고 모셔두었지만 어느새 시간이.. 바쁘다는 핑계는 댈 것도 없으며 제 자신의 게으름을 탓하게 됩니다.</p>\n<p>코드 리뷰(코드 평가)를 할 때 다른 분들은 어떻게 하는지 모르겠지만 여러 가지 이야기가 오가게 될 겁니다. 그 와중에 타협을 하는 경우도 적지 않게 많이 있을 테고, 아예 코드 리뷰 자체를 안하는 팀이 있을지도 모르겠네요. 타협과 관한 부분에서 특히 느낀 점이 많았습니다.</p>\n<p>아무쪼록 팀 단위로 작업을 하실 때 더 좋은 결과물을 만드는데 도움이 될 수 있기를 바랍니다.</p>',id:"/Users/rinae/Dev/blog/src/pages/posts/2017-05-27-four-nos-of-serious-code-reviewer-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-05-27",path:"/posts/four-nos-of-serious-code-reviewer-kor",title:"[번역] 진짜배기 코드 평가자라면 하지 말아야 할 네 가지",tags:["Programming","Code Review","Translation"],category:"Translation"}},{excerpt:"이 글의 원문은  Simone Carletti가 작성하였습니다. 오역 지적 및 피드백은 더 나은 번역을 위한 밑거름이 됩니다. 저는 제 자신을 활발한  StackOverflow  사용자라고 생각합니다. 사이트 활동이 하루의 업무량에 크게 좌지우지되긴 하지만요. 2009년에 StackOverflow에 가입하여 이 글을 쓰는 시점(2016년 12월)까지,  저는 12만 4천의 명성치를 얻었고  상위 30…",html:'<ul>\n<li><strong>이 글의 원문은 <a href="https://simonecarletti.com/blog/2016/12/how-i-use-stackoverflow/">Simone Carletti가 작성하였습니다.</a></strong></li>\n<li><strong>오역 지적 및 피드백은 더 나은 번역을 위한 밑거름이 됩니다.</strong></li>\n</ul>\n<hr>\n<p>저는 제 자신을 활발한 <a href="https://stackoverflow.com/">StackOverflow</a> 사용자라고 생각합니다. 사이트 활동이 하루의 업무량에 크게 좌지우지되긴 하지만요. 2009년에 StackOverflow에 가입하여 이 글을 쓰는 시점(2016년 12월)까지, <a href="https://stackoverflow.com/users/123527/simone-carletti">저는 12만 4천의 명성치를 얻었고</a> 상위 300명의 사용자 랭킹에 올랐습니다.</p>\n<p>가끔씩 다른 프로그래머들이 <em>어떻게 이렇게 활발히 활동할 수 있나요?</em> 혹은 <em>정말 StackOverflow가 좋은건가요 아니면 그냥 눈에 띄고 싶어서 그러는건가요?</em>, <em>하루에 StackOverflow에서 얼마나 시간을 보내시나요?</em> 같은 질문을 하곤 합니다. 저는 이번 포스트를 통해 다양한 질문들을 모아 대답하고 <em>제가 StackOverflow를 어떻게 사용하는지</em> 설명해보고자 합니다.</p>\n<h2 id="정말-가치있는-일인가"><a href="#%EC%A0%95%EB%A7%90-%EA%B0%80%EC%B9%98%EC%9E%88%EB%8A%94-%EC%9D%BC%EC%9D%B8%EA%B0%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>정말 가치있는 일인가?</h2>\n<p>솔직히 말씀드리겠습니다. (거의) 모든 사람은 가치 없는 일에 매달리지 않습니다(nobody does something for nothing). 우리 모두는 어떤 행동이 가장 중요한지 기대치에 따라 결정을 내립니다.</p>\n<p>하지만 우리 모두 행동의 가치를 매기는 기준이 다릅니다. 어떤 사람은 돈을 받는게 유일한 보상이라고 여기기도 하고, 반대로 어떤 사람은 다른 이들의 눈에 띄거나 명성을 얻는게 돈을 버는 일보다 가치있다고 여깁니다. 특정인들에게 행복이란 단어는 부와 명예와 같은 의미이고, 나머지 사람들에게는 삶의 방식과 직접적으로 연관된 의미입니다.</p>\n<p>이 개념을 프로그래밍의 특정 주제에 적용할 수 있습니다. 바로 오픈 소스입니다. 저는 오픈 소스에 기여하는게 가치 없는 일이고, 그 이유가 <em>돈이 안되어서</em> 라고 말하는 사람들을 많이 보았습니다. 하지만 제게 <a href="https://github.com/weppos">오픈 소스에 기여</a>하는 이유를 물으신다면, 이 일이 저를 더 나은 프로그래머로 만들어주고 제 경력에 긍정적인 도움이 되기 때문이라고 대답할 겁니다. 제가 오늘 직업을 가지고 있는 이유 중 하나가 오픈 소스에 기여하기 때문이며, 뿐만 아니라 여지껏 대단한 사람들과 함께 놀라운 코딩 여정을 함께할 수 있는 기회도 얻었습니다.</p>\n<p>다시 StackOverflow 이야기로 돌아와서, 저는 StackOverflow 안에서 어떤 가치를 발견했기 때문에 참여하기 시작했습니다. 요즘 가입하는 대부분의 신규 사용자들과 달리, 저는 그 때 별다른 도움이 필요치 않았습니다. 사실 가입하고 몇달이 지나서야 처음 질문을 올릴 정도였으니까요.</p>\n<p>2009년에 저는 이미 꽤 쓸만한 개발자였습니다만, 제 활동의 대부분은 이탈리아 커뮤니티에 한정되어 있었습니다. 제가 StackOverflow에서 발견한 것은 바로 세계적인 커뮤니티 안에서 경험과 명성을 얻고, 눈에 띌 수 있는 기회였습니다.</p>\n<p>이렇게 제가 StackOverflow에 가입한 이유를 설명드렸습니다. 하지만 제가 7년이나 계속 답변들을 달게 된 이유는 더 있습니다.</p>\n<h2 id="끊임없는-두뇌-훈련"><a href="#%EB%81%8A%EC%9E%84%EC%97%86%EB%8A%94-%EB%91%90%EB%87%8C-%ED%9B%88%EB%A0%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>끊임없는 두뇌 훈련</h2>\n<p>제가 StackOverflow에 엄청난 양의 시간을 투자한 이유 중 단연 첫 번째는 끊임없는 두뇌 훈련을 위해서입니다.</p>\n<p>어떤 사람들은 두뇌 훈련을 위해 십자말풀이를 하거나, <a href="https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%8F%84%EC%BF%A0">스도쿠</a>를 하기도 합니다. 개인적으로 저는 알고리즘, 데이터 마이닝, 프로그래밍 언어와 같이 각기 다른 분야에 걸쳐있는 작은 프로그래밍 문제들을 해결하면서 두뇌 훈련을 하는게 좋습니다.</p>\n<p>그래서 일반적으로 가능한 구현의 변수가 많거나 많은 양의 계층에 걸쳐진 문제같이(예를 들자면 Ruby on Rails와 관련된 질문인데 뷰, 컨트롤러, 데이터베이스의 코드가 다 담겨있는 경우) 큰 규모의 질문은 무시합니다. 대신 작고 잘 정의되어있는 질문은 10분 안에 충분히 답을 할 수 있어서 좋아합니다.</p>\n<h2 id="디버깅-기술-향상"><a href="#%EB%94%94%EB%B2%84%EA%B9%85-%EA%B8%B0%EC%88%A0-%ED%96%A5%EC%83%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>디버깅 기술 향상</h2>\n<p>적절하게 소프트웨어의 일부를 디버그하는 능력은 소프트웨어 엔지니어에게 아주 가치있는 기술 중 하나입니다.</p>\n<p>만약 자신의 코드를 디버깅하는게 힘들다면, 다른 사람의 코드를 디버깅하는 일은 더욱 힘들겁니다. 게다가 실제로 만날 수도 없는 상태이다보니, 의사소통이 훨씬 더 복잡해집니다. 여러분은 디버깅에 필요한 정보를 빨리 얻기 위해 최대한 적절한 질문을 떠올려야 합니다.</p>\n<p>StackOverflow의 질문들은 \'언제나 디버깅할 거리는 무수히 많다\'는 점을 보여줍니다. 시간을 들여 답변하기에 적절한 질문을 고르는 기술도 익히게 됩니다.</p>\n<p>때로는 제가 쓰지 않는 라이브러리나 제가 모르는 내용을 디버깅하는 질문에 뛰어들기도 합니다. 이를 통해 저는 <a href="https://simonecarletti.com/blog/2009/09/inside-ruby-on-rails-reading-StackOverflowurce-code/">계속 다른 사람의 코드를 읽는 훈련을 했습니다.</a> 웃긴 이야기를 하나 해 드리겠습니다. 제가 사용하고 있는 특정 라이브러리에 관한 해결책을 찾고 있을 때, 저는 제가 겪었던 문제와 정확히 똑같은 질문을 StackOverflow에서 찾았고 그 질문은 제대로 답변도 달려있었습니다. 별 이상한 점은 없었습니다. 그 답변을 달았던 사람이 저였다는걸 깨닫기 전까지는 말이죠! 비슷한 일이 몇번 있었습니다.</p>\n<h2 id="새로운-언어를-배우고-자신의-진도를-확인하기"><a href="#%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%96%B8%EC%96%B4%EB%A5%BC-%EB%B0%B0%EC%9A%B0%EA%B3%A0-%EC%9E%90%EC%8B%A0%EC%9D%98-%EC%A7%84%EB%8F%84%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>새로운 언어를 배우고 자신의 진도를 확인하기</h2>\n<p>저는 새로운 프로그래밍 언어나 기술을 배우기 좋아합니다. 이때는 절대로 StackOverflow를 사용하지 않고, 책이나 온라인 자료에 의지합니다. 하지만 StackOverflow는 자신의 진도를 테스트하는데 아주 좋은 수단이라는 사실을 깨달았습니다.</p>\n<p>불과 몇주 전에 자신이 배우기 시작한 분야에 다른 사람이 질문을 올렸는데, 그 질문에 답변을 할 수 있다면 엄청나게 뿌듯한 기분이 듭니다.</p>\n<p>요즘에는 StackOverflow에 올라온 질문에 답변을 달고, 그 답변이 채택되는 일이 그렇게 간단하지 않습니다. 엄청난 수의 전문가들이 매일 접속해있으니까요. 간단한 질문은 빠르면 몇 분 이내에 답변이 달리기도 하고, 심지어 여러분이 문제를 다 읽기도 전에 답변이 달릴 때도 있습니다. 대신 더 복잡한 질문은 시간이 걸리겠지만, 새로운 주제를 배우고 있는 상태에서 건드리기엔 너무 어렵습니다.</p>\n<p>따라서 적절한 질문을 선택한 뒤, 합리적인 시간 안에 올바른 해결책을 제시하는 일은 새로운 주제를 배우면서 진도를 테스트하는 좋은 방법입니다.</p>\n<p>저는 개인적으로 세 단계의 학습 과정을 가지고 있습니다.</p>\n<ol>\n<li>첫 번째 단계로 열심히 학습하는 동안 간단한 질문들을 읽고 답변을 떠올리지만, <em>실제로는 답변하지 않습니다.</em></li>\n<li>두 번째로 충분한 지식 기반을 쌓았을 때, 좀 쉬운 질문에만 답변을 쓰려고 하거나 이미 알맞은 해결책이 존재한다면 링크를 제공하기도 합니다. <em>제가 정말 이 답이 맞다고 자신있게 생각한다면</em> 직접 답변을 달기도 합니다. 저는 손쉽게 +1을 얻고자 하는게 아니기 때문에 진짜 적절한 해결책이라는 자신이 없다면 답변을 달지 않습니다. 보통 두 번째 단계가 가장 긴 단계인데, 이후 세 번째 단계로 자연스레 이어지게 됩니다.</li>\n<li>세 번째는 해당 주제에 상당한 양의 지식을 갖게 되고, 관련된 대부분의 질문에 대답을 하거나 디버깅할 수 있는 단계입니다. 물론 이 단계에 이르기까지 많은 시간이 들 뿐 아니라, 모든 프로그래밍 관련 주제에서 이 단계까지 다다를 필요는 없을 겁니다.</li>\n</ol>\n<p>일반적으로 두 번째 단계를 목표로 하셔야 합니다. 특정 주제에 관한 질문을 이해하고 괜찮은 수준의 답변을 할 수 있을 정도가 되어야 합니다. 비록 대부분의 경우 여러분이 올바른 해결책을 떠올리기까지 걸리는 시간이 다른 숙련된 개발자들에 비해 느리다고 하더라도 괜찮습니다. 답변을 다는 시간을 줄이는 능력은 더 많은 경험에서 우러나오기 마련인데, 반드시 시간 줄이기를 목표로 삼을 필요는 없습니다.</p>\n<h2 id="사용자-지원"><a href="#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A7%80%EC%9B%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>사용자 지원</h2>\n<p>가끔 누군가가 <a href="https://dnsimple.com/">DNSimple(작성자가 몸 담고 있는 서비스)</a>과 관련된 질문을 올릴 때도 있습니다. 대부분의 질문은 자신의 소프트웨어를 연결하거나 도메인을 등록하는 등 DNSimple이 하나의 구성요소인 경우가 많습니다.</p>\n<p>질문에 이미 제시된 답변이 없는 경우 저는 가능한 한 대화에 끼어들어 답을 제공하려 합니다. 만약 필요한 지식을 모르고 있다면 다른 DNSimple 팀원을 불러 그 사람과 함께 알맞은 해결책을 작성해봅니다.</p>\n<p>저는 StackOverflow에서 <a href="https://stackoverflow.com/questions/tagged/dnsimple">dnsimple</a> 태그를 구독해두었습니다. 그리고 때로는 <a href="https://serverfault.com/">ServerFault</a>와 <a href="https://webmasters.stackexchange.com/">Webmasters Stack Exchange</a>에서 <code>dnsimple</code> 키워드를 찾아보기도 합니다.</p>\n<h2 id="온라인-평판"><a href="#%EC%98%A8%EB%9D%BC%EC%9D%B8-%ED%8F%89%ED%8C%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>온라인 평판</h2>\n<p>작년에 저는 <em>온라인 평판</em>을 쌓는 것이 중요하다는 이야기를 많이 들었습니다. 이게 SEM(Search Engine Marketing) 회사들이 다른 회사들더러 온라인 활동에 투자하도록 꼬드기는 가장 일반적인 방법 중 하나입니다.</p>\n<p>온라인 평판은 마찬가지로 사람에게도 중요합니다. 특히 여러분의 주 활동 영역이 어떻게든 컴퓨터나 프로그래밍, 혹은 인터넷이랑 직접적인 연관이 있는 분야라면 말입니다.</p>\n<p>StackOverflow는 <a href="https://en.wikipedia.org/wiki/Show,_don&#x27;t_tell"><em>말하지 말고 행동으로 보이라</em></a> 는 접근 방식으로 온라인 평판을 쌓는 아주 좋은 방법입니다. StackOverflow에 있는 질문에 적절히 답을 하면서 여러분은 자신의 경험을 내보일 수 있습니다. 경험이 있는 척 하거나 다른 사람에게 무엇을 잘 한다고 말만 하고 다니는 것보다 훨씬 직접적입니다. 물론 다른 결과가 나올 수도 있습니다. 질문과 답변은 공개되어있고 몇 년 뒤에도 지워지지 않기 때문에, 자신의 기술 혹은 소통 능력의 약점을 드러낼 수 있기 때문입니다.</p>\n<p>예전부터 저는 최소한 두 가지 유형의 StackOverflow 프로필을 가지고 있는 사람들과 이야기해왔습니다. 첫 번째는 자신들의 온라인 평판에 긍정적인 영향을 미치는 방식으로 소통을 해온 사람들이고, 두 번째는 자신이 <em>너무 멍청하다고</em> 자책하며 질문을 올리는 사람들이었습니다.</p>\n<p>기억하세요. 바보같은 질문은 없습니다. 아무리 질문이 쉽다 하더라도 정말 중요한 것은 질문하는 방식(그리고 여러분이 적절한 답을 찾아보거나 최소한 노력이라도 했는지) 입니다. 저는 특정 분야에 제가 지식이 부족하다는 이야기를 하면서 질문하는데 아무런 거리낌이 없습니다. 제가 <a href="https://dba.stackexchange.com/">DBA</a>나 <a href="https://vi.stackexchange.com/">Vim</a> 사이트에 올린 질문들은 대부분 제 자신이 해당 분야의 전문가가 아니지만, 더 배우고 발전하고자 하는 의지를 보이고 있습니다.</p>\n<h2 id="온라인-노출도"><a href="#%EC%98%A8%EB%9D%BC%EC%9D%B8-%EB%85%B8%EC%B6%9C%EB%8F%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>온라인 노출도</h2>\n<p>온라인 평판이 여러분의 프로필을 발전시키는데 직접적으로 연관되어 있다면, 온라인 노출도는 여러분이 온라인에서 보여지는 횟수를 뜻합니다.</p>\n<p>Github는 프로그래머에게 온라인 평판(인터뷰에 지원할 때 자신의 오픈 소스 기여를 링크로 제공할 수 있기 때문에)과 온라인 노출도를 기르는 최적의 장소입니다. 하지만 Github와 비교하면 StackOverflow는 일반적으로 검색 엔진에서 많이 보이게 됩니다. 저는 여지껏 검색 엔진을 이용해서 StackOverflow에 있는 문제와 해결책을 찾는 데 어려움을 겪었다는 프로그래머를 본 적이 없습니다.</p>\n<p>StackOverflow는 검색 엔진에서 높은 우선순위를 가지고 있기 때문에, StackOverflow에서 명성을 얻는 일은 아마 여러분의 온라인 노출도에 직접적, 간접적으로 영향을 주게 됩니다. 직접적으로는 StackOverflow의 랭킹이 올라가고, 간접적으로 여러분이 답변을 달았던 질문이 검색 엔진의 결과 페이지에 나타나기 때문입니다.</p>\n<h2 id="영어-배움터"><a href="#%EC%98%81%EC%96%B4-%EB%B0%B0%EC%9B%80%ED%84%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>영어 배움터</h2>\n<p>저는 영어 원어민이 아닙니다. 영어로 글을 쓰는 일은 저에게 여전히 어렵고, 이탈리아어로 쓰는 일보다 훨씬 어려우며, 다른 사람이 영어로 쓴 글을 읽는 일보다 더욱 어렵습니다.</p>\n<p>StackOverflow는 제 영어 쓰기 실력을 기르는데 아주 좋은 기회를 제공해줍니다. 누구나 제 답변을 수정하거나 오타를 교정할 수 있기 때문입니다. StackOverflow는 모든 변경 사항의 이력을 가지고 보존하기 떄문에, 저는 언제나 제 글에 다른 사람들이 도움을 준 부분을 살펴볼 수 있습니다. 실수로부터 배우는 일은 저에게 아주 좋은 방법입니다.</p>\n<h2 id="결론"><a href="#%EA%B2%B0%EB%A1%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>결론</h2>\n<p>StackOverflow에 있는 질문에 답변을 작성하는 것은 <em>일반적으로</em> 저에게 기쁜 경험입니다. 저의 태도와 개인적인 역량에 긍정적인 영향을 주기 때문입니다. 하지만 긍정적인 경험이 짜증나는 일이 되도록 하지 않기 위해 이 일을 의무로 여기지 않고 있습니다.</p>\n<p>저는 최소 몇시간 혹은 최소 몇일에 한번 답변을 해야한다거나, 하루에 얼마만큼의 명성을 쌓아야 한다고 목표치를 정해놓지 않았습니다. 마지막으로 로그인한 시간이 좀 지났다 하더라도 찝찝한 기분이 들지도 않습니다.</p>\n<p>저는 하루 일과와 StackOverflow에 머물러 있는 시간의 균형을 유지하려고 노력합니다. 주로 테스트나 배포가 끝나길 기다리는 동안 하루에 30분에서 한 시간정도만 머물러 있습니다.</p>\n<p>StackOverflow에 기여하는 일은 두뇌를 단련하고, 소프트웨어 엔지니어로서 자신의 기술을 끌어올리며, 저의 온라인 평판과 노출도를 항샹시키는 긍정적인 부가 효과도 있습니다. 이 모든 이유가 제가 7년 동안 질문에 답하기 위해 <em>투자한</em> 시간을 정당화합니다.</p>\n<hr>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>글 내용이 꽤 길어서 힘들었지만 유익한 내용이었습니다. 저를 비롯한 많은 개발자들이 StackOverflow에서 이미 답변된 질문 위주로 검색을 하고, 답을 얻어서 문제를 해결할 생각은 하겠지만 직접 질문을 올리거나 답변을 작성할 생각은 별로 해 본적이 없을겁니다. 영어라는 장벽 때문이겠지요. 거기다 \'바빠 죽겠는데 이런데 글 쓰고 앉아있을 시간이 어디 있겠느냐\' 같은 생각도 할 수 있겠네요.</p>\n<p>이 글을 읽고 나니 StackOverflow를 적극적으로 사용하는 일은 Github으로 참여하는 오픈 소스 생태계와 비슷한 점이 많다고 느꼈습니다. 보통은 자신의 코드가 직접적으로 남는 Github쪽을 선호하겠지만, 오히려 무리해서 \'<a href="https://blog.outsider.ne.kr/1193">일일 커밋</a>\'을 하기보단 차근차근 StackOverflow에 적극적으로 참여하는 것도 개발자의 실력을 갈고닦는데 큰 도움이 되겠습니다.</p>\n<p>그리고 다른 어느 부분보다 글의 결론 부분이 와 닿았습니다. 우리는 보통 각자의 생업이 있고, 아무리 좋은 의도를 가진 행동도 의무가 되어야 할 필요는 없다고 생각합니다. 스타워즈의 요다 선생이 <strong>"Do. Or do not. There is no try."</strong> 라고 말씀하셨지만, 이번 경우에는 정 반대로 생각해보면 마음이 한결 편해집니다. <strong>"아예 안하는 것 보다는 시도라도 해 보는게 낫지 않을까"</strong></p>',id:"/Users/rinae/Dev/blog/src/pages/posts/2017-04-15-how-i-use-stackoverflow-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-04-15",path:"/posts/how-i-use-stackoverflow-kor",title:"[번역] 내가 StackOverflow를 사용하는 방법",tags:["Learning","Translation"],category:"Translation"}},{excerpt:"이 포스트는  Alex Kotliarskyi 의  글 을 번역한 것입니다. 오역 지적 및 피드백은 언제나 환영합니다. 저는 드디어  Cheng Lou 가 ReactConf'17에서 발표한 내용을 이해했습니다. 20분정도 시간을 내실 수 있다면 이 영상을 먼저 봐 주세요. 요약:  언어가 있으면  메타언어 (고차 언어)도 있다. 여기서 언어는 실제 소스 코드이고, 메타 언어는 그 위에 있는 모든 것(테스트, 주석, IDE…",html:'<ul>\n<li><strong>이 포스트는 <a href="http://frantic.im/">Alex Kotliarskyi</a>의 <a href="http://frantic.im/meta-language">글</a>을 번역한 것입니다.</strong></li>\n<li><strong>오역 지적 및 피드백은 언제나 환영합니다.</strong></li>\n</ul>\n<hr>\n<p>저는 드디어 <a href="https://twitter.com/_chenglou">Cheng Lou</a>가 ReactConf\'17에서 발표한 내용을 이해했습니다. 20분정도 시간을 내실 수 있다면 이 영상을 먼저 봐 주세요.</p>\n<iframe width="560" height="315" src="https://www.youtube.com/embed/_0T5OSSzxms" frameborder="0" allowfullscreen></iframe>\n<p><strong>요약:</strong> 언어가 있으면 <a href="https://ko.wikipedia.org/wiki/%EB%A9%94%ED%83%80_%EC%96%B8%EC%96%B4">메타언어</a>(고차 언어)도 있다. 여기서 언어는 실제 소스 코드이고, 메타 언어는 그 위에 있는 모든 것(테스트, 주석, IDE 기능, 문서, 예제, 튜토리얼, 블로그 글, 책, 비디오, 컨퍼런스 등의 기술 발표 등)을 뜻한다. 우리는 언어를 배우기 위해 메타언어를 사용한다. 우리가 메타언어의 개념을 언어 자체로 끌어내리면, 우리가 다루는 개념은 더욱 유연해지고 점차 새로운 메타언어를 만들어나갈 수 있게 된다. 새로운 메타언어는 같은 에너지를 쏟아도 기존 메타언어에 비해 더 고차원적이고 풍부한 형태를 가질 수 있게 된다.</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 790px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.5%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAAA5UlEQVQoz6WSX0vDQBDE+/0/muiDL4JY0bZJY7lL06T3f29v3ORBlBDa4MI83LH8mB1mgxuTc0Z2DkmpH3GMi/ubW0AiQrx4dC9n2H2HbAyK/P0LqE4BH1uDvk+wYQ6LIa8DfhmHp6PC80njVV/uAxo5pWkacdGjqqpJ3nuEENCnAe/XPT5NBUsOpfAfYFrr0PojVPsAdX5EZ7a4ypuZfgF5HZBsC6/eQK5F4XmGFFcAU0rIEkM+HJB3O7DW8x1Dy8DRkZPejflNHRQx86SlKaUsA0eQFhdKChylwKOGYUBd17hnvgGAkBLKECI+lQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="The Flow"\n        title=""\n        src="/static/2017-04-04-1b52eac1f90484ea982f2dbab689b235-ffc88.png"\n        srcset="/static/2017-04-04-1b52eac1f90484ea982f2dbab689b235-d16f8.png 198w,\n/static/2017-04-04-1b52eac1f90484ea982f2dbab689b235-f21b1.png 395w,\n/static/2017-04-04-1b52eac1f90484ea982f2dbab689b235-ffc88.png 790w,\n/static/2017-04-04-1b52eac1f90484ea982f2dbab689b235-81e7e.png 1185w,\n/static/2017-04-04-1b52eac1f90484ea982f2dbab689b235-c6d11.png 1200w"\n        sizes="(max-width: 790px) 100vw, 790px"\n      />\n    </span>\n  </span>\n  </p>\n<p>이 그림의 이해를 돕기 위해 다양한 예제를 준비해왔습니다.</p>\n<h2 id="어셈블리-명령어-→-변수명"><a href="#%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4-%E2%86%92-%EB%B3%80%EC%88%98%EB%AA%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>어셈블리 명령어 → 변수명</h2>\n<p>우주 산업 분야에서 행성으로부터의 <a href="https://ko.wikipedia.org/wiki/%ED%83%88%EC%B6%9C_%EC%86%8D%EB%8F%84">탈출 속도(escape velocity)</a>를 구하기 위해 사용되는 코드 일부를 살펴보겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-assembly"><code>.SUB_0_21:\n    ; Computes escape velocity\n    ; register xmm0 - planet mass\n    ; retister xmm1 - planet radius\n    mulsd   xmm0, qword ptr [rip + .LCPI0_0]\n    divsd   xmm0, xmm1\n    xorps   xmm1, xmm1\n    sqrtsd  xmm1, xmm0\n    ucomisd xmm1, xmm1\n    jp      .LBB0_2\n    movapd  xmm0, xmm1\n    ret\n.LBB0_2:\n    jmp     sqrt                    ; TAILCALL\n.LCPI0_0:\n    .quad   4459223850755291651     ; double 1.334816E-10</code></pre>\n      </div>\n<p>코드의 상당수가 메타언어에 기대고 있습니다. 이 코드에 대한 주석이나 문서(여기엔 보이지 않지만) 말입니다. 위 코드와 비교해서 C로 작성된 예를 살펴보겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">define</span> GRAVITY_CONSTANT 6.67408e-11</span>\n<span class="token keyword">double</span> <span class="token function">escape_velocity</span><span class="token punctuation">(</span><span class="token keyword">double</span> mass<span class="token punctuation">,</span> <span class="token keyword">double</span> radius<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> GRAVITY_CONSTANT <span class="token operator">*</span> mass <span class="token operator">/</span> radius<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>그저 변수에 이름을 지정해주었을 뿐인데 메타언어에 기대고 있던 정보를 언어 자체로 끌어내릴 수 있게 됐습니다.</p>\n<h2 id="변수명-→-심화-타입advanced-types"><a href="#%EB%B3%80%EC%88%98%EB%AA%85-%E2%86%92-%EC%8B%AC%ED%99%94-%ED%83%80%EC%9E%85advanced-types" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>변수명 → 심화 타입(Advanced Types)</h2>\n<p>C 버전의 코드는 어셈블리로 작성된 코드보다 훨씬 많은 정보를 가지고 있고, 메타언어도 더 높은 수준으로 이루어져 있습니다. 이제 우리는 반복 작성을 하거나 코드 안의 내용이 무엇인지 문서화할 필요가 없어졌습니다. 이 함수가 2개의 인자를 받아야 하며 첫 번째 인자는 질량, 두 번째 인자는 반경이라는 내용 말입니다.</p>\n<p>하지만 아직 문맥상 코드에 부족한 부분이 있습니다. 이 함수가 어느 단위 위에서 동작하는지 알 수가 없다는 겁니다. 당장은 라이브러리의 문서(메타언어)에 기댈 수 밖에 없습니다.</p>\n<p>우리는 인자 이름을 <code>mass_kilograms</code>, <code>radius_meters</code> 같은 이름으로 바꾸는 간단한 트릭을 써 볼수 있지만, 언어 자체에서 \'이 함수는 반드시 킬로그램과 미터를 입력해야한다\'고 보장해주는 장치가 없습니다.</p>\n<p>이제 더 복잡한 타입을 지원하는 언어의 예를 살펴보겠습니다. 저는 OCaml을 사용하겠지만 대부분의 ML-계열 언어들(하스켈, 스위프트 등)은 이런 기능을 지원합니다. (<a href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/units-of-measure">그리고 F#은 아예 단위에 대해 가장 높은 우선 순위로 지원을 하고 있습니다.</a>)</p>\n<div class="gatsby-highlight">\n      <pre class="language-ocaml"><code><span class="token keyword">let</span> gravity<span class="token punctuation">_</span>constant <span class="token operator">=</span> <span class="token number">6.67408e-11</span>\n\n<span class="token keyword">type</span> mass <span class="token operator">=</span> Kilograms <span class="token keyword">of</span> float\n<span class="token keyword">type</span> length <span class="token operator">=</span> Meters <span class="token keyword">of</span> float\n<span class="token keyword">type</span> velocity <span class="token operator">=</span> MetersPerSecond <span class="token keyword">of</span> float\n\n<span class="token keyword">let</span> escape<span class="token punctuation">_</span>velocity <span class="token punctuation">(</span>Kilograms mass<span class="token punctuation">)</span> <span class="token punctuation">(</span>Meters radius<span class="token punctuation">)</span> <span class="token operator">=</span>\n    MetersPerSecond <span class="token punctuation">(</span><span class="token number">2.0</span> <span class="token operator">*.</span> gravity<span class="token punctuation">_</span>constant <span class="token operator">*.</span> mass <span class="token operator">/.</span> radius <span class="token operator">|></span> sqrt<span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p><em>실은 지구로부터의 탈출 속도를 계산할 때 제 구현체에서 버그를 발견했습니다. 질량을 엉뚱한 단위로 입력하고 있었어요.</em></p>\n<p>위의 코드에서 <code>length</code> 와 <code>mass</code> 는 단순한 숫자가 아니라 1급 객체(first class citizen)입니다. 덕분에 더욱 안전하고 유지보수가 용이하며 코드를 발전시키기 쉬워졌지요. 예를 들어 우리가 야드파운드법을 지원하고자 한다면(왜 그래야하는지는 모르겠지만), <code>mass</code> 타입을 이렇게 바꾸면 됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ocaml"><code><span class="token keyword">type</span> mass <span class="token operator">=</span>\n  <span class="token operator">|</span> Kilograms <span class="token keyword">of</span> float\n  <span class="token operator">|</span> Pounds <span class="token keyword">of</span> float\n</code></pre>\n      </div>\n<p>이러면 타입 체커가 기존 코드에서 새 단위를 적용하기 위해 수정해야 할 부분을 낱낱이 지적해줄 겁니다.</p>\n<h2 id="사용되지-않을-경우deprecation와-다른-메타정보들"><a href="#%EC%82%AC%EC%9A%A9%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84-%EA%B2%BD%EC%9A%B0deprecation%EC%99%80-%EB%8B%A4%EB%A5%B8-%EB%A9%94%ED%83%80%EC%A0%95%EB%B3%B4%EB%93%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>사용되지 않을 경우(Deprecation)와 다른 메타정보들</h2>\n<p>우리가 기존의 탈출 속도보다 훨씬 정확한 값을 구할 수 있는 새로운 공식을 발견했다고 칩시다. 그렇다면 기존의 함수가 더 이상 사용되지 않는다고 표시하려면 어떻게 해야할까요?</p>\n<p>이럴 때 보통 주석이나 문서를 추가하거나 Medium에 글을 쓰는 등 메타언어를 구축할 것입니다. 하지만 메타언어로 구성된 정보들을 코드 자체로 끌어내리는게 훨씬 더 생산적인 방법입니다.</p>\n<p>전에 썼던 트릭처럼 C 함수의 이름을 바꾸어 <code>escape_velocity</code> 를 <code>escape_velocity_DEPRECATED</code> 나 <a href="https://github.com/facebook/react/blob/80bff5397bf854750dbe7c286f61654ea58938c5/src/umd/ReactUMDEntry.js#L21">이렇게 괴상한 이름으로 바꿀 수도 있습니다</a>. 하지만 이는 우리의 API가 변경되면서 클라이언트의 코드가 동작하지 않게 되고, 표준적인 방법도 아닙니다(누구나 자신만의 접미사를 붙일 수 있으니까요). 그리고 새로이 사용해야 할 메서드를 제대로 추천하지 않고 있습니다.</p>\n<p>만약 언어 자체가 이 메타정보를 알아서 알려주는 기능을 지원한다면 어떨까요?</p>\n<div class="gatsby-highlight">\n      <pre class="language-ocaml"><code><span class="token keyword">let</span> escape<span class="token punctuation">_</span>velocity <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">[</span><span class="token operator">@</span>ocaml<span class="token punctuation">.</span>deprecated <span class="token string">"Please use `quantum_escape` instead"</span><span class="token punctuation">]</span>\n</code></pre>\n      </div>\n<h2 id="추가-예시"><a href="#%EC%B6%94%EA%B0%80-%EC%98%88%EC%8B%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>추가 예시</h2>\n<p>지금까지 메타적 공간에 있던 많은 정보를 언어 자체에 심어주는 하나의 방법을 보여드렸습니다. 다른 예들을 보여드리겠습니다.</p>\n<p><strong><a href="https://ko.wikipedia.org/wiki/%EB%B9%84%EC%A7%80%ED%84%B0_%ED%8C%A8%ED%84%B4">방문자 패턴(Visitor Pattern)</a>과 <code>for</code> 루프 → map/filter/reduce:</strong> 제가 대학에 다닐 땐 방문자 패턴을 배웠지만, 이젠 이 패턴이 많은 언어에서 기본 라이브러리로 손쉽게 제공되고 있습니다.</p>\n<p><strong>상태(state) 불러오기:</strong> 저는 종종 사람들이 리액트 컴포넌트를 만들면서 상태를 이렇게 설정해두는 것을 보게 됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code>state <span class="token operator">=</span> <span class="token punctuation">{</span>\n  data<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  error<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  loading<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>이 경우 <code>loading</code> 이 <code>false</code> 라면 <code>data</code> 나 <code>error</code> 중에 하나가 <code>null</code> 이 되어서는 안된다는 안내를 하려면 메타언어를 사용할 수 밖에 없습니다. 그 대신 우리는 Flow나 타입스크립트(Typescript)를 사용하여 언어 단위에서 제약을 걸 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-typescript"><code><span class="token keyword">type</span> State <span class="token operator">=</span>\n  <span class="token punctuation">{</span> progress<span class="token punctuation">:</span> <span class="token string">\'loading\'</span> <span class="token punctuation">}</span> <span class="token operator">|</span>\n  <span class="token punctuation">{</span> progress<span class="token punctuation">:</span> <span class="token string">\'done\'</span><span class="token punctuation">,</span> data<span class="token punctuation">:</span> Object <span class="token punctuation">}</span> <span class="token operator">|</span>\n  <span class="token punctuation">{</span> progress<span class="token punctuation">:</span> <span class="token string">\'error\'</span><span class="token punctuation">,</span> error<span class="token punctuation">:</span> Error <span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p><strong>리덕스(Redux)와 불변성(Immutability):</strong> 현재는 문서, 블로그 포스트, 비디오, 컨퍼런스 발표 등에서 리덕스를 사용할 때 변수나 객체에 직접적으로 변화를 주지 않을 것을(lack of direct mutation) 전제하고 있습니다. 만약 자바스크립트가 기본적으로 불변 데이터 타입과 타입 선언(type annotations)을 제공한다면 위에서 말하는 전제를 코드에서 바로 표현할 수 있지 않을까요?</p>\n<p><strong>프로미스(Promises)와 옵저버블(Observables):</strong> 자바스크립트에서 프로미스 패턴은 라이브러리에서 제공하는 기능이었지만 이제 코어 기능으로 자리잡았습니다. <a href="https://github.com/tc39/proposal-observable">옵저버블</a>에도 같은 과정이 진행중입니다.</p>\n<h2 id="결론"><a href="#%EA%B2%B0%EB%A1%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>결론</h2>\n<p>아무리 메타언어를 언어로 끌어내린다 하더라도 사람 사이에 의사소통하는 부분을 해결할 수는 없다는 것을 새겨두시는게 좋습니다. 하지만 언어의 진화와 함께 우리는 더 효과적인 의사소통의 기회를 열어가고 있습니다.</p>\n<p>반드시 어딘가엔 복잡한 부분이 존재합니다. 만약 언어가 아주 단순하다면, 복잡한 부분은 메타언어에 머무르게 됩니다.</p>\n<p>참고로  <a href="https://www.youtube.com/watch?v=4anAwXYqLG8">Sebastian Markbåge의 최소한의 API 표현 범위(minimal API surface area)에 관한 발표와</a>, <a href="https://www.youtube.com/watch?v=V1po0BT7kac">Jared Forsyth의 타입 시스템에 대한 발표</a>를 살펴보세요. 아 그리고 영화 <a href="http://movie.daum.net/moviedb/main?movieId=105570">컨택트(Arrival, 2016)</a>도 꼭 보세요. 강추합니다!</p>\n<hr>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>처음 이 글을 접하게 된 계기는 이 코드 때문이었습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token comment">// explicit</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!==</span> undefined<span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">.</span>x<span class="token punctuation">;</span>\n\n<span class="token comment">// implicit</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">.</span>x<span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>보고 계시는 자바스크립트 코드에서 위쪽에 제시된 코드가 평균적으로 최대 15%까지 처리 속도가 빠르다고 합니다. <a href="https://twitter.com/dhh/status/846627223176167424">DHH는 트위터에서</a> \'어차피 15%라고 해봤자 실제로는 몇 밀리초 이하일텐데 왜 기계에게 맞추려고 하느냐\' 같은 내용의 비판을 쏟아내었지요. 코드를 어떻게 작성하실건지는 여러분의 취향에 맡기겠습니다.</p>\n<p>하지만 오늘 제가 드리고픈 말씀은 아래 트윗에 다 있기 때문에 후기를 짧게 줄이고자 합니다.</p>\n<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/dhh">@dhh</a> Code is not a conversation between a dev and a machine.&#13;&#13;Code is a conversation between a developer AND THE NEXT DEVELOPER.</p>&mdash; Don Schenck (@DonSchenck) <a href="https://twitter.com/DonSchenck/status/846675893909180416">March 28, 2017</a></blockquote>\n<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>',
id:"/Users/rinae/Dev/blog/src/pages/posts/2017-04-04-understanding-taming-the-meta-language-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-04-04",path:"/posts/understanding-taming-the-meta-language-kor",title:"[번역] 메타언어 길들이기",tags:["Programming","Learning","Translation"],category:"Translation"}},{excerpt:"본 포스트는  Aaron Patterson 의  포스트 의 번역본입니다. 기본적인 루비 및 레일즈 지식을 가지고 있는 독자 대상의 글입니다. 피드백은 언제나 환영합니다. 저는 콘솔 디버거입니다  (역주1: 원 제목의 'puts debuggerer'를 의역하였습니다. 루비의 puts는 전달받은 인자를 표준 출력(stdout)해주는 메서드입니다. 이후에도 puts debugging은 모두 콘솔 디버깅으로 번역하겠습니다) . 진짜 디버거(  pry…",html:'<ul>\n<li>본 포스트는 <a href="https://twitter.com/tenderlove">Aaron Patterson</a>의 <a href="https://tenderlovemaking.com/2016/02/05/i-am-a-puts-debuggerer.html">포스트</a>의 번역본입니다.</li>\n<li>기본적인 루비 및 레일즈 지식을 가지고 있는 독자 대상의 글입니다.</li>\n<li>피드백은 언제나 환영합니다.</li>\n</ul>\n<hr>\n<p>저는 콘솔 디버거입니다 <em>(역주1: 원 제목의 \'puts debuggerer\'를 의역하였습니다. 루비의 puts는 전달받은 인자를 표준 출력(stdout)해주는 메서드입니다. 이후에도 puts debugging은 모두 콘솔 디버깅으로 번역하겠습니다)</em>. 진짜 디버거( <code>pry</code> , <code>byebug</code> 등)를 사용하는 사람들을 폄하하고자 이 이야기를 하는게 아닙니다. 진짜 디버거는 아주 좋다고 생각하지만, 저는 하나라도 제대로 배울 시간을 들이지 못했습니다. 매번 한 개라도 써보려고 하다가 결국엔 한동안 사용하지 않고, 다시 사용방법을 배워야만 합니다. 어쨌든, 이번 기회에 여러분에게 콘솔 디버깅을 할 때 사용하는 트릭을 좀 알려드리고자 합니다. 저는 이 트릭들을 무언가가 어떻게 작동하는지 이해가 되지 않을때나 작동 원리를 더 알고싶을 때 사용합니다. 아래에 이야기하게 될 대부분의 것들은 <em>절대로</em> 최선의 방법(best practice)가 아니며 여러분들은 디버깅 세션이 끝나면 절대 이 코드들을 남겨두어선 안됩니다. 그러나 여러분이 <strong>무엇을 디버깅하던지</strong> 아주 유용하다고 생각합니다. 정말로 뭐든지요. 전역 변수, 메서드 재정의, 조건문 추가, 불러오기 경로 수정, 몽키 패칭, 콜 스택 출력 등 <strong>뭐든지요</strong>.</p>\n<p>저는 이 포스트에서 최대한 실제 접하는 예시들을 보여드리고 싶었습니다. 하지만 대부분의 예시들은 제가 레일즈의 보안 이슈를 디버깅하려고 할 때 나온 것들이라서, 이 코드의 테크닉은 재활용하셔도 좋지만 <strong>코드 전체를 그대로 쓰시면 안됩니다.</strong> 제가 디버깅하려는 코드들은 정상적으로 동작하지 않습니다. 거기다 이 코드를 사용하시는걸 원치도 않습니다.</p>\n<p>매 섹션에 제가 겪었던 문제들을 제목으로 적어두었으며, 내용 부분에 제가 사용한 해결책을 적어두었습니다.</p>\n<h2 id="어디에-문제가-있는진-알겠는데-어떻게-거기까지-가야할지-모르겠다"><a href="#%EC%96%B4%EB%94%94%EC%97%90-%EB%AC%B8%EC%A0%9C%EA%B0%80-%EC%9E%88%EB%8A%94%EC%A7%84-%EC%95%8C%EA%B2%A0%EB%8A%94%EB%8D%B0-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B1%B0%EA%B8%B0%EA%B9%8C%EC%A7%80-%EA%B0%80%EC%95%BC%ED%95%A0%EC%A7%80-%EB%AA%A8%EB%A5%B4%EA%B2%A0%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>어디에 문제가 있는진 알겠는데, 어떻게 거기까지 가야할지 모르겠다</h2>\n<p>가끔 저는 문제가 어딨는지는 알지만 어떻게 그 부분까지 가는지 모르는 이슈들을 디버깅할 때가 있습니다. 이럴 때마다 저는 <code>puts caller</code> 를 넣어서 콜 스택을 끄집어냅니다.</p>\n<p>예를 들어 제가 이런 코드를 작성했다고 칩시다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token constant">LOOKUP</span> <span class="token operator">=</span> <span class="token builtin">Hash</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token punctuation">{</span> <span class="token operator">|</span>h<span class="token punctuation">,</span> k<span class="token operator">|</span> h<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">Type</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token keyword">unless</span> k<span class="token punctuation">.</span>blank<span class="token operator">?</span> <span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>여기서 저는 기본 블록이 어떻게 호출되는지 알고 싶을 때 이렇게 합니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token constant">LOOKUP</span>\t\t<span class="token operator">=</span> <span class="token builtin">Hash</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token punctuation">{</span> <span class="token operator">|</span>h<span class="token punctuation">,</span> k<span class="token operator">|</span>\n  puts <span class="token string">"#"</span> <span class="token operator">*</span> <span class="token number">90</span>\n  puts caller\n  puts <span class="token string">"#"</span> <span class="token operator">*</span> <span class="token number">90</span>\n  h<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">Type</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token keyword">unless</span> k<span class="token punctuation">.</span>blank<span class="token operator">?</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>위의 코드는 90개의 해시 태그를 출력하고 콜 스택을 출력한 뒤에, 나머지 90개의 해시 태그를 출력할 겁니다. 해시 태그는 여러번 호출될 때를 대비해서 콜 스택을 쉽게 구분하기 위해 넣어두었습니다. 참고로 이걸 "해시 태그"라고 부르는건 여러분을 골려주려고 그러는 겁니다.</p>\n<p>저는 이 방법을 꽤 자주 사용하기 때문에 Vim 단축키를 지정해두었습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>" puts the caller\nnnoremap <leader>wtf oputs "#" * 90<c-m>puts caller<c-m>puts "#" * 90<esc></code></pre>\n      </div>\n<p>이렇게 하면 <code>&#x3C;leader>wtf</code> 키 조합으로 커서가 있는 위치 바로 밑에 디버깅 코드를 삽입합니다.</p>\n<h3 id="콜-스택을-한-번만-출력하고-싶어"><a href="#%EC%BD%9C-%EC%8A%A4%ED%83%9D%EC%9D%84-%ED%95%9C-%EB%B2%88%EB%A7%8C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B3%A0-%EC%8B%B6%EC%96%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>콜 스택을 한 번만 출력하고 싶어</h3>\n<p>그냥 콜 스택을 출력한 뒤에 <code>exit!</code> 를 사용하거나, <code>raise</code> 를 호출하세요. <code>raise</code> 는 예외를 출력할거고, 어쨌든 콜 스택을 볼 수 있을겁니다.</p>\n<h3 id="콜-스택을-특정-경우에만-보고-싶어"><a href="#%EC%BD%9C-%EC%8A%A4%ED%83%9D%EC%9D%84-%ED%8A%B9%EC%A0%95-%EA%B2%BD%EC%9A%B0%EC%97%90%EB%A7%8C-%EB%B3%B4%EA%B3%A0-%EC%8B%B6%EC%96%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>콜 스택을 특정 경우에만 보고 싶어</h3>\n<p>이건 그냥 디버깅 코드니까 여러분이 하고싶은대로 하시면 됩니다. 예를 들어 제가 해시에 무언가를 추가할 때마다 콜 스택을 호출하고 싶다고 한다면, 이렇게 하면 됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token constant">LOOKUP</span>\t\t<span class="token operator">=</span> <span class="token builtin">Hash</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token punctuation">{</span> <span class="token operator">|</span>h<span class="token punctuation">,</span> k<span class="token operator">|</span>\n  <span class="token keyword">unless</span> k<span class="token punctuation">.</span>blank<span class="token operator">?</span>\n    puts <span class="token string">"#"</span> <span class="token operator">*</span> <span class="token number">90</span>\n    puts caller\n    puts <span class="token string">"#"</span> <span class="token operator">*</span> <span class="token number">90</span>\n    h<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">Type</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>\n  <span class="token keyword">end</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>어차피 전 이 코드를 없애버릴거니까 어떤 이상한 조건문도 마음대로 추가할 수 있지요!</p>\n<h2 id="메서드를-호출했는데-이게-어디에-있는건지-모르겠다"><a href="#%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%96%88%EB%8A%94%EB%8D%B0-%EC%9D%B4%EA%B2%8C-%EC%96%B4%EB%94%94%EC%97%90-%EC%9E%88%EB%8A%94%EA%B1%B4%EC%A7%80-%EB%AA%A8%EB%A5%B4%EA%B2%A0%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>메서드를 호출했는데, 이게 어디에 있는건지 모르겠다</h2>\n<p>메서드를 호출했는데 그 메서드가 어디에 구현되어있는지 모를 때, 저는 <code>source_location</code> 메서드와 함께 <code>method</code> 메서드를 사용합니다. 예를 들어 (레일즈) 컨트롤러 안에 있는 액션이 <code>render</code> 메서드를 호출하고 있을 때, 저는 그 메서드를 어디서 호출하는지 알고 싶었습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> index\n  render params<span class="token punctuation">[</span><span class="token symbol">:id</span><span class="token punctuation">]</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>위의 코드를 이렇게 바꿔보겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> index\n  p <span class="token function">method</span><span class="token punctuation">(</span><span class="token symbol">:render</span><span class="token punctuation">)</span><span class="token punctuation">.</span>source_location\n  render params<span class="token punctuation">[</span><span class="token symbol">:id</span><span class="token punctuation">]</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>호출해보도록 하지요.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>$ curl http://localhost:3000/users/xxxx</code></pre>\n      </div>\n<p>그러면 로그에는 이렇게 출력됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>Processing by UsersController#show as */*\n  Parameters: {"id"=>"xxxx"}\n["/Users/aaron/git/rails/actionpack/lib/action_controller/metal/instrumentation.rb", 40]\nCompleted 500 Internal Server Error in 35ms (ActiveRecord: 0.0ms)</code></pre>\n      </div>\n<p>이제 저는 <code>render</code> 메서드가 <a href="https://github.com/rails/rails/blob/6fcc3c47eb363d0d3753ee284de2fbc68df03194/actionpack/lib/action_controller/metal/instrumentation.rb#L40">instrumentation.rb 파일의 40번째 줄</a>에 있다는 것을 알게 되었습니다.</p>\n<h2 id="super-메서드를-호출했는데-그게-어디에-있는건지-모르겠다"><a href="#super-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%96%88%EB%8A%94%EB%8D%B0-%EA%B7%B8%EA%B2%8C-%EC%96%B4%EB%94%94%EC%97%90-%EC%9E%88%EB%8A%94%EA%B1%B4%EC%A7%80-%EB%AA%A8%EB%A5%B4%EA%B2%A0%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>super</code> 메서드를 호출했는데 그게 어디에 있는건지 모르겠다</h2>\n<p><code>render</code> 메서드가 <a href="https://github.com/rails/rails/blob/6fcc3c47eb363d0d3753ee284de2fbc68df03194/actionpack/lib/action_controller/metal/instrumentation.rb#L43">super를 호출한다는 걸</a> 알게 되었습니다만, 저는 그게 어디에 구현되어있는지 모릅니다. 이 경우에 <code>method</code> 의 리턴 값에 <code>super_method</code> 를 사용합니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> index\n  p <span class="token function">method</span><span class="token punctuation">(</span><span class="token symbol">:render</span><span class="token punctuation">)</span><span class="token punctuation">.</span>source_location\n  render params<span class="token punctuation">[</span><span class="token symbol">:id</span><span class="token punctuation">]</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>위의 코드를 이렇게 바꿉니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> index\n  p <span class="token function">method</span><span class="token punctuation">(</span><span class="token symbol">:render</span><span class="token punctuation">)</span><span class="token punctuation">.</span>super_method<span class="token punctuation">.</span>source_location\n  redner params<span class="token punctuation">[</span><span class="token symbol">:id</span><span class="token punctuation">]</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>같은 요청을 해 보면 이런 결과를 얻을 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>Processing by UsersController#show as */*\n  Parameters: {"id"=>"xxxx"}\n["/Users/aaron/git/rails/actionpack/lib/action_controller/metal/rendering.rb", 34]\nCompleted 500 Internal Server Error in 34ms (ActiveRecord: 0.0ms)</code></pre>\n      </div>\n<p>이제야 <code>super</code> 가 <a href="https://github.com/rails/rails/blob/6fcc3c47eb363d0d3753ee284de2fbc68df03194/actionpack/lib/action_controller/metal/rendering.rb#L34">여기로 가는 게</a> 보입니다. 이 메서드는 마찬가지로 <code>super</code> 를 호출하지만, 그냥 위의 작업을 반복하여(아니면 그냥 loop를 쓰면 됩니다!) 제가 진짜 알아보고자 하는 메서드를 찾을 수 있습니다.</p>\n<h2 id="method-메서드의-구현체를-찾고자-한다면"><a href="#method-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EA%B5%AC%ED%98%84%EC%B2%B4%EB%A5%BC-%EC%B0%BE%EA%B3%A0%EC%9E%90-%ED%95%9C%EB%8B%A4%EB%A9%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>method</code> 메서드의 구현체를 찾고자 한다면?</h2>\n<p>때때로 <code>method</code> 를 이용한 트릭이 작동하지 않을 때가 있습니다. 제가 알아보려는 객체가 자신만의 <code>method</code> 메서드를 구현하고 있기 때문입니다. 예를 들어 저는 <code>request</code> 객체에 <code>headers</code> 메서드가 구현된 위치를 찾고자 할 때 이런 코드를 사용했습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> index\n  p request<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token symbol">:headers</span><span class="token punctuation">)</span><span class="token punctuation">.</span>source_location\n  <span class="token variable">@users</span> <span class="token operator">=</span> <span class="token constant">User</span><span class="token punctuation">.</span>all\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>제가 요청을 보내면 이런 에러가 뜹니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>ArgumentError (wrong number of arguments (given 1, expected 0)):\n  app/controllers/users_controller.rb:5:in `index\'</code></pre>\n      </div>\n<p>이 경우는 <code>request</code> 객체가 자신만의 <code>method</code> 를 따로 구현하고 있기 때문입니다. <code>headers</code>  메서드를 찾아내기 위해 메서드를 <code>Kernel</code> 로부터 분리하고 <code>request</code> 객체에 다시 바인드 한 뒤 실행해보겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> index\n  method <span class="token operator">=</span> <span class="token constant">Kernal</span><span class="token punctuation">.</span><span class="token function">instance_method</span><span class="token punctuation">(</span><span class="token symbol">:method</span><span class="token punctuation">)</span>\n  p method<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token symbol">:headers</span><span class="token punctuation">)</span><span class="token punctuation">.</span>source_location\n  <span class="token variable">@users</span> <span class="token operator">=</span> <span class="token constant">User</span><span class="token punctuation">.</span>all\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>요청을 다시 해보면 결과가 다르게 나옵니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>Processing by UsersController#index as */*\n["/Users/aaron/git/rails/actionpack/lib/action_dispatch/http/request.rb", 201]</code></pre>\n      </div>\n<p>이제서야 <code>headers</code> 메서드가 <a href="https://github.com/rails/rails/blob/6fcc3c47eb363d0d3753ee284de2fbc68df03194/actionpack/lib/action_dispatch/http/request.rb#L201">여기에</a> 구현되어 있다는 것을 발견했습니다.</p>\n<p>심지어 <code>method</code> 메서드의 구현체를 찾을 수도 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> index\n  method <span class="token operator">=</span> <span class="token constant">Kernal</span><span class="token punctuation">.</span><span class="token function">instance_method</span><span class="token punctuation">(</span><span class="token symbol">:method</span><span class="token punctuation">)</span>\n  p method<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token symbol">:method</span><span class="token punctuation">)</span><span class="token punctuation">.</span>source_location\n  <span class="token variable">@users</span> <span class="token operator">=</span> <span class="token constant">User</span><span class="token punctuation">.</span>all\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<h2 id="또-뭔가-호출했는데-이게-어딨는지-모르겠다"><a href="#%EB%98%90-%EB%AD%94%EA%B0%80-%ED%98%B8%EC%B6%9C%ED%96%88%EB%8A%94%EB%8D%B0-%EC%9D%B4%EA%B2%8C-%EC%96%B4%EB%94%A8%EB%8A%94%EC%A7%80-%EB%AA%A8%EB%A5%B4%EA%B2%A0%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>(또) 뭔가 호출했는데 이게 어딨는지 모르겠다</h2>\n<p>가끔 당장 사용하고 있는 메서드가 실제로는 문제의 본질이 아닐 수 있습니다. 그래서 <code>method</code> 메서드를 사용하는 트릭은 별 도움이 안될 겁니다. 이럴 때엔 저는 <code>TracePoint</code> 라고 하는 더 큰 추적기(a larger hammer)를 사용합니다. <code>render</code> 메서드로부터 호출 된 <em>모든</em> 메서드의 리스트를 추출하기 위해 다시 한번 예를 들어보겠습니다. 리스트에 보이는 메서드들은 <code>render</code> 메서드가 직접 호출한 것은 아니지만 어딘가로부터 호출 된 것입니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token comment"># GET /users</span>\n<span class="token comment"># GET /users.json</span>\n<span class="token keyword">def</span> index\n  <span class="token variable">@users</span> <span class="token operator">=</span> <span class="token constant">User</span><span class="token punctuation">.</span>all\n  tp <span class="token operator">=</span> <span class="token constant">TracePoint</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token symbol">:call</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token operator">|</span>x<span class="token operator">|</span>\n    p x\n  <span class="token keyword">end</span>\n  tp<span class="token punctuation">.</span>enable\n  render <span class="token string">\'index\'</span>\n<span class="token keyword">ensure</span>\n  tp<span class="token punctuation">.</span>disable\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>저기 위치한 <code>TracePoint</code> 는 모든 "호출(<code>:call</code>)" 이벤트마다 작동하고, 블록은 메서드 이름과 호출된 위치를 출력할 것입니다. 여기서 "호출" 이라 함은 루비 메서드가 호출되는 경우를 말합니다(C 메서드는 제외). 만약 C 메서드가 호출되는 것을 보고 싶으시다면 <code>:c_call</code> 을 사용하세요. 이 예시는 <em>엄청난 양의</em> 결과가 출력될겁니다. 저는 호출될 메서드가 꽤 적거나, 도대체 어디부터 찾아봐야 할지 모를 때 이 방법을 사용합니다.</p>\n<h2 id="예외가-일어나는-것은-알겠지만-어디서-발생하는지-모르겠다"><a href="#%EC%98%88%EC%99%B8%EA%B0%80-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B2%83%EC%9D%80-%EC%95%8C%EA%B2%A0%EC%A7%80%EB%A7%8C-%EC%96%B4%EB%94%94%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94%EC%A7%80-%EB%AA%A8%EB%A5%B4%EA%B2%A0%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>예외가 일어나는 것은 알겠지만, 어디서 발생하는지 모르겠다</h2>\n<p>예외가 발생할 때 <em>실제로</em> 어디서 예외가 발생했는지 모를 때가 있습니다. 이 예시는 레일즈 3.0.0을 기준으로 작성되었지만(참고로 이 문제는 수정되었습니다), 일단 이런 코드가 있다고 해보죠.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token constant">ActiveRecord</span><span class="token punctuation">:</span><span class="token symbol">:Base</span><span class="token punctuation">.</span>logger <span class="token operator">=</span> <span class="token constant">Logger</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token variable">$stdout</span>\n<span class="token constant">User</span><span class="token punctuation">.</span>connection<span class="token punctuation">.</span>execute <span class="token string">"oh no!"</span>\n</code></pre>\n      </div>\n<p>SQL은 작동하지 않을 테고, 예외가 일어날 겁니다. 그렇다면 예외가 어떻게 발생하는지 보겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>  SQL (0.1ms)  oh no!\nSQLite3::SQLException: near "oh": syntax error: oh no!\nactiverecord-3.0.0/lib/active_record/connection_adapters/abstract_adapter.rb:202:in `rescue in log\': SQLite3::SQLException: near "oh": syntax error: oh no! (ActiveRecord::StatementInvalid)\n\tfrom activerecord-3.0.0/lib/active_record/connection_adapters/abstract_adapter.rb:194:in `log\'\n\tfrom activerecord-3.0.0/lib/active_record/connection_adapters/sqlite_adapter.rb:135:in `execute\'\n\tfrom test.rb:6:in `<top (required)>\'\n\tfrom railties-3.0.0/lib/rails/commands/runner.rb:48:in `eval\'\n\tfrom railties-3.0.0/lib/rails/commands/runner.rb:48:in `<top (required)>\'\n\tfrom railties-3.0.0/lib/rails/commands.rb:39:in `require\'\n\tfrom railties-3.0.0/lib/rails/commands.rb:39:in `<top (required)>\'\n\tfrom script/rails:6:in `require\'\n\tfrom script/rails:6:in `<main>\'</code></pre>\n      </div>\n<p>여러분이 추적 내역(backtrace) 을 읽어보셨다면 <em>(역주2: backtrace하면 역추적 이라는 말이 직역하기는 좋지만, 보통 루비에서 backtrace를 떠올릴 때 콘솔에 뜨는 십수 줄의 추적 내역이 연상될 때가 많아서 추적 내역으로 번역하였습니다)</em>, 예외가 <a href="https://github.com/rails/rails/blob/9891ca8/activerecord/lib/active_record/connection_adapters/abstract_adapter.rb#L202">abstract_adapter.rb의 202번째 줄</a>에서 발생했다는 것을 알 수 있습니다. 그러나 이 코드는 <a href="https://github.com/rails/rails/blob/9891ca8/activerecord/lib/active_record/connection_adapters/abstract_adapter.rb#L199-L202">예외가 발생한 상황에서 다시 예외를 일으키도록</a> 되어있는게 보일 겁니다. 그렇다면 실제로는 어디서 예외가 일어난 걸까요? 정답을 찾기 위해 <code>puts</code> 를 사용하거나 루비의 <code>-d</code> 플래그를 사용할 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>[aaron@TC okokok (master)]$ bundle exec ruby -d script/rails runner test.rb</code></pre>\n      </div>\n<p><code>-d</code> 플래그는 경고를 활성화하고 모든 예외 발생을 출력합니다. 네, 실제로는 엄청나게 많은 양의 결과물이 출력되겠지요. 그러나 끝부분을 살펴보시면 이렇게 되어있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>Exception `NameError\' at activesupport-3.0.0/lib/active_support/core_ext/module/remove_method.rb:3 - method `_validators\' not defined in Class\nException `SQLite3::SQLException\' at sqlite3-1.3.11/lib/sqlite3/database.rb:91 - near "oh": syntax error\nException `SQLite3::SQLException\' at activesupport-3.0.0/lib/active_support/notifications/instrumenter.rb:24 - near "oh": syntax error\n  SQL (0.1ms)  oh no!\nSQLite3::SQLException: near "oh": syntax error: oh no!\nException `ActiveRecord::StatementInvalid\' at activerecord-3.0.0/lib/active_record/connection_adapters/abstract_adapter.rb:202 - SQLite3::SQLException: near "oh": syntax error: oh no!\nException `ActiveRecord::StatementInvalid\' at railties-3.0.0/lib/rails/commands/runner.rb:48 - SQLite3::SQLException: near "oh": syntax error: oh no!\nactiverecord-3.0.0/lib/active_record/connection_adapters/abstract_adapter.rb:202:in `rescue in log\': SQLite3::SQLException: near "oh": syntax error: oh no! (ActiveRecord::StatementInvalid)\n\tfrom activerecord-3.0.0/lib/active_record/connection_adapters/abstract_adapter.rb:194:in `log\'\n\tfrom activerecord-3.0.0/lib/active_record/connection_adapters/sqlite_adapter.rb:135:in `execute\'\n\tfrom test.rb:6:in `<top (required)>\'\n\tfrom railties-3.0.0/lib/rails/commands/runner.rb:48:in `eval\'\n\tfrom railties-3.0.0/lib/rails/commands/runner.rb:48:in `<top (required)>\'\n\tfrom railties-3.0.0/lib/rails/commands.rb:39:in `require\'\n\tfrom railties-3.0.0/lib/rails/commands.rb:39:in `<top (required)>\'\n\tfrom script/rails:6:in `require\'\n\tfrom script/rails:6:in `<main>\'</code></pre>\n      </div>\n<p>실제 예외는 여기서 발생했습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>Exception `SQLite3::SQLException\' at sqlite3-1.3.11/lib/sqlite3/database.rb:91 - near "oh": syntax error</code></pre>\n      </div>\n<p>그리고 여기서 다시 예외가 일어났지요.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>Exception `SQLite3::SQLException\' at activesupport-3.0.0/lib/active_support/notifications/instrumenter.rb:24 - near "oh": syntax error</code></pre>\n      </div>\n<p>예외가 발생할 때 래핑된 뒤 다시 예외가 발생하는 경우에는 <em>반드시</em> 본래의 추적 내역을 노출해야 합니다. 그러므로 이 경우는 명백히 버그지만, 실제로 버그는 고쳐졌으며, 우리는 언젠가 또 이런 경우가 발생했을 때 해결하는 법을 알게 되었습니다.</p>\n<h3 id="커맨드-라인-도구를--d-플래그와-함께-사용하여-실행"><a href="#%EC%BB%A4%EB%A7%A8%EB%93%9C-%EB%9D%BC%EC%9D%B8-%EB%8F%84%EA%B5%AC%EB%A5%BC--d-%ED%94%8C%EB%9E%98%EA%B7%B8%EC%99%80-%ED%95%A8%EA%BB%98-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%8B%A4%ED%96%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>커맨드 라인 도구를 <code>-d</code> 플래그와 함께 사용하여 실행</h3>\n<p>위의 기술을 RSpec 테스트에 적용하고 싶으시다면 이렇게 하시면 됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>$ ruby -d -S rspec</code></pre>\n      </div>\n<h3 id="-d-플래그는-사용하고-싶은데-프로세스를-실행하는-방법을-모르겠다"><a href="#-d-%ED%94%8C%EB%9E%98%EA%B7%B8%EB%8A%94-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%8B%B6%EC%9D%80%EB%8D%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%84-%EB%AA%A8%EB%A5%B4%EA%B2%A0%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>-d</code> 플래그는 사용하고 싶은데 프로세스를 실행하는 방법을 모르겠다</h3>\n<p>Rake 테스트 작업은 기본적으로 <a href="https://github.com/ruby/rake/blob/3c4fe3e25e5ab6b052f9e81bc2920ca4b4fc1094/lib/rake/testtask.rb#L105">서브 프로세스 안에서 당신의 테스트를 실행합니다</a>. 말인 즉슨 <code>ruby -d -S rake</code> 같은 커맨드를 입력해도 서브 프로세스 안에 있는 여러분의 테스트에는 플래그가 적용되지 않는다는 뜻입니다. 이 경우 저는 <code>RUBYOPT</code> 환경 변수를 사용합니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>[aaron@TC okokok (master)]$ RUBYOPT=-d bundle exec rake test</code></pre>\n      </div>\n<p><code>RUBYOPT</code> 환경 변수는 쉘에서 실행된 모든 루비 프로그램에 적용되고, 심지어 rake로부터 호출 된 서브 쉘에도 적용됩니다. 이를 응용하면 <code>rspec</code> 커맨드를 이렇게 다시 써볼 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>$ RUBYOPT=-d rspec</code></pre>\n      </div>\n<h2 id="이-객체는-어디에서-온-걸까"><a href="#%EC%9D%B4-%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%96%B4%EB%94%94%EC%97%90%EC%84%9C-%EC%98%A8-%EA%B1%B8%EA%B9%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>이 객체는 어디에서 온 걸까?</h2>\n<p>보통은 콜 스택을 출력하여 객체가 어디에서 왔는지 찾습니다. 하지만 가끔 객체가 콜 스택 바깥에 위치한 경우도 있습니다. 이럴 때는 객체가 어디에서 호출된 건지 찾기 힘듭니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> foo\n  x <span class="token operator">=</span> baz\n  bar x\n<span class="token keyword">end</span>\n\n<span class="token keyword">def</span> bar x\n  puts <span class="token string">"#"</span> <span class="token operator">*</span> <span class="token number">90</span>\n  puts caller\n  puts <span class="token string">"#"</span> <span class="token operator">*</span> <span class="token number">90</span>\n  p x\n<span class="token keyword">end</span>\n\n<span class="token keyword">def</span> baz<span class="token punctuation">;</span> zot<span class="token punctuation">;</span>\t\t<span class="token keyword">end</span>\n<span class="token keyword">def</span> zot<span class="token punctuation">;</span> <span class="token builtin">Object</span><span class="token punctuation">.</span><span class="token keyword">new</span>\t<span class="token class-name">end</span>\n\nfoo\n</code></pre>\n      </div>\n<p>이전에 "어디에 문제가 있는진 알겠는데, 어떻게 거기까지 가야할지 모르겠다" 파트에서 <code>caller</code> 를 사용하는 방법, "wtf  트릭" <em>(역주3: 글쓴이는 해당 방법을 소개할 때 Vim 단축키를 <code>&#x3C;leader>wtf</code> 으로 설정하였습니다. 그래서 이를 "wtf trick"으로 명명한 것으로 보입니다)</em>을 보여드렸습니다.  여기서 저는 <code>x</code> 라는 값이 어떻게 할당되었는지 신경쓰였는데요, <code>foo</code> 메서드를 따라가다보면 <code>baz</code> 메서드에서 값을 가져오는 것을 볼 수 있습니다. 거대한 코드 베이스에서는 형제 트리에서 모든 호출과 로직을 따라가는게 아주 어렵습니다(코드를 자료구조의 그래프라고 생각한다면, <code>foo</code> 메서드는 두 개의 자손이 있는 겁니다. <code>baz</code> 와 <code>bar</code> 이죠. 그래서 <code>baz</code>가 <code>bar</code> 의 형제라고 여길 수 있습니다). 저는 게으르기 때문에 객체가 어디서 왔는지 찾기 위해 모든 메서드를 뒤지고 싶지 않았습니다. 그래서 저는 루비의 객체 할당 추적기(object allocation tracer)를 사용하는걸 좋아합니다. 루비의 할당 추적기는 루비 2.1버전부터 사용할 수 있습니다(확실한 것은 아닙니다). 제가 이 방법을 사용할 때는 가능한 빨리 <code>require</code> 한 뒤에 활성화합니다. 그러면 제가 찾고자 하는 할당 위치를 찾을 수 있지요.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">require</span> <span class="token string">\'objspace\'</span>\n<span class="token constant">ObjectSpace</span><span class="token punctuation">.</span>trace_object_allocations_start\n\n<span class="token keyword">def</span> foo\n  x <span class="token operator">=</span> baz\n  bar x\n<span class="token keyword">end</span>\n\n<span class="token keyword">def</span> bar x\n  p <span class="token constant">ObjectSpace</span><span class="token punctuation">.</span><span class="token function">allocation_sourcefile</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token constant">ObjectSpace</span><span class="token punctuation">.</span><span class="token function">allocation_sourceline</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">def</span> baz<span class="token punctuation">;</span> zot<span class="token punctuation">;</span>\t\t<span class="token keyword">end</span>\n<span class="token keyword">def</span> zot<span class="token punctuation">;</span> <span class="token builtin">Object</span><span class="token punctuation">.</span><span class="token keyword">new</span>\t<span class="token class-name">end</span>\n\nfoo\n</code></pre>\n      </div>\n<p>프로그램을 실행하면 이런 결과를 얻습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>[aaron@TC tlm.com (master)]$ ruby x.rb\n{"x.rb"=>14}\n[aaron@TC tlm.com (master)]$</code></pre>\n      </div>\n<p><code>x</code> 객체가 해당 파일의 14번째 줄에 있다는 것을 알게 되었습니다. 그러면 해당 라인으로 가서 "wtf 트릭" 을 반복하거나 프로그램에 무슨 문제가 있는지 발견할 때 까지 이 방법을 반복합니다.</p>\n<p>저는 보통 객체 추적을 가능한 빠르게 시작합니다. 제 객체가 어디에 할당되었는지 모르니까요. 이런 추적은 프로그램의 속도를 떨어뜨리지만, 디버깅 중에는 신경쓸 필요가 없습니다.</p>\n<h2 id="나는-require-를-진짜-진짜-빨리-하고-싶어"><a href="#%EB%82%98%EB%8A%94-require-%EB%A5%BC-%EC%A7%84%EC%A7%9C-%EC%A7%84%EC%A7%9C-%EB%B9%A8%EB%A6%AC-%ED%95%98%EA%B3%A0-%EC%8B%B6%EC%96%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>나는 <code>require</code> 를 진짜 진짜 빨리 하고 싶어</h2>\n<p>바로 위에 보여드린 기술은 오로지 객체가 <code>trace_object_allocations_start</code> 메서드가 호출되고 난 뒤에 할당된 이후의 정보만 제공합니다. 파일이 <code>require</code> 되는 순간에 객체가 할당되어서, 도대체 무슨 파일이고 <em>어디에 있는지</em> 모를 때가 있습니다. 그래서  프레임워크 안에 있는 어떤 파일이라도 로드되기 전에 코드를 좀 실행시킬 필요가 있습니다. 이럴 때 저는 <code>-r</code> 플래그를 사용한 뒤 스크립트를 작성합니다.</p>\n<p>우리가 <code>User::BLACKLISTED_CLASS_METHODS</code> 의 할당 위치를 찾는 코드를 작성했다고 칩시다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">require</span> <span class="token string">\'active_record\'</span>\n\n<span class="token constant">AciveRecord</span><span class="token punctuation">:</span><span class="token symbol">:Base</span><span class="token punctuation">.</span>establish_connection adapter<span class="token punctuation">:</span> <span class="token string">\'sqlite3\'</span><span class="token punctuation">,</span> databse<span class="token punctuation">:</span> <span class="token string">\':memory:\'</span>\n\n<span class="token constant">ActiveRecord</span><span class="token punctuation">:</span><span class="token symbol">:Base</span><span class="token punctuation">.</span>connection<span class="token punctuation">.</span>instance_eval <span class="token keyword">do</span>\n  create_table <span class="token symbol">:users</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token operator">&lt;</span> <span class="token constant">ActiveRecord</span><span class="token punctuation">:</span><span class="token symbol">:Base</span><span class="token punctuation">;</span> <span class="token keyword">end</span>\np <span class="token constant">ObjectSpace</span><span class="token punctuation">.</span><span class="token function">allocation_sourcefile</span><span class="token punctuation">(</span><span class="token constant">User</span><span class="token punctuation">:</span><span class="token symbol">:BLACKLISTED_CLASS_METHODS</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token constant">ObjectSpace</span><span class="token punctuation">.</span><span class="token function">allocation_sourceline</span><span class="token punctuation">(</span><span class="token constant">User</span><span class="token punctuation">:</span><span class="token symbol">:BLACKLISTED_CLASS_METHODS</span><span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>그런데 우리는 이 어떤 파일이 이 상수를 할당했는지 모르고, 찾는 방법을 떠올리고 싶지도 않을 때가 있습니다(네, 이건 좀 억지로 꾸며낸 경우입니다). 이럴 때 <code>y.rb</code> 라는 파일을 작성해 보겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">require</span> <span class="token string">\'objspace\'</span>\n<span class="token constant">ObjectSpace</span><span class="token punctuation">.</span>trace_object_allocations_start\n</code></pre>\n      </div>\n<p>그리고 저는 루비의 커맨드 라인 인자를 넣어서 이 파일을 실행할 때 바로 <code>require</code> 하도록 만들었습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>[aaron@TC tlm.com (master)]$ ruby -I. -ry x.rb\n{"/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/activerecord-5.0.0.beta1/lib/active_record/attribute_methods.rb"=>35}\n[aaron@TC tlm.com (master)]$</code></pre>\n      </div>\n<p>인자들을 찬찬히 살펴보면 <code>-I.</code> 는 ". 를 불러오기 경로로 추가하고", <code>-ry</code> 는 <code>require \'y\'</code> 와 같으며, 이후에 <code>x.rb</code> 를 실행하는 겁니다. 그러니 <code>.</code> 가 불러오기 경로로 추가되었고, <code>x.rb</code> 가 실행되기도 전에 <code>y.rb</code> 파일이 <code>require</code> 되었습니다. 그 결과로 <code>BLACKLISTED_CLASS_METHODS</code> 가 <code>attribute_methods.rb</code> 의 35번째 줄에 에 할당되어 있다는 사실을 알 수 있습니다. 만약 서브 프로세스 안에서 실행되는 코드에 이 기술을 적용하고자 한다면 <code>RUBYOPT</code> 를 함께 쓰면 됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>$ RUBYOPT=\'-I. -ry\' rake test</code></pre>\n      </div>\n<h2 id="객체가-어딘가에서-수정되었는데mutated-그-위치를-모르겠다"><a href="#%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%96%B4%EB%94%98%EA%B0%80%EC%97%90%EC%84%9C-%EC%88%98%EC%A0%95%EB%90%98%EC%97%88%EB%8A%94%EB%8D%B0mutated-%EA%B7%B8-%EC%9C%84%EC%B9%98%EB%A5%BC-%EB%AA%A8%EB%A5%B4%EA%B2%A0%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>객체가 어딘가에서 수정되었는데(mutated), 그 위치를 모르겠다</h2>\n<p>객체를 살펴보다 보면 이게 수정되고 있다는건 알겠는데, 어디서 수정되고 있는 지 모를 때가 있습니다. 이 때는 객체에 <code>freeze</code> 를 호출한 뒤에, 테스트를 실행해보고, 어디서 예외가 발생하는지 살펴보면 됩니다. 그 예로, 제가 <a href="https://github.com/rails/rails/blob/38b5af6595338cb2212980062d9aaf51241878cc/activesupport/lib/active_support/concurrency/share_lock.rb#L28">어디에서 특정 변수가 수정되는지 알고 싶을 때</a>가 있습니다. 코드를 살펴보니 이 변수가 수정된다는 것은 알고 있었지만, 어디서부터 수정이 일어나는지 알지 못했습니다. 그래서 코드를 이렇게 수정해봤습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> initialize\n  <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n  <span class="token variable">@cv</span> <span class="token operator">=</span> new_cond\n\n  <span class="token variable">@sharing</span> <span class="token operator">=</span> <span class="token builtin">Hash</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n  <span class="token variable">@sharing</span><span class="token punctuation">.</span>freeze\n  <span class="token variable">@waiting</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n  <span class="token variable">@exclusive_thread</span> <span class="token operator">=</span> <span class="token keyword">nil</span>\n  <span class="token variable">@exclusive_depth</span> <span class="token operator">=</span> <span class="token number">0</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>그리고 나서 레일즈 서버를 실행하면 예외가 발생하며 추적 내역이 보여집니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>active_support/concurrency/share_lock.rb:151:in `delete\': can\'t modify frozen Hash (RuntimeError)\n\tfrom active_support/concurrency/share_lock.rb:151:in `yield_shares\'\n\tfrom active_support/concurrency/share_lock.rb:79:in `block in stop_exclusive\'</code></pre>\n      </div>\n<p>이제 처음에 수정이 발생한 곳을 발견했습니다. 만약 이 부분이 여러분이 찾고자 하는 부분이 아니라면 작성해둔 <code>freeze</code> 를 삭제한 뒤에 내역을 따라가서 수정된 부분 이후에 다시 덧붙이면 됩니다.</p>\n<h2 id="교착-상태deadlock에-빠졌는데-어디서-문제가-생겼는지-모르겠다"><a href="#%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9Cdeadlock%EC%97%90-%EB%B9%A0%EC%A1%8C%EB%8A%94%EB%8D%B0-%EC%96%B4%EB%94%94%EC%84%9C-%EB%AC%B8%EC%A0%9C%EA%B0%80-%EC%83%9D%EA%B2%BC%EB%8A%94%EC%A7%80-%EB%AA%A8%EB%A5%B4%EA%B2%A0%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>교착 상태(deadlock)에 빠졌는데, 어디서 문제가 생겼는지 모르겠다</h2>\n<p>저에게 스레드와 관련된 이슈가 발생했고, 문제를 어디에서 해결해야할 지 몰랐을 때, 저는 살아있는 스레드를 검사해보기 위해 코드를 좀 추가했습니다. 예를 들어 저는 <a href="https://github.com/rails/rails/issues/23503">이 이슈를 디버깅하고 있었습니다</a>. 애플리케이션 서버가 막혀있는데, 대체 어디서 문제가 발생했는지 몰랐습니다. 그래서 어디서 스레드가 막혀있는지 찾기 위해 <code>x.rb</code> 라는 파일을 작성했습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token function">trap</span><span class="token punctuation">(</span><span class="token symbol">:INFO</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token builtin">Thread</span><span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>t<span class="token operator">|</span>\n    puts <span class="token string">"#"</span> <span class="token operator">*</span> <span class="token number">90</span>\n    p t\n    puts t<span class="token punctuation">.</span>backtrace\n    puts <span class="token string">"#"</span> <span class="token operator">*</span> <span class="token number">90</span>\n  <span class="token keyword">end</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>그리고 앱 서버를 이렇게 실행했습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>$ ruby -I. -rx bin/rails s</code></pre>\n      </div>\n<p>이제 앱 서버가 막혔을 때, 컨트롤+T 키를 누르면(죄송하지만 OS X에서만 작동합니다, 리눅스에서는 <code>kill</code> 을 사용해야 합니다), 모든 스레드의 추적 내역을 볼 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>##########################################################################################\n#<Thread:0x007f90bc07cb38 run>\nomglolwut/x.rb:7:in `backtrace\'\nomglolwut/x.rb:7:in `block (2 levels) in <top (required)>\'\nomglolwut/x.rb:4:in `each\'\nomglolwut/x.rb:4:in `block in <top (required)>\'\ngems/puma-2.16.0/lib/rack/handler/puma.rb:43:in `join\'\ngems/puma-2.16.0/lib/rack/handler/puma.rb:43:in `run\'\ngems/rack-2.0.0.alpha/lib/rack/server.rb:296:in `start\'\nrails/commands/server.rb:78:in `start\'\nrails/commands/commands_tasks.rb:90:in `block in server\'\nrails/commands/commands_tasks.rb:85:in `tap\'\nrails/commands/commands_tasks.rb:85:in `server\'\nrails/commands/commands_tasks.rb:49:in `run_command!\'\nrails/command.rb:20:in `run\'\nrails/commands.rb:19:in `<top (required)>\'\nbin/rails:4:in `require\'\nbin/rails:4:in `<main>\'\n##########################################################################################\n##########################################################################################\n#<Thread:0x007f90bef3b668@/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/puma-2.16.0/lib/puma/reactor.rb:136 sleep>\nlib/puma/reactor.rb:29:in `select\'\nlib/puma/reactor.rb:29:in `run_internal\'\nlib/puma/reactor.rb:138:in `block in run_in_thread\'\n##########################################################################################\n##########################################################################################\n#<Thread:0x007f90bef3b500@/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/puma-2.16.0/lib/puma/thread_pool.rb:216 sleep>\nlib/puma/thread_pool.rb:219:in `sleep\'\nlib/puma/thread_pool.rb:219:in `block in start!\'\n##########################################################################################\n##########################################################################################\n#<Thread:0x007f90bef3b3c0@/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/puma-2.16.0/lib/puma/thread_pool.rb:187 sleep>\nlib/puma/thread_pool.rb:190:in `sleep\'\nlib/puma/thread_pool.rb:190:in `block in start!\'\n##########################################################################################\n##########################################################################################\n#<Thread:0x007f90bef3b258@/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/puma-2.16.0/lib/puma/server.rb:296 sleep>\nlib/puma/server.rb:322:in `select\'\nlib/puma/server.rb:322:in `handle_servers\'\nlib/puma/server.rb:296:in `block in run\'\n##########################################################################################\n##########################################################################################\n#<Thread:0x007f90c1ef9a08@/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/puma-2.16.0/lib/puma/thread_pool.rb:61 sleep>\nlib/ruby/2.4.0/monitor.rb:111:in `sleep\'\nlib/ruby/2.4.0/monitor.rb:111:in `wait\'\nlib/ruby/2.4.0/monitor.rb:111:in `wait\'\nlib/ruby/2.4.0/monitor.rb:132:in `wait_until\'\naction_dispatch/http/response.rb:170:in `block in await_commit\'\nlib/ruby/2.4.0/monitor.rb:214:in `mon_synchronize\'\naction_dispatch/http/response.rb:169:in `await_commit\'\naction_controller/metal/live.rb:270:in `process\'\naction_controller/metal.rb:193:in `dispatch\'\naction_controller/metal.rb:265:in `dispatch\'\naction_dispatch/routing/route_set.rb:50:in `dispatch\'\naction_dispatch/routing/route_set.rb:32:in `serve\'\n##########################################################################################\n##########################################################################################\n#<Thread:0x007f90bd1d5f38@/Users/aaron/git/rails/actionpack/lib/action_controller/metal/live.rb:279 sleep>\nlib/ruby/2.4.0/monitor.rb:111:in `sleep\'\nlib/ruby/2.4.0/monitor.rb:111:in `wait\'\nlib/ruby/2.4.0/monitor.rb:111:in `wait\'\nlib/ruby/2.4.0/monitor.rb:123:in `wait_while\'\nactive_support/concurrency/share_lock.rb:57:in `block (2 levels) in start_exclusive\'\nactive_support/concurrency/share_lock.rb:154:in `yield_shares\'\nactive_support/concurrency/share_lock.rb:56:in `block in start_exclusive\'\nlib/ruby/2.4.0/monitor.rb:214:in `mon_synchronize\'\nactive_support/concurrency/share_lock.rb:51:in `start_exclusive\'\nactive_support/concurrency/share_lock.rb:113:in `exclusive\'\nactive_support/dependencies/interlock.rb:12:in `loading\'\nactive_support/dependencies.rb:37:in `load_interlock\'\nactive_support/dependencies.rb:369:in `require_or_load\'\nactive_support/dependencies.rb:529:in `load_missing_constant\'\nactive_support/dependencies.rb:212:in `const_missing\'\nactive_support/dependencies.rb:561:in `load_missing_constant\'\nactive_support/dependencies.rb:212:in `const_missing\'\napp/controllers/users_controller.rb:9:in `index\'\n##########################################################################################</code></pre>\n      </div>\n<p>가독성을 위해 결과물을 조금 잘라냈습니다만, 여러분은 이제 각각의 스레드가 무엇을 하는지 볼 수 있습니다. 그리고 어느 스레드 두 개가 교착 상태에 빠졌는지 쉽게 발견할 수 있습니다(정답은 마지막 두 개입니다).</p>\n<h2 id="특정한-시간에만-언제-메서드가-실행되는지-알고-싶다"><a href="#%ED%8A%B9%EC%A0%95%ED%95%9C-%EC%8B%9C%EA%B0%84%EC%97%90%EB%A7%8C-%EC%96%B8%EC%A0%9C-%EB%A9%94%EC%84%9C%EB%93%9C%EA%B0%80-%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94%EC%A7%80-%EC%95%8C%EA%B3%A0-%EC%8B%B6%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>특정한 시간에만 언제 메서드가 실행되는지 알고 싶다</h2>\n<p>일정 시간 뒤에 메서드가 언제 실행되었는지 알고 싶을 때가 있습니다. 저는 애플리케이션이 <em>구동된 뒤에</em>  <code>start_exclusive</code> 메서드가 언제 호출되는지 알고 싶었습니다. 이럴 때 위에 보여드린 <code>trap</code> 트릭과 전역 변수를 조합하여 해결했습니다.</p>\n<p>먼저 <code>start_exclusive</code> 를 이렇게 수정했습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> <span class="token function">start_exclusive</span><span class="token punctuation">(</span>purpose<span class="token punctuation">:</span> <span class="token keyword">nil</span><span class="token punctuation">,</span> compatible<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> no_wait<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">)</span>\n  <span class="token keyword">if</span> <span class="token variable">$foo</span>\n    puts <span class="token string">"#"</span> <span class="token operator">*</span> <span class="token number">90</span>\n    puts caller\n    puts <span class="token string">"#"</span> <span class="token operator">*</span> <span class="token number">90</span>\n  <span class="token keyword">end</span>\n  <span class="token comment"># ..</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>그리고 <code>x.rb</code> 라는 파일을 작성했습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token function">trap</span><span class="token punctuation">(</span><span class="token symbol">:INFO</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  puts <span class="token string">"turning on debugging!"</span>\n  <span class="token variable">$foo</span> <span class="token operator">=</span> <span class="token keyword">true</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>그리고 앱 서버를 구동하고 모든 요소가 준비되면 컨트롤+T를 눌러서 제 전역 변수를 <code>true</code> 로 바꿉니다. 그리고 로그 메세지들을 살펴볼 수 있게 됩니다.</p>\n<h2 id="끝"><a href="#%EB%81%9D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>끝</h2>\n<p>이게 제가 지금 생각해 낼 수 있는 방법의 전부입니다. 그리고 <a href="http://www.schneems.com/2016/01/25/ruby-debugging-magic-cheat-sheet.html">Richard의 puts 디버깅에 관한 글도 읽어보세요</a>. 좋은 하루 되시길. 끝.</p>\n<hr>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>간만에 엄청나게 긴 양의 글을 번역했습니다. 그래도 맘 잡고 하니 생각보다 오래 걸리지도 않고, 초벌번역의 퀄리티도 조금씩 올라가고 있다고 느끼고 있습니다.</p>\n<p>이번에 소개해 드린 글은 콘솔에 디버깅 하는 방법을 소개하는 글입니다. 보통은 디버깅 툴로 <code>byebug</code>, <code>pry-byebug</code> 등을 사용하실 겁니다. 저도 어지간한 디버깅을 그렇게 처리하고 있지만.. 본문의 내용처럼 좀 깊은 부분을 들여다볼 때는 일일히 깊숙하게 파고들기 힘들 때가 많습니다. 좀 더 자신이 사용하고 있는 코드의 깊은 부분을 들여보고자 할 때 아주 유용한 테크닉이 될 것이라 생각합니다.</p>\n<p>번역된 챕터 제목들의 말투가 조금 이상하다고 느끼실텐데, 들어가는 글에서 원 저자가 \'어차피 블로그 포스트니까 신경 안쓰고 말투를 편하게 한다\'는 식으로 쓰여있길래 그 느낌을 가능한 한 살려서 작성해보았습니다.</p>\n<p>글을 읽다 보면 레일즈같은 거대한 오픈 소스에 기여하는 분들은 \'어떻게 이 방대한 코드를 다 고려하면서 개발을 하는걸까?\' 하는 생각에 더욱 존경심이 들더군요. 레일즈 뿐 아니라 다른 오픈소스 프레임웍들도 마찬가지입니다. 언젠가는 오픈소스에 기여했다는 족적을 꼭 남겨 보고 싶습니다.</p>\n<p>현재 Hanami 기반으로 개발을 하고 있다보니 문서화가 덜 되어 \'소스를 까볼\' 일이 많은데 이런 기술을 더 유용하게 사용해볼 수 있겠습니다. 이 글을 보는 다른 분들은 어떻게 \'프로그램의 소스를 살펴 보시는지\' 궁금하기도 하고, 더 유용한 디버깅 팁이 있는지도 궁금해집니다.</p>',
id:"/Users/rinae/Dev/blog/src/pages/posts/2017-03-19-I-am-a-puts-debuggerer-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-03-19",path:"/posts/i-am-a-puts-debuggerer-kor",title:"[번역] 나는 'puts' 디버거다",tags:["Ruby","Debugging","Translation"],category:"Translation"}},{excerpt:"본 포스트는  Gerald Weinberg 의  포스팅 의 번역본입니다 피드백은 언제나 환영합니다 제가 처음 이 질문을 Quora에서 보았을 때, 이미 4…",html:'<ul>\n<li><strong>본 포스트는 <a href="https://en.wikipedia.org/wiki/Gerald_Weinberg">Gerald Weinberg</a>의 <a href="http://secretsofconsulting.blogspot.kr/2017/02/should-i-learn-c-or-python.html">포스팅</a>의 번역본입니다</strong></li>\n<li><strong>피드백은 언제나 환영합니다</strong></li>\n</ul>\n<hr>\n<p>제가 처음 이 질문을 Quora에서 보았을 때, 이미 47개 정도의 답변이 달려있었고 대부분의 답은 잘못되어 있었습니다. 하지만 이 많은 답변들은 여러분에게 무언가 시사하는 바가 있습니다. 프로그래밍 언어를 선택하는 것은 기술적이라기보단 종교적인 질문에 가깝다는 겁니다. 사실 당신이 전문적인 프로그래머가 되고자 한다면 두 언어를 동시에 배워야 합니다.</p>\n<p>우리가 프로그래밍을 가르칠 때는 언제나 두 언어를 동시에 가르칩니다. 과제는 반드시 두 가지(혹은 그 이상의) 언어로 작성되어야 하며, 왜 언어마다 해결법이 다른지, 혹은 왜 같은지 설명하는 에세이를 같이 첨부하도록 합니다. 이 방법으로 여러분의 전문적 코딩 지식과 성숙도를 발전시킬 수 있습니다.</p>\n<p>일부 답변자들은 프로그래밍 언어는 도구에 불과하다고 주장합니다. 만약 그 비유가 맞다면, 목수가 되고자 하는 사람들이 이런 질문을 할 때 어떻게 대답해야 할까요?</p>\n<blockquote>\n<p>"제가 톱질하는 법을 배워야 할까요? 아니면 나사돌리개 쓰는 법을 배워야 할까요?"</p>\n</blockquote>\n<p>둘 중에 하나만 배운 사람이 최고 수준의 목수가 될 수 있을까요?</p>\n<p>그러니 이 결론이 날 리 없고 유사종교스러운 논란을 멀리하는 대신에, 여러분의 소중한 시간을 가능한한 많은 프로그래밍 언어를 배우는데 쓰도록 하십시오. 최소한 다섯 개에서 여섯 개 정도를 배우세요. 모든 언어를 반드시 사용할 필요는 없지만, 언어별로 다른 접근방식을 알게 되면 이런 바보같은 말은 하지 않게 될 것입니다: </p>\n<blockquote>\n<p>"저는 X라는 언어만 알고 있어요, 그리고 여전히 이 언어가 세상에서 가장 뛰어난 언어라고 생각합니다."</p>\n</blockquote>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>요즘은 시간이 너무나 빨리 지나가버려서 1주일에 한 개 정도 번역을 하겠다는 다짐을 지키지 못하게 되는 때가 잦습니다. 다시 번역에 시동을 걸면서 이번에는 짧지만 의미있는 글을 번역해보았습니다.</p>\n<p>우연히 이 글을 보게 되었을 때 \'이 나이 지긋한 어르신은 누구신가\' 하고 찾아보니 명망있는 IT 컨설턴트시더군요. 병환으로 사경을 헤메신 적이 있다고 하는데 아직까지는 잘 계십니다. 최근 트윗을 보니 병원에 다시 투병중이신가 봅니다. 쾌차하시길 바랍니다.</p>\n<p>\'프로그래밍 언어는 도구에 불과하다\' 라는 말을 다른 분에게 들었을 때는 이 글에서 이야기하고자 하는 뉘앙스와 약간 달랐습니다. \'개발에 필요한 원리를 숙지하고, 실무에서 필요한(혹은 가장 빠르게 적용 가능한) 언어를 익혀서 금방금방 적용할 수 있어야 한다.\' 라는 뜻으로 말씀을 하셨었지요. 어느 쪽이든, 결론적으로 다양한 언어를 접하는 것은 프로그래머로서 사고의 폭을 넓히기 때문에 도움이 된다는 뜻이라고 생각합니다.</p>\n<p>취지는 좋지만 현실적인 문제를 생각해보면.. 시간이 부족하다는 장벽이 있겠지요. 이럴 때는 조급한 마음가짐을 잠시 내려놓고 배움의 호흡을 길게 가져가야 할 것 같습니다. 제가 이 글의 번역을 하겠다고 허락을 구하기 위해 메일을 보낼 때 주고받았던 메일 일부를 발췌해 보았습니다.</p>\n<blockquote>\n<p>Rinae: (중략) 저는 루비와 자바스크립트라도 동시에 익혀나가고 있습니다. 하지만 쉽지는 않네요.</p>\n<p>Gerald: 음, 그 두개면, 충분히 제가 추천한 방식대로 하고 있군요. 앞서 언급했듯이 같은 일을 양쪽 언어로 구현해보세요. 그렇다고 무조건 구체적으로 작성할 필요도 없지만, 최소한 서로 다른 두 언어가 어떻게 다른지 이해하고 최소한의 스케치라도 디자인할 수 있을 정도가 되어야 합니다.</p>\n<p>그리고 이렇게 하는 게 아주 어렵다고 느껴진다면 최소한 앞의 두 언어가 익숙해질 때 까지는 세 번째 언어를 배우지 않도록 하세요.</p>\n</blockquote>\n<blockquote>\n<p>Rinae: 새로 배울 언어를 추천해주실 수 있나요?</p>\n<p>Gerald: 기존에 알고 있던 언어와 가능한한 다른 언어를 고르세요. 다른 언어를 고르기 위해 인터넷에서 찾아보거나 프로그래머 지인들에게 그 사람들이 알고 있는 언어를 물어보세요. 그 대신에 지금 알고 있는 언어와 너무 비슷한 언어를 고르게 된다면 헷갈리기만 할 겁니다<em>(역주: 언어의 문법이 다른 정도만 헷갈리고 나머지는 별 의미 없을 것이라는 의미로 보입니다)</em>.</p>\n</blockquote>\n<p>이 글의 저자는 이후에 다른 글 <a href="http://secretsofconsulting.blogspot.kr/2017/02/how-long-can-i-remain-ruby-java-c.html">\'How Long Can I Remain a [Ruby, Java, C++, Python, …]  Programmer?\'</a> 를 작성하여 더 깊게 생각할 거리를 던져주었습니다. 이 글의 후속편이라고 할 수 있겠지만, 굳이 번역하지는 않을거라 한번 읽어보시면 좋겠습니다. 저 글의 한줄 요약을 남겨드리자면 이렇습니다.</p>\n<blockquote>\n<p>"특정 언어의 프로그래머로 몇년 먹고살 수 있을지 전전긍긍하지 말고 ‘Programmer’ or ‘Problem-solver’ 같은 사람이 되어 살아남을 생각을 하라\'\'</p>\n</blockquote>',id:"/Users/rinae/Dev/blog/src/pages/posts/2017-03-11-should-i-learn-c++-or-python-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-03-11",path:"/posts/should-i-learn-cpp-or-python-kor",title:"[번역] C++와 Python 중 무엇을 먼저 배울까?",tags:["Learning","Translation"],category:"Translation"}},{excerpt:"이 포스트는  Ian C. Anderson…",html:'<ul>\n<li><strong>이 포스트는 <a href="https://twitter.com/IanCAnderson">Ian C. Anderson</a>의 <a href="https://robots.thoughtbot.com/beginners-mind">글</a>을 번역한 것입니다</strong></li>\n<li><strong>번역에 관한 감상 및 피드백은 작성자에게 큰 도움이 됩니다</strong></li>\n</ul>\n<hr>\n<p>저는 루비 프로그래머입니다. 저는 이 언어를 즐겨 쓰며, 직업적으로 소프트웨어를 만들면서 루비가 저의 호기심과 흥미를 충족시켜준다고 믿고 있습니다. 저는 매일 끊임없이 루비와 레일즈에 대해 배우고 있지만 이 언어와 플랫폼에 대해서는 잘 이해하고 있습니다.</p>\n<p>그러다가 최근에 하스켈을 배우기 시작했습니다. <a href="https://thoughtbot.com/">Thoughtbot</a>의 하스켈 프로젝트에 기여하고 싶었고, 제 시야를 확장해보고 싶었기 때문입니다.</p>\n<p>하스켈은 근본적으로 루비와 다릅니다. 순수한 함수형 언어이며 엄격한 정적 타입을 요구합니다. 루비가 동적 타입을 가지고 있고 함수형과는 거리가 먼 객체지향 언어라는 것과는 다릅니다. 제가 함수형 언어를 다루는 수준은 아주 미약합니다. 그래서 함수형 언어의 여러 개념과 하스켈이란 언어 자체가 저에게는 생소합니다.</p>\n<p>현 시점에서 하스켈 세계는 신비롭고 경이롭게 느껴집니다. 그래서 그런지 배우고자 하는 사람들에게는 동기부여와 흥분되는 기분을 가져다 줄 겁니다.</p>\n<h2 id="무한한-가능성"><a href="#%EB%AC%B4%ED%95%9C%ED%95%9C-%EA%B0%80%EB%8A%A5%EC%84%B1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>무한한 가능성</h2>\n<blockquote>\n<p>초심자의 마음속에는 많은 가능성이 자리잡고 있다, 그러나 전문가들은 그 가능성이 적다.(In the beginner’s mind there are many possibilities, but in the expert’s there are few.)</p>\n<p>— <em>Shunryu Suzuki, <a href="https://www.amazon.com/Zen-Mind-Beginners-Shunryu-Suzuki/dp/1590308492">Zen Mind, Beginner\'s Mind.</a></em></p>\n</blockquote>\n<p>이 인용문은 당신이 공부하고 있는 주제에 익숙해질 수록 점점 좁은 시야를 가지게 되는 것을 경계하고 있습니다. 저의 경우엔 문제 해결을 위한 만능 도구로서 루비를 갈고 닦으면서도, 언제나 제 기술적 선택에 만족하지 않도록 신경씁니다. 언제든지 더 나은 방법이 있다고 <em>믿으며</em> 그 방법을 찾아야 합니다.</p>\n<h2 id="전문가의-모순"><a href="#%EC%A0%84%EB%AC%B8%EA%B0%80%EC%9D%98-%EB%AA%A8%EC%88%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>전문가의 모순</h2>\n<blockquote>\n<p>모순되게도 마치 좁은 시야와 선입견을 가지게 되는 것처럼, 아주 탄탄하게 쌓아올린 전문 지식은 퍼포먼스의 저하를 초래할 수 있다.(Paradoxically, the very underpinning of expertise can entail degradation in performance as well, such as tunnel vision and biases.)</p>\n<p>— <em>Itiel E. Dror, <a href="https://core.ac.uk/download/pdf/1717017.pdf">The paradox of human expertise: Why experts get it wrong</a></em></p>\n</blockquote>\n<p>지식이 늘어날 수록 무엇이 어떻게 동작하는 지에 대해 추측하는 일도 늘어납니다. 이런 선입견들은 전문가로서 효율적으로 정보를 처리하고 문제를 푸는데 능숙하게 만들어 줄 수도 있습니다. 그러나 "기본적인(defaults)" 해답은 전문가들에게 주어진 문제를 해결하기 위한 더 적절한 답을 고민하지 못하게 만들 수 있습니다. 전문가들의 뇌는 특정 분야에 특화되어 있습니다. 말하자면 좁고 엄격한 마음가짐을 가지게 된다는 겁니다.</p>\n<h2 id="정신적-기민함의-가치"><a href="#%EC%A0%95%EC%8B%A0%EC%A0%81-%EA%B8%B0%EB%AF%BC%ED%95%A8%EC%9D%98-%EA%B0%80%EC%B9%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>정신적 기민함의 가치</h2>\n<blockquote>\n<p>지능의 척도는 변화할 수 있는 능력이다.(The measure of intelligence is the ability to change.)</p>\n<p>— <em>Albert Einstein</em></p>\n</blockquote>\n<p>저는 thoughbot의 <a href="https://thoughtbot.com/playbook#research">Research Trello board</a>가 생각났습니다. 우리는 이 장소를 우리가 진행하는 일이나 기술 스택의 변화를 실험하는 장소로 사용합니다. 우리는 어떤 툴을 사용하고 어떻게 사용하는지에 대해 고집스럽게 굴지만<em>(역주: 예를 들면 Thoughtbot의 개발자들은 대부분 Vim을 사용한다고 합니다)</em>, 언젠가 더 좋은 도구가 있다면 기꺼이 갈아탈 용의가 있습니다.  과학적 방법을 통해 지속적으로 우리 자신의 가설에 도전하는 것은, 우리가 주어진 문제를 해결하기 위해 현재와 미래에 걸쳐 최선의 도구와 기술을 사용하고 있다는 확신을 들게 합니다. 기술 분야에서 변화는 피할수 없습니다. 그러므로 이런 정신적 기민함은 굉장히 가치있는 자산입니다.</p>\n<h2 id="당신의-지혜-주머니를-키워라"><a href="#%EB%8B%B9%EC%8B%A0%EC%9D%98-%EC%A7%80%ED%98%9C-%EC%A3%BC%EB%A8%B8%EB%8B%88%EB%A5%BC-%ED%82%A4%EC%9B%8C%EB%9D%BC" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>당신의 지혜 주머니를 키워라</h2>\n<blockquote>\n<p>… 몇몇 경우에 지혜롭게 모나드의 힘을 적용하면 우리는 중첩된 콜백을 풀어낼 수 있고, 코드의 일부분을 재사용가능하게 만들며, 전반적으로 우리의 프로그램을 더 좋게 만듭니다.</p>\n<p>— Tom Stuart, <a href="http://codon.com/refactoring-ruby-with-monads">Refactoring Ruby with Monads</a></p>\n</blockquote>\n<p><a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">모나드</a>는 함수형 프로그래밍의 추상 개념인데 하스켈에서 필수적입니다. <a href="http://codon.com/refactoring-ruby-with-monads">Tom의 발표</a>에서 모나드를 이용하여 이상한 루비 코드 덩어리들을 멋진 해법으로 바꾸는 세 가지 실전적인 예시를 볼 수 있습니다. Tom의 코드가 그가 경험한 함수형 프로그래밍의 도움을 받았다는 것은 자명합니다. 그는 평상시의 문제를 해결하기 위해 다른 개념을 빌려올 수 있다는 것을 보여주었습니다. 이상적인 루비 코딩 스타일을 유지하면서요.</p>\n<p>제가 하스켈 전문가가 될 수 있을까요? 아니면 제가 하스켈 프로젝트를 풀 타임으로 다루게 될까요? <a href="https://robots.thoughtbot.com/if-you-gaze-into-nil-nil-gazes-also-into-you">아마도요</a>. 만약 아니라고 해도 하스켈을 배운 경험이 무의미하다고 생각하진 않을 겁니다. 저는 제 지혜 주머니를 키우고 있고(I am adding to my bag of tricks), 그래서 다각도로 문제를 해결해볼 수 있습니다. 제가 어떤 레일즈 앱의 기능을 구현할 때 함수형 프로그래밍의 접근 방식이 저의 평소 객체지향적 코드보다 더 나을지 생각해 볼 것입니다.</p>\n<p>전문가가 되기 위해 분투하는 것은 가치있는 일입니다. 그 비결은 끊임없이 특정 경우에 더 나을 수도 있는 대안을 찾아가면서, 더욱 많은 지식과 경험을 흡수하는 것입니다.</p>\n<hr>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>저도 루비 프로그래머입니다(쑥스럽지만 원본 글 첫머리를 빌려서 한마디 적어봅니다). 매일 새로운 것을 1이라도 알면 그 뒤에 알아야 할 것들이 10이 넘는 하루하루를 보내고 있습니다. 하지만 나름 재미있지요. 당장 저의 주력 언어라고 말 할 수 있는 루비는 아직 잘 다룬다고 생각하지 않아서 더 깊게, 깊게 파고들어야 한다고 생각하고 있었습니다.</p>\n<p>물론 이 글에서 말하고자 하는 주제는 이미 알고 있었습니다만 언제나 \'아직은 다른 언어나 개념을 접하기엔 좀 부족해..\' 라는 생각을 하면서 고개를 돌리지 않고 있습니다. 올해 안에는 적어도 Elixir나 Scala에 도전해보고 싶긴 합니다. 물론 루비 이외에 다른 도전은 언제나 하고 있지요. 바로 자바스크립트입니다.</p>\n<p>저에게는 너무나 변화가 빠른 언어이고, 겉으로 보기에는 별거 없어 보이지만 다루고자 하면 굉장히 복잡하고(+골때리고) 코드를 잘 짜기 위한 고민을 계속 해도 잘 되지 않는 언어입니다. 지금은 이 두 언어를 번갈아 익히는 것 만으로도 벅차네요.</p>\n<p>제가 본격적으로 제 자신을 \'개발자\' 라고 지칭할만한 일을 하게 된지 이제 1년이 되었습니다. 이 시점에서 이번 글은 다시 한번 끊임없는 향상심에 대해 환기시켜주는 글이었습니다. 다음 해에는 어떤 글을 남길 수 있을지 제 자신에게 조금 더 기대를 걸어봅니다.</p>',id:"/Users/rinae/Dev/blog/src/pages/posts/2017-02-20-beginners-mind-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-02-20",path:"/posts/beginners-mind-kor",title:"[번역] 초심자의 마음가짐",tags:["Learning","Translation"],category:"Translation"}},{excerpt:"이 글은  Joël Quenneville 의  글 을 번역한 것입니다 번역 및 내용에 관한 피드백은 언제나 환영합니다 수 년에 걸쳐 저는  Elm 을 배워왔습니다. 보통 저는 새로운 언어를 배울 때 이러저러한 과정을 거칩니다: 튜토리얼을 따라가본다 많은 토이 프로젝트를 만든다 블로그 글을 읽는다 해당 언어의 주간 뉴스레터를 구독한다 그런데 기대하지 않던 순간에 제 고정관념을 바꾸는 일이 생겼습니다. 저는  elm-lang…",html:'<ul>\n<li>이 글은 <a href="https://twitter.com/joelquen">Joël Quenneville</a>의 <a href="https://robots.thoughtbot.com/learning-by-helping">글</a>을 번역한 것입니다</li>\n<li>번역 및 내용에 관한 피드백은 언제나 환영합니다</li>\n</ul>\n<hr>\n<p>수 년에 걸쳐 저는 <a href="http://elm-lang.org">Elm</a>을 배워왔습니다. 보통 저는 새로운 언어를 배울 때 이러저러한 과정을 거칩니다:</p>\n<ul>\n<li>튜토리얼을 따라가본다</li>\n<li>많은 토이 프로젝트를 만든다</li>\n<li>블로그 글을 읽는다</li>\n<li>해당 언어의 주간 뉴스레터를 구독한다</li>\n</ul>\n<p>그런데 기대하지 않던 순간에 제 고정관념을 바꾸는 일이 생겼습니다.</p>\n<p>저는 <a href="https://elmlang.herokuapp.com">elm-lang 슬랙 커뮤니티</a>에 가입하여 <code>#beginners</code> 채널을 둘러보기 시작했습니다. 대부분의 질문이 "X를 위한 문법이 뭐죠?" 이거나 "Y를 하려면 어떻게 하죠?" 같은 질문이었습니다. 대부분은 공식 문서에 답이 적혀있는 질문들이었습니다.</p>\n<p>소프트웨어 산업에서 짬이 찬 대부분의 사람들과 같이, 저는 몇가지 기술을 연마해왔습니다:</p>\n<ul>\n<li>구글을 뒤적인다</li>\n<li>문서를 읽는다</li>\n<li>가설을 테스트하기 위한 작은 실험을 디자인한다</li>\n</ul>\n<p>![]({{ site.baseurl }}/assets/2017-02-13-sc1.png)</p>\n<p>사람들에게 그냥 "제발 그놈의 메뉴얼을 읽어보세요(<a href="https://ko.wikipedia.org/wiki/RTFM">RTFM</a>)", "구글은 여러분의 친구입니다" 혹은 "REPL(콘솔)에서 한번 쳐보세요" 같은 말을 하는게 편할 수도 있습니다. 그러나 이는 공감하기 힘들거나 자각하기 힘든 답변이 됩니다. 여러분이 당연하게 여기는 기술들은 다른 사람에게는 그렇지 않습니다. 특히 <code>#beginners</code>  채널 같은곳에서 질문을 하는 사람들에게는요.</p>\n<p>그 대신에 저는 문서를 찾아서 해당 질문에 대해 적절한 답이 될 수 있는 부분의 링크를 공유해 주었습니다. 필요하다면 설명도 곁들였습니다. 그러면서 단순히 문법이나 함수에 대해 찾아주는 것을 넘어 더 개념적인 질문을 돕기 시작 했습니다:</p>\n<blockquote>\n<p>왜 컴파일러는 이벤트 핸들러를 위한 스니펫으로 타입 <code>Html a</code> 를 쓰는 것을 좋아하지 않을까요?</p>\n</blockquote>\n<blockquote>\n<p><code>&#x3C;select></code> 에다 이벤트를 어떻게 집어넣을 수 있나요?</p>\n</blockquote>\n<blockquote>\n<p><code>type User = User String Int</code> 같은 중복은 어떻게 처리되나요?</p>\n</blockquote>\n<p>결과적으로 저는 빠르게 Elm의 문법과 코어 라이브러리에 관한 지식을 다질 수 있었습니다. 그리고 최근에 생겨난 <a href="https://robots.thoughtbot.com/elms-universal-pattern">패턴</a>에 대해 살펴보기 시작했습니다. 제가 전혀 몰랐던 라이브러리에 관해 도울 수도 있게 되었습니다.</p>\n<p>간단하게 <a href="https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%A7%95">퍼즈 테스터</a>를 만들려면 어떻게 해야할까요? <code>map</code> 작동에 대해서 알아야겠군요. JSON 디코더 3개를 엮으려 하신다구요? 아마 <code>Json.Decode.map3</code> 함수가 있을걸요?</p>\n<p>점점 이런 작업이 편해지면서, 저는 단순히 문서만 살펴보는게 아니라 소스를 파고들어 왜 특정 행동이 특정 방법으로 작동하는지 설명하고자 하였습니다.</p>\n<p>시간이 흘러, 자주 질문이 들어온다고 느끼는 주제에 대해서 블로그 글도 작성했습니다. 이를테면 <a href="https://robots.thoughtbot.com/building-custom-dom-event-handlers-in-elm">\'커스텀 DOM 이벤트 핸들러를 작성하는 방법\'</a>처럼요.</p>\n<p>이러한 과정을 거치는 동안 <a href="https://robots.thoughtbot.com/beginners-mind">초심자의 마음가짐</a>을 유지하는 것은 중요합니다. 때때로, 질문에 대답하는 것은 함께 배워나가는 과정이었습니다. 저는 처음에는 답을 몰랐거나 아주 모호하게 이해하고 있었을 뿐이었지만 토론을 거쳐가면서 지식을 발전시킬 수 있었습니다. 다른 때엔 제가 대답할수 없었지만 지금은 알게 된 개념에 대해 설명하려고 노력했습니다. 겸손함과 \'잘 모르겠습니다\' 라고 말하는 능력은 질문 받는 상황(these situations)을 배움의 기회로 바꿀 수 있습니다.</p>\n<p>다른사람에게 조언하거나 도움을 주기 위해 "전문가"가 될 때까지 기다리지 마세요. 당신이 초보자라 하더라도 그 결과는 엄청납니다(The payoffs are massive). 끊임없이 배우고, 끊임없이 지식을 나누세요.</p>\n<hr>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>사실 저는 Elm을 들어는 봤지만 제대로 사용해본 적은 없습니다. 함수형 프로그래밍의 개념에 대해서 가볍게 알아보고자 할 때 이러한게 있다 까지는 보았고, 호기심에 가벼운 튜토리얼을 따라가보았지만 아직 저에겐 너무 어려웠습니다.</p>\n<p>하지만 이 글의 내용은 Elm이랑 크게 관련 있는 것은 아니고, 개발자로서 끊임없이 배움의 과정을 걷는 사람들에게 생각할 거리를 준다는 느낌을 받아 번역을 해 보았습니다. 그래서 위의 Elm관련 번역은 부적절한 번역일 수 있으니 Elm을 사용해본 분들의 많은 조언 부탁드립니다.</p>\n<p>저 자신도 RORLAB 슬랙의 <code>#question_answer</code> 채널에 질문이 올라오면 당장 제가 모르는 내용이라도 검색을 해 봅니다. 제가  답변했던 내용들 일부는 제가 실제로 해 본 것도 아니고, 구글에서 적절하게 검색하여 찾은 내용이지만 해당 질문을 한 회원은 문제를 해결할 수 있었습니다. 그러면서 제가 몰랐던 지식도 조금씩 알아나갈 수 있었고 개발 문서만 보는 것을 넘어서 소스를 들여다 보는데 거부감이 많이 줄어들게 되었습니다.</p>\n<p>이 글의 핵심은 마지막 문장이라 생각합니다. 저도 당연히 \'번역의 전문가\'가 아님에도 이러저러한 글을 번역해서 올리고 있습니다. 분명 더 예전에 번역했던 글들의 퀄리티를 생각하면 다시 하고 싶지만..시간상.. 넘어가도록 하고, 조금씩 찾아가고 물어가면서 퀄리티를 향상시키고자 하고 있습니다. 제가 작성하는 코드도 그렇게 되었으면 하는 바람입니다.</p>\n<p>다음에는 <a href="https://robots.thoughtbot.com/beginners-mind">\'초심가의 마음가짐\'</a>에 대한 글을 번역해보려 합니다.</p>',id:"/Users/rinae/Dev/blog/src/pages/posts/2017-02-13-learning-by-helping-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-02-13",path:"/posts/learning-by-helping-kor",title:"[번역] 도우면서 배우기",tags:["Learning","Translation"],category:"Translation"}},{excerpt:"이 포스팅은  Piotr Solnica 의  글 을 번역한 것입니다 번역 내용에 대한 조언 및 의견은 언제나 작성자에게 큰 도움이 됩니다 저는 우리 루비스트들이 의존성 주입(Dependency Injection)에 대해 요즘은 어떻게 생각하는지 궁금해졌습니다. 제가 기억하는 한 의존성 주입에 대한 몇몇 토론은 대부분 자바로 인해 굳혀진 개념(post-java-trauma…",html:'<ul>\n<li><strong>이 포스팅은 <a href="https://twitter.com/_solnic_">Piotr Solnica</a>의 <a href="http://solnic.eu/2013/12/17/the-world-needs-another-post-about-dependency-injection-in-ruby.html">글</a>을 번역한 것입니다</strong></li>\n<li><strong>번역 내용에 대한 조언 및 의견은 언제나 작성자에게 큰 도움이 됩니다</strong></li>\n</ul>\n<hr>\n<p>저는 우리 루비스트들이 의존성 주입(Dependency Injection)에 대해 요즘은 어떻게 생각하는지 궁금해졌습니다. 제가 기억하는 한 의존성 주입에 대한 몇몇 토론은 대부분 자바로 인해 굳혀진 개념(post-java-trauma)을 비판하는 내용이었습니다. 이 글을 작성하기까지 오랜 시간동안 머리속으로 생각만 하고 있었지만, 이 주제가 아마도.. 알려져 있다는 것을 알고 있었습니다. 그래서 글을 작성하기 전에 구글에 검색을 해 보기로 마음먹었지요. 구글에 "ruby dependency injection"을 입력하면 이런 결과를 얻었습니다:</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 580px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 69.13793103448276%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB8klEQVQ4y52UiarbMBBF8/+fUeh/tFDaQpuljv1iv3iVF3nf4iV2nNyOVQIJeSRQwWEkZI3nzoy02LMMkanCNE0EAYdlWTS3wBiDaVg4HA5o2/Yln75U+Py1xKLretRNjwNxPB7/GyfuwIgFbsbIA0y0Wdc1pmlC13Xo+x5N02AYBsF1Pe9/NBaXywVXjuRgDn8+MNvZ4cztN6+4izDlJWwthG8lsN8jBE6KKMjBvRQBS8H0CJGX4zSdMIyDcPAQ4e2CuQ62igxJkSDvZCjqGwzLwGq7wlaVsZY3UHUNuqkjCDnyoniQfuewJ3lFWaKuKlHdkubjOOJ8Pt9xlfdhDm8XFkn8tXEgyS5+rxlF5mItudgoDjayTdaiSG2EGSciTOfpucMso1xxjsD3RR+6rivwPB++74ke9TwPSZqiIhVNc3iI9M5hVY2wnYYOtYiiHmHYUbP/w/dbcLLMaanxG3DekfwXReExh27rYAHDu6FhbxswHAN7KkISJ/SDEEVRitzWVS1a66nDru2R5wWqshbkWSEOVjNFJeZlUWMcTjiNk+CpZN8LoSh77HY6pD8qpLUGaalhu9Hw88cGy9UW378tqWhvUBUdrhU9b5s8z2DbNuXJgUGPxfxgJHGMJEkQxxFJ5mRjtE0rruB8h+c2uh1/AQTbLgUTO1ZlAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="2017 02 04 sc1"\n        title=""\n        src="/static/2017-02-04-sc1-9dcb9be1a8d06e20a0c943b7fe6c9637-9c10f.png"\n        srcset="/static/2017-02-04-sc1-9dcb9be1a8d06e20a0c943b7fe6c9637-0ca6d.png 198w,\n/static/2017-02-04-sc1-9dcb9be1a8d06e20a0c943b7fe6c9637-45e8e.png 395w,\n/static/2017-02-04-sc1-9dcb9be1a8d06e20a0c943b7fe6c9637-9c10f.png 580w"\n        sizes="(max-width: 580px) 100vw, 580px"\n      />\n    </span>\n  </span>\n  </p>\n<p><em>역주: 이 글은 2013년 12월에 작성되었으며, 현재 같은 검색어로 검색하면 결과물의 순서 및 노출되는 글이 다릅니다.</em></p>\n<p>저는 <a href="http://david.heinemeierhansson.com/2012/dependency-injection-is-not-a-virtue.html">DHH(David Heinmeier Hansson, Ruby on Rails의 창시자)의 블로그</a>로 들어가 글을 다시 읽어보았습니다. 그 글에 대해 희미한 기억만 남아있었기 때문입니다. 그리고 나서야 저는 세상이 루비의 의존성 주입에 대한 다른 글이 필요하다는 것을 깨달았습니다. 왜 그럴까요? 대개 저 글을 읽고 많은 루비스트들이 루비의 의존성 주입에 대해 잘못된 인식을 가질 우려가 있기 때문입니다. 또한 의존성 주입이 뭔지 배워보고자 하는 사람들은 DHH의 블로그 글을 발견할테고, 루비에서의 의존성 주입이 "필요 없다" 라는 크게 잘못된 생각을 가질 수 있습니다. 네, 정말로 걱정되는 부분입니다.</p>\n<p>제가 이 글의 제목을 "루비의 의존성 주입"이라고 작성한 이유는 <strong>"루비의"</strong> 라는 부분이 꽤 중요하기 때문입니다. 루비의 의존성 주입은 아주 직관적인 실체를 가지고 있으며 여러가지 장점을 가지고 있습니다.</p>\n<p>아, 간단히 정리하자면:</p>\n<p>여러분은 루비의 의존성 주입을 사용하기 위해 어떠한 외부 라이브러리도 쓸 필요가 없습니다.</p>\n<p>여러분은 루비의 의존성 주입을 사용하기 위해 어떠한 설정도 할 필요가 없습니다.</p>\n<p>여러분은 루비의 의존성 주입을 사용하기 위해 코드의 단순함을 희생할 필요가 없습니다.</p>\n<p>여러분은 루비의 의존성 주입을 사용하기 위해 코드를 더 작성해야 할 필요가 없습니다.</p>\n<h2 id="루비의-의존성-주입은-아주-쉽다"><a href="#%EB%A3%A8%EB%B9%84%EC%9D%98-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85%EC%9D%80-%EC%95%84%EC%A3%BC-%EC%89%BD%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>루비의 의존성 주입은 아주 쉽다</h2>\n<p>별로 대단한 건 없어요. 정말로요. 하지만 당신의 코드에 큰 영향을 줍니다. 자신만의 의존성을 갖는 객체를 만드는 것 보다 객체에 의존성을 주입 할 때 유연성은 증가하고 결합도는 낮아집니다. 더 나은 디자인을 채용하게 된 덤으로 테스트 하기도 쉬워지지요. 자주 일어나는 일입니다.</p>\n<p>한번 살펴보시죠:</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token comment"># 일반적인 접근</span>\n<span class="token keyword">class</span> <span class="token class-name">Hacker</span>\n\n  <span class="token keyword">def</span> initialize\n    <span class="token variable">@keyboard</span> <span class="token operator">=</span> <span class="token constant">Keyboard</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token symbol">:layout</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">\'us\'</span><span class="token punctuation">)</span>\n  <span class="token keyword">end</span>\n\n  <span class="token comment"># stuff</span>\n<span class="token keyword">end</span>\n\n<span class="token comment"># 그리고 의존성 주입의 경우</span>\n<span class="token keyword">class</span> <span class="token class-name">Hacker</span>\n\n  <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>keyboard<span class="token punctuation">)</span>\n    <span class="token variable">@keyboard</span> <span class="token operator">=</span> keyboard\n  <span class="token keyword">end</span>\n\n  <span class="token comment"># stuff</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>우리가 뭔가 멋진 의존성 주입 라이브러리를 사용했나요? 아니죠. 우리가 코드를 더 작성했나요? 글쎄요. 아니면 코드가 더 복잡해졌나요? 확실히 아닙니다.</p>\n<p>작은 변화에 불과했지만 여러분의 코드에 <strong>큰 영향을 미칩니다.</strong> <code>Hacker</code> 클래스는 더 이상 키보드를 만드는 방법에 종속될 필요가 없습니다. 그저 주어진 인터페이스를 사용하게 될 뿐이며, 우리는 키보드 인터페이스를 구현하기만 하면 어떤 것이든 편하게 집어넣을 수 있게 되었습니다. 이게 유연성이 증가하고 결합도가 낮아진다는 것을 뜻합니다.</p>\n<p>다 좋은데 그렇다면 키보드의 의존성은 어디서 만들어야 할까요? 분명 어디선가 만들어져야 할 텐데요?</p>\n<p>제가 사용하는 패턴은 이렇습니다:</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">Hacker</span>\n\n  <span class="token keyword">def</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>layout <span class="token operator">=</span> <span class="token string">\'us\'</span><span class="token punctuation">)</span>\n    <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token constant">Keyboard</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token symbol">:layout</span> <span class="token operator">=</span><span class="token operator">></span> layout<span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token keyword">end</span>\n\n  <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>keyboard<span class="token punctuation">)</span>\n    <span class="token variable">@keyboard</span> <span class="token operator">=</span> keyboard\n  <span class="token keyword">end</span>\n\n  <span class="token comment"># stuff</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>잠깐만요, 제가 코드를 더 작성하지 않아도 된다고 했나요? 제가 거짓말을 했네요. <code>build</code> 메서드를 쓰기 위해 코드를 두 줄 정도 더 써버렸습니다. 들켰네요.</p>\n<p>그래도 일단 좋은 면만 보도록 합시다:</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token comment"># 우리는 hacker 인스턴스를 아주 작은 노력으로 만들 수 있습니다</span>\n<span class="token constant">Hacker</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token string">\'us\'</span><span class="token punctuation">)</span>\n\n<span class="token comment"># 만약 우리가 이미 키보드 객체를 가지고 있다면 이 방식으로도 작동합니다</span>\n<span class="token constant">Hacker</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>keyboard_we_already_had<span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>우리가 의존성을 명시적으로 드러냈기 때문에 테스트하기도 쉬워졌습니다:</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code>describe <span class="token constant">Hacker</span> <span class="token keyword">do</span>\n  <span class="token comment"># 여기서는 키보드 객체가 큰 의존성을 가지고 있어서 그냥 mock으로 만든다고 칩시다</span>\n  <span class="token function">let</span><span class="token punctuation">(</span><span class="token symbol">:keyboard</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">mock</span><span class="token punctuation">(</span><span class="token string">\'keyboard\'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>\n\n  it <span class="token string">\'writes awesome ruby code\'</span> <span class="token keyword">do</span>\n    hacker <span class="token operator">=</span> <span class="token constant">Hacker</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>keyboard<span class="token punctuation">)</span>\n\n    <span class="token comment"># some expectations</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>의존성 주입이 없었다면 어떤 모양으로 보일 지 생각해봅시다. 제가 끔찍한 예를 하나 들어보겠습니다. 그리고 저는 여전히 사람들이 이런 코드를 작성하는 것을 보곤 합니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code>describe <span class="token constant">Hacker</span> <span class="token keyword">do</span>\n  <span class="token function">let</span><span class="token punctuation">(</span><span class="token symbol">:keyboard</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">mock</span><span class="token punctuation">(</span><span class="token string">\'keyboard\'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>\n\n  it <span class="token string">\'writes awesome ruby code\'</span> <span class="token keyword">do</span>\n\t<span class="token comment"># 우웩!</span>\n    <span class="token constant">Keyboard</span><span class="token punctuation">.</span><span class="token function">should_receive</span><span class="token punctuation">(</span><span class="token symbol">:new</span><span class="token punctuation">)</span><span class="token punctuation">.</span>\n      <span class="token function">with</span><span class="token punctuation">(</span><span class="token symbol">:layout</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">\'us\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>\n      <span class="token function">and_return</span><span class="token punctuation">(</span>keyboard<span class="token punctuation">)</span>\n\n    hacker <span class="token operator">=</span> <span class="token constant">Hacker</span><span class="token punctuation">.</span><span class="token keyword">new</span>\n\n    <span class="token comment"># some expectations</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p><em>역주: 윗부분에서 <code>Hacker</code> 클래스를 의존성 주입 없이 사용하는 예를 살펴보시면 ,<code>Hacker</code> 클래스의 인스턴스를 작성할 때 동시에 <code>Keyboard</code> 클래스의 인스턴스를 만든다는 것을 볼 수 있습니다. 그래서 <code>keyboard</code> 라는 객체가 의도대로 생성되는지를 테스트하기 위해 이런 복잡한 코드가 들어가게 되었다고 생각합니다.</em></p>\n<h2 id="더-나아가서"><a href="#%EB%8D%94-%EB%82%98%EC%95%84%EA%B0%80%EC%84%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>더 나아가서</h2>\n<p>루비의 의존성 주입을 연습할 때 저는 몇몇 작은 패턴과 규칙을 정해놓고 따르고 있습니다.</p>\n<ul>\n<li><code>.new</code> 메서드를 깔끔하게 유지하고, 오버라이드 하지 말 것. 단순한 의존성만 인자로 받아들인다</li>\n<li>빌더 메서드를 분리하여 만들고 이 메서드가 "모양빠지는" 입력들을 받아서, 해당 클래스의 객체가 필요로 하는 모든 것을 만들 수 있게한다</li>\n<li>빌더 메서드가 너무 복잡해지게 되면 빌드 로직을 서로 다른 객체로 분리한다</li>\n<li>생성자에 옵션 해시를 전달하는 것을 피한다</li>\n</ul>\n<p>이 규칙들은 제가 작성하는 코드에 크게 긍정적인 영향을 주었습니다. 결합도를 낮추었고, 유연성을 높였으며, 리팩토링도 쉬워졌습니다.</p>\n<p>사실 제가 이 글을 통해 작성한 간단한 예제만으로 위의 규칙이 말이 된다고 설득하는 것은 어렵습니다. 그러므로 일단 루비의 의존성 주입을 사용해보라고 권하고 싶습니다. 의존성 주입을 사용하는게 단순히 테스트할 때 이득을 보기 위해서라고 여기지 말아주세요. 제발요 :)</p>\n<p>제가 말하고 싶은 것은 루비의 의존성 주입은 하나의 미덕이라는 점입니다. 루비는 복잡한 일들을 간단한 방법으로 구현할 수 있는 아름다운 언어입니다. 반면에 테스트 할 때 <code>Time.now</code> 에 <code>stub</code> 을 사용하는 것은 그렇게 영리한 방법은 아닙니다.<em>(역주: <code>stub</code> 메서드는 Rspec에서 일종의 객체 목업을 생성해주는 메서드로 알고 있습니다. 굳이 글쓴이가 <code>Time.now</code> 에 <code>stub</code> 메서드를 사용한다는 이야기를 꺼낸 것은 이 예시가 DHH의 포스트에 언급되어 있기 때문입니다.)</em></p>\n<p>물론 여러분이 루비의 의존성 주입을 사용하지 않을 수도 있지만, 실제로 사용해 보시면 더 깔끔하고 명시적인 코드를 작성하실 수 있습니다. 여러분의 코드는 더 좋아질 겁니다.</p>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>저는 언제나 기본적인 컴퓨터 과학 및 좋은 프로그래밍 방법론에 대한 지식이 부족하다는 점을 통감하고 있습니다. 단순히 전공자가 아니기 때문인 것도 있지만, 지속적으로 개발을 제대로 하려면 이러한 지식이 반드시 필요하다고 생각하고 있기 때문입니다. 이런 점에서 최근에 좀 더 알아보고 싶던 주제가 \'의존성 주입\' 입니다.</p>\n<p>자바 스프링 프레임워크를 사용할 때 주로 \'의존성 주입\' 이라는 단어가 많이 나왔을겁니다. 그런데 제가 제대로 쓸 수 있는(정말일까?) 유일한 언어인 루비는 어떻게 의존성 주입을 사용하는지 궁금하여 찾아보다 이 글을 발견하게 되었습니다.</p>\n<p>번역 과정 자체는 무난했는데 후반부에 "Stub Time.now" 라는 말의 뜻을 이해하지 못하겠더군요. 알고보니 두 가지 문제가 있었습니다.</p>\n<ol>\n<li>RSpec을 제대로 써 보지 않았다</li>\n<li>DHH의 글을 먼저 읽어보지 않았다</li>\n</ol>\n<p>글 작성자에게 더 자세한 설명을 부탁했더니 이런 답변을 받았습니다. 참고하시기 바랍니다.</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 790px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 94.36619718309859%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB5ElEQVQ4y42Uy27CQAxF+SjUbdUNqniGACHhGQgJtNtuaFdVpaqq+gP9W9dnGtNEENKFNeMZ+9oeX09jMhrJ8/EoY9+XYDwWdFt9z5PRcChevy/ddrtSBr2ejNS/3+1KY7VcSvvu1jmudQ8wQAhACIbXALm3oI3iha+gRKsC6HU67v7Sue1LgPMoksN+L5v1WjZxLA/5nsyTzUZ2SeLOkX2aCtVxht9FwG1umKkAlO12DpRz9lsFXc7n7i5VoCTXixglwNVi4ZzIiBWgeLWSaDq9+oaVgGt1tswMbLfduj0ZcReroHOOHUlQFcy4WDJlkB2OqTrYupjNXAB0AFwQPSeIvS/NKQHaJcaAkhXls3LGPY7oYRA4H+hS2WW4N51MXPpGbnQ4yh6O2p7OFocBu/OS86ww5m1YEZrCGupK6Sdds5yF4Uk/A8QAoLrJuNplr3Mv318fMtMoAJIFEa10yqoDGQ4GztfNcuB78v7yJBN1XGp2ZEg3XedyavAUj4eDJKrbZBQbVsnDhbIehzjvtoEBzLi5sYSDuU0tsY2HSJHgAJK50cpmnQCpkTvL/gAv/SBVUuScfV0lHvIRfL69up+DZkRKA0rnnWiM8bCuKfj2NbEG6DfNpty3Wr+/iJbwn85WyQ9oQ/RV9QwqNgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="2017 02 04 sc2"\n        title=""\n        src="/static/2017-02-04-sc2-0f2ed11f15088cd9b3c54a8078fb8ed1-ffc88.png"\n        srcset="/static/2017-02-04-sc2-0f2ed11f15088cd9b3c54a8078fb8ed1-d16f8.png 198w,\n/static/2017-02-04-sc2-0f2ed11f15088cd9b3c54a8078fb8ed1-f21b1.png 395w,\n/static/2017-02-04-sc2-0f2ed11f15088cd9b3c54a8078fb8ed1-ffc88.png 790w,\n/static/2017-02-04-sc2-0f2ed11f15088cd9b3c54a8078fb8ed1-ee9f1.png 994w"\n        sizes="(max-width: 790px) 100vw, 790px"\n      />\n    </span>\n  </span>\n  </p>\n<p>루비의 의존성 주입에 대한 이야기는 <a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=49317754">루비로 배우는 객체지향 디자인</a> 책에도 조금 설명되어 있습니다. 루비로 프로그래밍을 하신다면 두번 이상은 읽어보시길 추천드립니다.</p>\n<p>참고 링크:</p>\n<ul>\n<li><a href="http://www.slideshare.net/hnki0104/ss-42101768">주니어 개발자도 이해할 수 있는 의존성 주입</a></li>\n<li><a href="https://medium.com/@Bakku1505/introduction-to-dependency-injection-in-ruby-dc238655a278#.ywoosbc3h">Introduction to dependency injection in Ruby</a></li>\n<li><a href="http://david.heinemeierhansson.com/2012/dependency-injection-is-not-a-virtue.html">Dependency injection is not a virtue</a></li>\n</ul>',
id:"/Users/rinae/Dev/blog/src/pages/posts/2017-02-04-the-world-needs-another-post-about-dependency-injection-in-ruby-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-02-04",path:"/posts/the-world-needs-another-post-about-dependency-injection-in-ruby-kor",title:"[번역] 세상은 루비의 의존성 주입에 대한 다른 글을 원한다",tags:["Ruby","OOP","Translation"],category:"Translation"}},{excerpt:"이 포스팅은  Cezar Halmagean 의  포스팅 을 번역한 글입니다 번역 내용에 대한 조언 및 의견은 언제나 작성자에게 큰 도움이 됩니다 블록은 루비에서 가장 강력한 기능이지만 대수롭지 않게 여겨지는 기능이기도 합니다. 고백컨데 저도 루비 블록이 어떻게 동작하는지, 그리고 실제로 어떻게 유용하게 사용될 수 있는지 알아내는데 시간이 좀 걸렸습니다. 처음에 블록을 이해하는데 굉장히 어렵게 만드는 요소로  yield…",html:'<ul>\n<li><strong>이 포스팅은 <a href="https://twitter.com/chalmagean">Cezar Halmagean</a>의 <a href="https://mixandgo.com/blog/mastering-ruby-blocks-in-less-than-5-minutes">포스팅</a>을 번역한 글입니다</strong></li>\n<li><strong>번역 내용에 대한 조언 및 의견은 언제나 작성자에게 큰 도움이 됩니다</strong></li>\n</ul>\n<hr>\n<p>블록은 루비에서 가장 강력한 기능이지만 대수롭지 않게 여겨지는 기능이기도 합니다. 고백컨데 저도 루비 블록이 어떻게 동작하는지, 그리고 실제로 어떻게 유용하게 사용될 수 있는지 알아내는데 시간이 좀 걸렸습니다.</p>\n<p>처음에 블록을 이해하는데 굉장히 어렵게 만드는 요소로 <code>yield</code> 등의 개념이 있습니다. 저는 블록의 일부 개념에 대해 이야기하고 몇몇 예시를 들어서 글 마지막에는 여러분이 루비 블록을 명확하게 이해하도록 돕겠습니다.</p>\n<h2 id="무엇을-배울-것인가"><a href="#%EB%AC%B4%EC%97%87%EC%9D%84-%EB%B0%B0%EC%9A%B8-%EA%B2%83%EC%9D%B8%EA%B0%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>무엇을 배울 것인가</h2>\n<ol>\n<li>\n<p>기초: 루비 블록이란?</p>\n</li>\n<li>\n<p><code>yield</code> 가 동작하는 방법</p>\n<ul>\n<li>블록을 메서드로 전달하기</li>\n<li><code>yield</code> 도 매개변수를 받는다</li>\n</ul>\n</li>\n<li>\n<p><code>&#x26;block</code> 은 무엇을 의미하는가?</p>\n</li>\n<li>\n<p>값의 반환</p>\n</li>\n<li>\n<p><code>.map(&#x26;:something)</code> 은 어떻게 동작하는가?</p>\n</li>\n<li>\n<p>반복자, 그리고 여러분의 반복자를 직접 만들기</p>\n</li>\n<li>\n<p>블록을 이용하여 기본값으로 객체를 초기화하기</p>\n</li>\n<li>\n<p>루비 블록 예시</p>\n<p>​</p>\n</li>\n</ol>\n<h2 id="기초-루비-블록이란"><a href="#%EA%B8%B0%EC%B4%88-%EB%A3%A8%EB%B9%84-%EB%B8%94%EB%A1%9D%EC%9D%B4%EB%9E%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>기초: 루비 블록이란?</h2>\n<p>블록은 기본적으로 <code>do</code> 와 <code>end</code> 사이에 들어가는 코드입니다. 그게 다에요. <em>"그럼 마법같은 일(Magic)은 어디서 일어나는거죠?"</em> 라고 질문하실 수 있겠습니다. 우리는 몇 분 이내에 그 부분을 파고들겠지만 차례대로 설명하겠습니다(but first things first).</p>\n<p>여러분은 블록을 두 가지 방법으로 작성할 수 있습니다. 1. 멀티-라인으로 작성할 때는 <code>do</code> 와 <code>end</code> 사이에 코드를 작성하고, 2. 인라인으로 작성할 땐 <code>{</code> 와 <code>}</code> 사이에 코드를 작성하면 됩니다.</p>\n<p>이 두 가지 작성 방법은 정확하게 똑같이 작동합니다. 그래서 어느 방법을 고를 지는 여러분의 선택에 달려 있습니다. 일반적인 스타일 가이드에 의하면 가독성을 위해 코드가 한줄 이상 넘어가면 <code>do</code> ~ <code>end</code> 를 이용하여 작성하는 것이 좋습니다.</p>\n<p>멀티 라인 블록의 기본적인 예시는 이렇습니다: <code>[1, 2, 3].each do |n| puts "Number #{n}" end</code></p>\n<p>이 블록이 멀티 라인 블록이라 불리는 이유는 한 줄 이상으로 코드가 작성되어서가 아니고 인라인 블록이 아니기 때문입니다. 같은 예시를 인라인으로 작성할 수도 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token punctuation">{</span> <span class="token operator">|</span>n<span class="token operator">|</span> puts <span class="token string">"Number <span class="token interpolation"><span class="token delimiter tag">#{</span>n<span class="token delimiter tag">}</span></span>"</span> <span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>두 가지 버전 모두 1, 2, 3을 순서대로 출력할 겁니다. 파이프 사이에 있는 소문자 n(<code>|n|</code>)은 <strong>블록 매개변수(block parameter)</strong> 라고 불리고, 이 예시에서는 배열 안에 있는 각각의 번호가 순서대로 나오게됩니다. 그래서 처음 반복 시에 <code>n</code> 의 값은 1이 되고, 두번째 반복에서는 2가 되고 그 다음엔 3이 됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code># 결과\nNumber 1\nNumber 2\nNumber 3\n => [1, 2, 3]</code></pre>\n      </div>\n<h2 id="yield가-동작하는-방법"><a href="#yield%EA%B0%80-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>yield가 동작하는 방법</h2>\n<p>이제 위험한 녀석이 왔습니다(Here\'s bad wolf). 이 녀석이 루비 블록의 마법스러움과 혼란스러움을 가져다주는 주범이지요. 제 생각엔 대부분 <code>yield</code> 가 블록을 호출하는 방법과 어떻게 매개변수를 전달하는지가 어렵게 보일 것이라 생각합니다. 우리는 이 섹션에서 두 가지 시나리오를 모두 살펴볼겁니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> my_method\n  puts <span class="token string">"reached the top"</span>\n  <span class="token keyword">yield</span>\n  puts <span class="token string">"reached the bottom"</span>\n<span class="token keyword">end</span>\n\nmy_method <span class="token keyword">do</span>\n  puts <span class="token string">"reached yield"</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code># 결과\nreached the top\nreached yield\nreached the bottom\n => nil</code></pre>\n      </div>\n<p>기본적으로 <code>my_method</code> 메서드가 실행되고 <code>yield</code> 를 호출하는 줄에 도달하면, 블록 안에 있는 코드가 실행됩니다. 그리고 블록 안의 코드가 끝나면 <code>my_method</code> 메서드가 계속 실행됩니다.</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 492px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 42.07317073170732%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABIElEQVQoz41Sy27CMBDk//+qBy4IqSpQaAQtaURImoftTWJvHCNNY7fh0ha60mjWkjU73vEM39VRB0MNuGtgVA0mib7nHxiGAbdqNjXZMcN+vUJyivDy9oj98QlRFSOWKVpucbkMAU1Do3APIoJSKnDbttBafwk652CthcgEqp0YHRoYq8HWgAeDru/gnL0KKiVhjEGe58iyDEVRoKqqcPaDZl7M1zlNsdtukagznotXRGUceF8nWH8cUGsZBIkUmDmIeAghIKUMvXd8FaScoJUep5ibmO7/ucPpArMJS9e6C0/qmX8Nxbk7oXj73vJms8JyucDDco75eoHjexoCOVEeMO3Q2v5+yv4rFHGJMi2hx0CEVlCGQNxAjtyM/F/BT16naRwsT7lHAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="2017 01 26 sc1"\n        title=""\n        src="/static/2017-01-26-sc1-0b41e997207a170368c666aab1b250d5-806d2.png"\n        srcset="/static/2017-01-26-sc1-0b41e997207a170368c666aab1b250d5-e0e3b.png 198w,\n/static/2017-01-26-sc1-0b41e997207a170368c666aab1b250d5-4f7b9.png 395w,\n/static/2017-01-26-sc1-0b41e997207a170368c666aab1b250d5-806d2.png 492w"\n        sizes="(max-width: 492px) 100vw, 492px"\n      />\n    </span>\n  </span>\n  </p>\n<h3 id="블록을-메서드로-전달하기"><a href="#%EB%B8%94%EB%A1%9D%EC%9D%84-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EC%A0%84%EB%8B%AC%ED%95%98%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>블록을 메서드로 전달하기</h3>\n<p>블록을 매개변수로 받기 위해 메서드에 특별히 무언가를 정의할 필요는 없습니다. 그냥 블록을 함수(메서드)로 전달할 수 있습니다. 하지만 그 함수가 <code>yield</code> 를 호출하지 않으면 블록은 실행되지 않을겁니다.</p>\n<p>반면에 메서드에 <code>yield</code> 를 호출하도록 해놓으면 블록을 인자로 전달하는 것이 강제됩니다. 이 메서드가 블록을 매개변수로 받지 않는다면 에러가 발생하게 됩니다.</p>\n<p>만약 블록을 매개변수로 받는 것을 가변적으로 처리하고 싶다면 <code>block_given?</code> 메서드를 사용할 수 있습니다. 이 메서드는 블록이 메서드로 전달되었는지를 따져 true나 false를 리턴합니다.</p>\n<h3 id="yield-도-매개변수를-받는다"><a href="#yield%1C-%EB%8F%84-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EB%A5%BC-%EB%B0%9B%EB%8A%94%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>yield</code> 도 매개변수를 받는다</h3>\n<p>어떠한 매개변수든지  <code>yield</code> 로 전달되면 블록의 매개변수처럼 동작할 것입니다. 그래서 블록이 실행될 때 원래 메서드로(yield를 호출하는 메서드)부터 전달되는 매개변수를 사용할 수 있습니다. 즉 매개변수는 <code>yield</code> 가 자리잡고 있는 메서드의 지역 변수가 될 수도 있다는 뜻입니다.</p>\n<p>전달되는 매개변수의 순서는 중요합니다. 왜냐면 여러분이 전달하는 매개변수의 순서가 블록이 매개변수를 전달받는 순서와 일치하기 때문입니다.</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 475px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 43.15789473684211%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQoz2OYP3+iILF41qwJogyEwJmmi6Y3a7IsrjcV6tytibG6U59lem7zVsEjR+byouOlSyeKA7Ww4jXwbM0N37O119zPt10xPF17xfX8hLNKp7tPq2EzcMWKKYQN3Nm2R2fRogmixOCZM3tlgFrYGMgETEDMBcQSUBoG8Luwu7uTBx0bGhoo5efn8mdkpAnExEQLJSUlCIJwTEyUENQi3MDYWENbV1dFX11d3jTIyUfvTMsFw7Mtl4zPtF7QP9dy2Rg5PKFhiB8Y6mvomzkYaGpMDTIBYb1pYfo600MNlCcHWGpOCTbRnBpsYjgjXEdlcoBFx4Jmmfb2dqnu7m7Bzs5O7Y6ODoWuri4JIFsXytZkONh43Gb58qmixOBZs3plCTkQANDMvCE6DwrTAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="2017 01 26 sc2"\n        title=""\n        src="/static/2017-01-26-sc2-bb2e2064049183892cdc8f6790ab92a8-7203d.png"\n        srcset="/static/2017-01-26-sc2-bb2e2064049183892cdc8f6790ab92a8-93713.png 198w,\n/static/2017-01-26-sc2-bb2e2064049183892cdc8f6790ab92a8-ae0be.png 395w,\n/static/2017-01-26-sc2-bb2e2064049183892cdc8f6790ab92a8-7203d.png 475w"\n        sizes="(max-width: 475px) 100vw, 475px"\n      />\n    </span>\n  </span>\n  </p>\n<p>한가지 유의하셔야 할 점은 블록 안의 매개변수는 블록에만 한정된 지역 변수가 된다는 겁니다. (메서드에 있던 지역 변수를 블록으로 전달할 때와는 다릅니다)</p>\n<h2 id="block은-무엇을-의미하는가-ampersand-parameter"><a href="#block%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%9D%98%EB%AF%B8%ED%95%98%EB%8A%94%EA%B0%80-ampersand-parameter" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>&#x26;block은 무엇을 의미하는가? (ampersand parameter)</h2>\n<p>여러분은 아마 다른 루비 코드 여기저기에 <code>&#x26;block</code> 이 사용된 것을 보셨을 겁니다. 이 것은 지역 변수 대신에 블록에 대한 참조(reference) 자체를 메서드로 전달하는 방식입니다. 사실 <strong>루비는 블록처럼 작동하는 어떠한 객체라도 메서드에 전달되는걸 허용합니다.</strong> 메서드가 전달받은 객체가 블록이라면 이 블록을 사용하려 할 것이지만, <em>만약 블록이 아니라면 그 객체에 <code>to_proc</code> 메서드를 호출하여</em> 블록으로 변환하려고 시도할 것입니다.</p>\n<p>또 참고하셔야 할 점은 <code>block</code> 이라는 이름은(ampersend(&#x26;) 기호 이외의 부분) 단지 참조를 위한 이름일 뿐입니다. 여러분이 좋아하는 어떠한 이름이라도 사용하실 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> <span class="token function">my_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>block<span class="token punctuation">)</span>\n  puts block\n  block<span class="token punctuation">.</span>call\n<span class="token keyword">end</span>\n\nmy_method <span class="token punctuation">{</span> puts <span class="token string">"Hello!"</span> <span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code># 결과\n#<Proc:0x0000010124e5a8@tmp/example.rb:6>\nHello!</code></pre>\n      </div>\n<p>위의 예를 보시다시피, <code>my_method</code> 안에 있는 <code>block</code> 변수는 블록의 참조이고, 이 블록은 <code>call</code> 메서드를 통해 실행될 수 있습니다. 블록에 <code>call</code> 을 하는 것은 <code>yield</code> 와 똑같은 겁니다. 일부 사람들은 가독성을 위해 <code>yield</code> 대신에 <code>block.call</code> 을 사용합니다.</p>\n<h2 id="값의-반환"><a href="#%EA%B0%92%EC%9D%98-%EB%B0%98%ED%99%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>값의 반환</h2>\n<p><code>yield</code> 는 블록 안에서 마지막으로 평가된 값(last evaluated expression)이 반환됩니다. 달리 말하면 <code>yield</code> 가 리턴하는 값은 블록이 리턴하는 값이라는 겁니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> my_method\n  value <span class="token operator">=</span> <span class="token keyword">yield</span>\n  puts <span class="token string">"value is: <span class="token interpolation"><span class="token delimiter tag">#{</span>value<span class="token delimiter tag">}</span></span>"</span>\n<span class="token keyword">end</span>\n\nmy_method <span class="token keyword">do</span>\n  <span class="token number">2</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code># 결과\nvalue is 2\n=> nil</code></pre>\n      </div>\n<h2 id="mapsomething은-어떻게-동작하는가"><a href="#mapsomething%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>.map(&#x26;:something)은 어떻게 동작하는가?</h2>\n<p>여러분은 아마 <code>.map(&#x26;:capitalize)</code> 같은 단축 표현을 많이 쓰셨을 겁니다. 특히 레일즈로 코딩을 좀 해보셨다면 말이죠.  <code>.map { |title| title.capitalize }</code> 에 비하면 아주 깔끔한 단축 표현입니다.</p>\n<p><strong>그런데 이게 어떻게 작동하는걸까요?</strong></p>\n<p>실제로는 <a href="http://ruby-doc.org/core-2.2.0/Symbol.html#method-i-to_proc">심볼 클래스가</a> <code>to_proc</code> 을 메서드를 구현하고 있기 때문에, 단축 표현을 풀어서 실제의 긴 표현식으로 변환해주는 겁니다. 멋지죠?</p>\n<h2 id="반복자-그리고-여러분의-반복자를-직접-만들기"><a href="#%EB%B0%98%EB%B3%B5%EC%9E%90-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%97%AC%EB%9F%AC%EB%B6%84%EC%9D%98-%EB%B0%98%EB%B3%B5%EC%9E%90%EB%A5%BC-%EC%A7%81%EC%A0%91-%EB%A7%8C%EB%93%A4%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>반복자, 그리고 여러분의 반복자를 직접 만들기</h2>\n<p>여러분은 메서드 안에 있는 <code>yield</code> 를 원하시는 대로 몇번이든 부를 수 있습니다. 그게 기본적으로 반복자(iterator)가 동작하는 원리입니다. <code>yield</code> 를 배열 안에 있는 각 요소마다 호출하면 루비에서 기본적으로 제공하는 반복자를 흉내낼 수 있습니다.</p>\n<p>루비의 <code>map</code> 메서드와 비슷한 메서드를 작성하는 방법을 보여드리겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> <span class="token function">my_map</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span>\n  new_array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n\n  <span class="token keyword">for</span> element <span class="token keyword">in</span> array\n    new_array<span class="token punctuation">.</span>push <span class="token keyword">yield</span> element\n  <span class="token keyword">end</span>\n\n  new_array\n<span class="token keyword">end</span>\n\n<span class="token function">my_map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token operator">|</span>number<span class="token operator">|</span>\n  number <span class="token operator">*</span> <span class="token number">2</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code># 결과\n[2, 4, 6]</code></pre>\n      </div>\n<h2 id="블록을-이용하여-객체를-기본값과-함께-초기화하기"><a href="#%EB%B8%94%EB%A1%9D%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EA%B8%B0%EB%B3%B8%EA%B0%92%EA%B3%BC-%ED%95%A8%EA%BB%98-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>블록을 이용하여 객체를 기본값과 함께 초기화하기</h2>\n<p>루비 블록을 사용할 수 있는 멋진 패턴 중 하나는 객체를 기본값과 함께 초기화하는 것입니다. 한번이라도 아무 루비 젬에서나 <code>.gemspec</code> 파일을 살펴보았을 때 이 패턴을 보셨을겁니다.</p>\n<p>작동하는 원리는 이렇습니다. <code>initialize</code> 메서드 안에 <code>yield(self)</code> 를 호출하는 초기화 도구(initializer)를 넣어두는 겁니다. 여기서 <code>self</code> 는 초기화되는 객체 자신입니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">Car</span>\n  attr_accessor <span class="token symbol">:color</span><span class="token punctuation">,</span> <span class="token symbol">:doors</span>\n\n  <span class="token keyword">def</span> initialize\n    <span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\ncar <span class="token operator">=</span> <span class="token constant">Car</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">do</span> <span class="token operator">|</span>c<span class="token operator">|</span>\n  c<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">"red"</span>\n  c<span class="token punctuation">.</span>doors <span class="token operator">=</span> <span class="token number">4</span>\n<span class="token keyword">end</span>\n\nputs <span class="token string">"My car\'s color is <span class="token interpolation"><span class="token delimiter tag">#{</span>car<span class="token punctuation">.</span>color<span class="token delimiter tag">}</span></span> and it\'s got <span class="token interpolation"><span class="token delimiter tag">#{</span>car<span class="token punctuation">.</span>doors<span class="token delimiter tag">}</span></span> doors."</span>\n</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code># 결과\nMy car\'s color is Red and it\'s got 4 doors.</code></pre>\n      </div>\n<h2 id="루비-블록-예시"><a href="#%EB%A3%A8%EB%B9%84-%EB%B8%94%EB%A1%9D-%EC%98%88%EC%8B%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>루비 블록 예시</h2>\n<p>요즘은 예시로 보여주는게 대세(all the rage these days)인만큼 실제 세계에서(혹은 실제 세계와 최대한 가까운) 블록을 사용하는 몇가지 흥미로운 시나리오를 보여드리겠습니다.</p>\n<h3 id="텍스트를-html-태그로-감싸기"><a href="#%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%A5%BC-html-%ED%83%9C%EA%B7%B8%EB%A1%9C-%EA%B0%90%EC%8B%B8%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>텍스트를 HTML 태그로 감싸기</h3>\n<p>여러분이 다양한 코드 덩어리를 약간의 고정된 코드로 감싸고자 할 때 블록은 최고의 도구입니다. 예를 들자면 여러분이 어떤 텍스트를 감싸고 있는 HTML 태그를 만들고자 한다면, 텍스트는 가변적이고(왜냐면 아직 당신은 무엇을 태그로 감쌀지 전혀 모르니까요) 태그는 고정적인 부분입니다. 이 형태는 변하지 않습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> wrap_in_h1\n  <span class="token string">"&lt;h1><span class="token interpolation"><span class="token delimiter tag">#{</span><span class="token keyword">yield</span><span class="token delimiter tag">}</span></span>&lt;/h1>"</span>\n<span class="token keyword">end</span>\n\nwrap_in_h1 <span class="token punctuation">{</span> <span class="token string">"Here\'s my heading"</span> <span class="token punctuation">}</span>\n\n<span class="token comment"># => "&lt;h1>Here\'s my heading&lt;/h1>"</span>\n\nwrap_in_h1 <span class="token punctuation">{</span> <span class="token string">"Ha"</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">}</span>\n\n<span class="token comment"># => "&lt;h1>HaHaHa&lt;/h1>"</span>\n</code></pre>\n      </div>\n<p>메서드에 블록을 넘기는 방법은 여러분이 특정 행동을 재사용하고 싶지만 살짝 다르게 쓰고 싶을 때 유용하다는 점을 알아두시기 바랍니다. 이번엔 우리가 HTML 태그로 감싸고 싶은 문자열이 있고, 이걸 조금 다른 용도로 사용하는 경우를 봅시다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">def</span> <span class="token function">wrap_in_tags</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> text<span class="token punctuation">)</span>\n  html <span class="token operator">=</span> <span class="token string">"&lt;<span class="token interpolation"><span class="token delimiter tag">#{</span>tag<span class="token delimiter tag">}</span></span>><span class="token interpolation"><span class="token delimiter tag">#{</span>text<span class="token delimiter tag">}</span></span>&lt;/<span class="token interpolation"><span class="token delimiter tag">#{</span>tag<span class="token delimiter tag">}</span></span>>"</span>\n  <span class="token keyword">yield</span> html\n<span class="token keyword">end</span>\n\n<span class="token function">wrap_in_tags</span><span class="token punctuation">(</span><span class="token string">"title"</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">|</span>html<span class="token operator">|</span> <span class="token constant">Mailer</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span> <span class="token punctuation">}</span>\n<span class="token function">wrap_in_tags</span><span class="token punctuation">(</span><span class="token string">"title"</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">|</span>html<span class="token operator">|</span> <span class="token constant">Page</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token symbol">:body</span> <span class="token operator">=</span><span class="token operator">></span> html<span class="token punctuation">)</span> <span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>첫 번째 경우에는 <code>&#x3C;title>Hello&#x3C;/title></code> 이라는 문자열을 이메일로 보냈고, 두 번째 경우에는 <code>Page</code>  레코드를 만듭니다. 두 경우 모두 같은 메서드를 사용했지만 다른 일을 했습니다.</p>\n<h3 id="노트-작성하기"><a href="#%EB%85%B8%ED%8A%B8-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>노트 작성하기</h3>\n<p>우리가 생각(아이디어)을 데이터베이스 테이블로 저장하는 방법을 빠르게 개발한다고 생각해보겠습니다. 이 도구가 바르게 작동하려면 우리는 노트의 내용을 전달하고 메서드가 데이터베이스 연결을 다루도록 해야 합니다. 이상적으로 우리는 <code>Note.create { "Nice day today" }</code> 라고 호출하고 나면 데이터베이스 연결을 열고 닫는데 일일이 신경 쓰고 싶지 않을 것입니다. 그럼 한번 보시죠.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">Note</span>\n  attr_accessor <span class="token symbol">:note</span>\n\n  <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>note<span class="token operator">=</span><span class="token keyword">nil</span><span class="token punctuation">)</span>\n    <span class="token variable">@note</span> <span class="token operator">=</span> note\n    puts <span class="token string">"@note is <span class="token interpolation"><span class="token delimiter tag">#{</span>@note<span class="token delimiter tag">}</span></span>"</span>\n  <span class="token keyword">end</span>\n\n  <span class="token keyword">def</span> <span class="token keyword">self</span><span class="token punctuation">.</span>create\n    <span class="token keyword">self</span><span class="token punctuation">.</span>connect\n    note <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">yield</span><span class="token punctuation">)</span>\n    note<span class="token punctuation">.</span>write\n    <span class="token keyword">self</span><span class="token punctuation">.</span>disconnect\n  <span class="token keyword">end</span>\n\n  <span class="token keyword">def</span> write\n    puts <span class="token string">"Writing \\"<span class="token interpolation"><span class="token delimiter tag">#{</span>@note<span class="token delimiter tag">}</span></span>\\" to the database."</span>\n  <span class="token keyword">end</span>\n\nprivate\n\n  <span class="token keyword">def</span> <span class="token keyword">self</span><span class="token punctuation">.</span>connect\n    puts <span class="token string">"Connecting to the database..."</span>\n  <span class="token keyword">end</span>\n\n  <span class="token keyword">def</span> <span class="token keyword">self</span><span class="token punctuation">.</span>disconnect\n    puts <span class="token string">"Disconnecting from the database..."</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token constant">Note</span><span class="token punctuation">.</span>create <span class="token punctuation">{</span> <span class="token string">"Foo"</span> <span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code># 결과\nConnecting to the database...\n@note is Foo\nWriting "Foo" to the database.\nDisconnecting from the database...</code></pre>\n      </div>\n<p>데이터베이스 연결, 노트 작성, 그리고 연결을 종료하는 기능의 구체적인 구현은 이 글에서 다루는 범위를 넘어가는 것이라 설명하지 않겠습니다.</p>\n<h3 id="배열에서-나눌-수-있는divisible-요소를-찾기"><a href="#%EB%B0%B0%EC%97%B4%EC%97%90%EC%84%9C-%EB%82%98%EB%88%8C-%EC%88%98-%EC%9E%88%EB%8A%94divisible-%EC%9A%94%EC%86%8C%EB%A5%BC-%EC%B0%BE%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>배열에서 나눌 수 있는(divisible) 요소를 찾기</h3>\n<p>제가 점점 "실제 시나리오" 와 멀어진 설명을 하고 있는 것 같습니다만, 마지막 예시를 보여드리도록 하겠습니다. 만약 배열 안에 있는 모든 요소 중에서 3으로 나뉘는 요소를 가져온다고 할 때(어떤 숫자를 생각하셔도 상관없습니다), 루비 블록을 어떻게 활용할 수 있을까요?</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">Fixnum</span>\n  <span class="token keyword">def</span> to_proc\n    <span class="token builtin">Proc</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">do</span> <span class="token operator">|</span>obj<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token operator">|</span>\n      obj <span class="token operator">%</span> <span class="token keyword">self</span> <span class="token operator">==</span> <span class="token number">0</span>\n    <span class="token keyword">end</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\nnumbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token number">3</span><span class="token punctuation">)</span>\nputs numbers\n</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code># 결과\n3\n6\n9</code></pre>\n      </div>\n<p>역주: 위의 코드를 간략하게 설명하자면, 글 위에 <code>&#x26;block</code> 을 설명한 부분에서 <code>&#x26;</code> 기호 뒤에 붙어있는 객체가 블록이 아니라면 <code>to_proc</code> 으로 블록으로 변환하는 것을 시도한다는 내용이 있습니다. 그래서 <a href="https://en.wikipedia.org/wiki/Monkey_patch">몽키 패칭</a>으로 <code>Fixnum</code> 클래스에 <code>to_proc</code> 메서드를 정의해 두는 겁니다. 3이라는 숫자는 <code>Fixnum</code> 클래스의 객체이기 때문입니다. (루비 2.4.0부터는 Integer 클래스에 속합니다.) 실제로 변환된 블록은 다음의 형태를 가지고 있을 겁니다. <code>*args</code> 는 옵션입니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span>select <span class="token keyword">do</span> <span class="token operator">|</span>n<span class="token operator">|</span>\n  n <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<h2 id="결론"><a href="#%EA%B2%B0%EB%A1%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>결론</h2>\n<p>블록은 단순히 <strong>코드 덩어리</strong>라고 볼 수 있고, <code>yield</code> 는 메서드 어딘가에 그 코드를 <em>주입</em>할 수 있도록 만들어줍니다. 말인 즉슨 여러분은 한 가지 메서드를 다양한 방법으로 조작할 수 있다는 뜻입니다. 그래서 여러 메서드를 작성할 필요가 없어지게 됩니다. (한 메서드를 재사용하여 여러 가지를 할 수 있다는 겁니다.)</p>\n<p>수고하셨습니다! 이 포스트를 통해 여러분은 루비 블록을 더 유용하게 활용하는 방법을 익히셨을 겁니다. 만약 여전히 혼란스러운 부분이 있거나 이 글에서 뭔가 놓친 부분이 있다면 <a href="https://mixandgo.com/blog/mastering-ruby-blocks-in-less-than-5-minutes">댓글을 남겨주세요</a>.</p>\n<p>또는 루비 블록에 대해 새로 배운게 있다면 이 글을 공유해주세요.</p>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>회사에서 개발을 하면서 필요한 기능에 맞추어 메서드를 만들다가 무언가 반복되는 부분이 발견되었습니다. 처음엔 메서드를 쪼개서 한 메서드를 여러 메서드가 공유하는 방식으로 사용했었는데, 생각해보니 그렇게까지 할 것도 없더군요. 분명 머리속엔 <code>yield</code> 라는 게 있다고 기억은 하고 있었는데.. 자세한 용도를 다시 살펴보고자 검색을 하니 이 포스팅을 발견하였고, 내용이 너무 좋아서 바로 번역을 해도 되겠냐고 저자에게 물었습니다. 하지만 실제 번역된 결과물을 내기까지 생각보다 시간이 걸렸습니다.</p>\n<p>포스팅에 작성 된 예제 말고도 <a href="https://ko.wikipedia.org/wiki/%EB%A9%94%ED%83%80_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">메타프로그래밍</a> 등 블록이 사용될 수 있는 부분은 무궁무진하게 많습니다. 이 글을 시작으로 간단하게 블록을 사용하여 이미 작성한 메서드를 개량하는 것부터 시작해보시는게 어떨까요?</p>\n<p>여담이지만 아직까지는 번역을 하면서 존대어를 쓰는 번역도 있고 경어를 쓰는 번역도 있습니다. 제 자신도 실력이 부족하고, 표현에 대해서 큰 고민을 하지 않고 의미 전달에만 초점을 두다 보니 이런 뒤죽박죽인 결과가 나왔네요. 번역 퀄리티가 점점 더 발전할 수 있도록 노력하겠습니다. 물론 좋은 글들을 흡수하여 제 자신이 더 좋은 코드를 작성하는 것도 신경 써야겠지요 :)</p>',
id:"/Users/rinae/Dev/blog/src/pages/posts/2017-01-26-mastering-ruby-blocks-in-less-than-5minutes-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-01-26",path:"/posts/mastering-ruby-blocks-in-less-than-5minutes-kor",title:"[번역] 루비 블록을 5분 이내에 마스터하기",tags:["Ruby","Translation"],category:"Translation"}},{excerpt:"이 번역글은  Justin Weiss의 포스팅 을 번역한 글입니다 오류 지적 및 피드백은 언제나 환영합니다. 댓글이나 메일로 알려주세요 당신은 자신이 만든 앱을 보고 매우 흥분한 상태이다. 한가지 문제가 있다는 점만 빼고 - 테스트를 전혀 작성하지 않았다는 점 말이다. 당신은 TDD(Test-Driven Development…",html:'<ul>\n<li><strong>이 번역글은 <a href="http://www.justinweiss.com/articles/how-do-you-take-an-app-from-test-less-to-tdd/">Justin Weiss의 포스팅</a>을 번역한 글입니다</strong></li>\n<li><strong>오류 지적 및 피드백은 언제나 환영합니다. 댓글이나 메일로 알려주세요</strong></li>\n</ul>\n<hr>\n<p>당신은 자신이 만든 앱을 보고 매우 흥분한 상태이다. 한가지 문제가 있다는 점만 빼고 - 테스트를 전혀 작성하지 않았다는 점 말이다. 당신은 TDD(Test-Driven Development) 방법론을 적용하여 코드를 쓰고 싶었지만, 어디부터 시작해야 할지 전혀 몰라서 막혀버렸다. 어디부터 시작해야 할 것인가? <strong>어떻게 하면 테스트가 없는 앱을 가지고 TDD를 이용한 앱을 작성할 수 있을까?</strong></p>\n<h2 id="이미-작성한-코드를-테스트하라"><a href="#%EC%9D%B4%EB%AF%B8-%EC%9E%91%EC%84%B1%ED%95%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EB%9D%BC" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>이미 작성한 코드를 테스트하라</h2>\n<p>당신은 테스트가 없는 코드 뭉치를 가지고 있다. 그렇다고 <em>당장</em> 기존의 코드를 가지고 테스트를 작성할 수 없다는 뜻은 아니다. 이미 가지고 있는 코드를 테스트하는 것 부터 시작해보라. 기대하던대로 코드가 작동하는지 확인해보는 것이다.</p>\n<p>이건 TDD가 아니다. <strong>그러나 이미 존재하는 코드를 테스팅하는 것은 TDD를 배우는데 도움을 줄 것이다.</strong></p>\n<ul>\n<li>\n<p><strong>예외적인 경우나 에러가 발생하는 조건에 대해 생각하는 연습을 하게 된다</strong></p>\n<p>모든 가능한 입력을 테스트하느라 수 년을 허비하지 않고 테스트를 작성하기 위해서, 당신은 보통 코드의 어느 부분에서 문제가 발생하는지 생각해야 한다. 만약 문자열을 받는 메서드를 테스트한다고 할 때, 대신 심볼을 넣으면 어떤 일이 생길 것인가?  <code>nil</code> 을 넣는다면? 혹은 숫자를 나누는 함수를 테스트한다면, 0을 입력하는 경우에 대한 테스트를 하는 것이 좋다. 하지만 아마 1과 2를 테스트 할 필요는 없을 것이다.</p>\n<p>당신은 충분한 테스트를 작성한 뒤에 메서드의 어느 부분에서 문제가 발생할지 예측하기 시작할 것이다. 그리고 한번 TDD를 시작하면 이 기술을 이용하여 탄탄한 테스트를 작성할 수 있을 것이다. 이 테스트들은 예외 사항들을 더욱 잘 처리하도록 코드를 강제하는 역할을 한다. </p>\n</li>\n<li>\n<p><strong>짜임새있는 테스트를 작성하는 연습을 하게 된다</strong></p>\n<p>이미 작성한 코드에 대한 테스트를 작성한다면, 이 테스트들을 <a href="https://www.justinweiss.com/articles/writing-better-tests-with-the-three-phase-pattern//">구조화하는 다른 패턴들</a>을 시도해볼 수도 있다. 테스트하고자 하는 코드는 이미 있다. 그러니 당신은 테스트 자체, 그리고 이 테스트가 어떤 식으로 작성되어야 하는지에 대해 집중할 수 있다. 그리고 한번 몇몇 좋은 패턴들을 익히고 나면 당신이 기댈 코드가 <em>없을</em> 때에도 더 좋은 테스트를 작성할 것이다.</p>\n</li>\n<li>\n<p><strong>코드를 테스트하기 힘들게 하는 요소들을 발견하게 된다</strong></p>\n<p>테스트들을 작성할 수록 점점 시스템 어느 부분이 테스트하기 제일 어려운지 느끼게 될 것이다. 그런 부분들을 알아차리게 되면 그 부분을 리팩터링이 필요한 부분이라고 표시해둘 수 있다. 더 나아가 처음부터 더욱 테스트하기 좋은 코드를 작성하기 시작할 것이다.</p>\n<p>테스트하기 좋은 코드가 어떤 식으로 생겼는지 알기 시작하면, 그 지식을 기반으로 TDD하기 쉬운 API를 개발할 수 있으며 더욱 빨리 앱을 개발할 수 있을 것이다.</p>\n</li>\n</ul>\n<h2 id="tdd에-익숙해지기ease-into-tdd"><a href="#tdd%EC%97%90-%EC%9D%B5%EC%88%99%ED%95%B4%EC%A7%80%EA%B8%B0ease-into-tdd" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TDD에 익숙해지기(Ease into TDD)</h2>\n<p>\'테스트를 나중에\' 기법을 TDD를 배우는데 도움이 되는 기술로 사용할 수 있다. 하지만 여전히 당신 앱의 일부에 TDD를 적용하고 싶을 것이다.<em>(역주: 테스트를 먼저 작성하고 기능을 개발하는 것을 의미하는 것이라 추정합니다)</em> <strong>그리고 기존의 코드를 가지고 TDD에 익숙해지는 간단한 방법이 있다: <a href="https://ko.wikipedia.org/wiki/%ED%9A%8C%EA%B7%80_%ED%85%8C%EC%8A%A4%ED%8A%B8">회귀 테스트를 작성하는 것이다</a></strong></p>\n<p>회귀 테스트는 이미 확정한 코드를 부수는 것을 억누른다. 아이디어 자체는 아주 간단하다. 당신이 버그를 발견할 때마다, 그 버그를 다시 만들어보기 위해 브라우저에서 여기저기 클릭해보는 대신에:</p>\n<ul>\n<li>버그를 재생성하기 위해 <strong>실패하는 테스트를 작성하라.</strong></li>\n<li><strong>테스트를 실행하라,</strong> 그리고 그 테스트가 확실히 실패하는지 확인하라 (왜냐면 버그는 아직 존재하니까).</li>\n<li>가능한한 가장 간단한 방법으로 <strong>버그를 수정하라.</strong></li>\n<li><strong>테스트를 실행하라,</strong> 그리고 테스트가 통과하는지 확인하라.</li>\n<li>만약 필요하다면 당신이 수정한 방법을 <strong>리팩터링하라.</strong></li>\n</ul>\n<p>이 방법은 새 시스템을 밑바닥부터 TDD로 개발하는 것 보단 훨씬 쉽다. 왜냐면 이미 작성된 코드를 단지 테스트 주도적으로 바꾸기만 하는 것이기 때문이다. 그리고 "Red, Green, Refactor" 라는 TDD의 핵심적인 루프를 습관화하게 된다. <strong>그리고 이쯤부터 당신의 TDD는 테스트가 없는 상태에서 바로 TDD로 개발하는 것에 가까워지게 된다.(And from here, TDD is a shorter step away than trying to go straight to TDD from no tests.)</strong></p>\n<h2 id="테스트가-없는-상태에서-tdd로"><a href="#%ED%85%8C%EC%8A%A4%ED%8A%B8%EA%B0%80-%EC%97%86%EB%8A%94-%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C-tdd%EB%A1%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>테스트가 없는 상태에서 TDD로</h2>\n<p>테스트가 없는 앱은 그렇게 나쁜 출발점은 아니다. 이미 작성된 코드를 테스트할 때, 당신은 좋은 TDD 테스트를 작성하기 위해 무엇이 필요한지 많이 배우게 될 것이다. \'테스트를 나중에\' 하는 것은 시작부터 TDD로 개발하는 것 보다 쉽다. 왜냐면 아직 어떻게 디자인해야할지 모르는 API들을 상상할 필요가 없기 때문이다. 그리고 자신의 앱에 한번 TDD를 도입하기로 결정했다면 회귀 테스트를 통해 익숙해질 수 있다.</p>\n<p>그러니 만약 당신이 상상하고 있는 시스템에 TDD를 어떻게 도입해야 할 지 모르겠다면, 계속 테스트를 작성하라. 비록 코드를 먼저 써야 하더라도 말이다.</p>\n<hr>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>2017년 첫 번역은 TDD에 관한 글입니다. TDD 혹은 BDD(Behavior Driven Development)가 개발 방법론에 있어서 절대적인 진리는 아닐 겁니다. 다만 많이 권장되는데는 이유가 있겠지요. 저는 간단하게 TDD가 확장성, 유지보수성에 큰 도움이 된다고 인지하고 있습니다.</p>\n<p>제 자신도 아직 실력이 미천하여 코드 없이 테스트를 작성한다는 것에 큰 두려움을 느끼면서 지내왔습니다. 최근에야 일부 기능에 대해 예측되는 결과를 먼저 테스트로 작성하고, 이후에 실제 기능을 작성하여 잘 작동하는지 확인하는 수준에 불과합니다.</p>\n<p>그러다가 마침 기존에 작성한 코드를 이용하여 TDD를 배워나가는 과정에 대해 간단한 포스팅이 있어 이렇게 소개를 하게 되었습니다. 음.. 당장은 기존의 코드를 이용하여 테스트를 작성하는게 꽤 부끄럽지만 (왜냐면 테스트를 작성할 것도 없이 손대야 할 부분들이 수두룩하게 보이니까요) 이런 방식으로 약간 우회하여 TDD를 습득하는 방법도 있겠지요. </p>\n<p>그럼 모두 2017년 한해에도 좋은 테스트 + 테스트를 통과하는 좋은 코드 작성이 잘 되시길 바랍니다 :)</p>\n<p>(추가) 피드백에 의해 \'You\' 라는 단어의 직역이 너무 많이 들어간 것 같아 조금 수정하였습니다. 확실히 번역할 때 \'당신\' 이라는 단어가 일일이 들어갈 필요는 없겠네요. 좋은 피드백을 주신 <a href="https://twitter.com/initnirvana">@initNirvana</a> 님께 감사드립니다.</p>',id:"/Users/rinae/Dev/blog/src/pages/posts/2017-01-16-how-do-you-take-an-app-from-no-tests-to-tdd-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-01-16",path:"/posts/how-do-you-take-an-app-from-no-tests-to-tdd-kor",title:"[번역] 테스트가 없는 앱을 이용하여 TDD를 배우는 방법",tags:["Ruby","Testing","Translation"],category:"Translation"}},{excerpt:"이 포스팅은  Luca Guidi의 포스팅 을 번역한 글입니다 오역이나 잘못된 표현 지적은 언제나 환영합니다 객체 지향 프로그래밍, 인터페이스, 동적 타입에 대한 짧은 이야기 역주: 이 글은 가상의 이야기를 기반으로 객체 지향의 개념을 일부 짚어주는 글입니다 '루비 3'는 아직 개발 중이며, 어떤 형태로 나오게 될 지 모릅니다. 오늘은 주식회사 활빈당(Spectacular Foo Ltd…",html:'<ul>\n<li><strong>이 포스팅은 <a href="https://lucaguidi.com/2016/06/07/the-penguin-that-cannot-fly.html">Luca Guidi의 포스팅</a>을 번역한 글입니다</strong></li>\n<li><strong>오역이나 잘못된 표현 지적은 언제나 환영합니다</strong></li>\n</ul>\n<hr>\n<h2 id="객체-지향-프로그래밍-인터페이스-동적-타입에-대한-짧은-이야기"><a href="#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%8F%99%EC%A0%81-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A7%A7%EC%9D%80-%EC%9D%B4%EC%95%BC%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>객체 지향 프로그래밍, 인터페이스, 동적 타입에 대한 짧은 이야기</h2>\n<p><em>역주: 이 글은 가상의 이야기를 기반으로 객체 지향의 개념을 일부 짚어주는 글입니다 \'루비 3\'는 아직 개발 중이며, 어떤 형태로 나오게 될 지 모릅니다.</em></p>\n<p>오늘은 주식회사 활빈당(Spectacular Foo Ltd. <em>역주: 보통 임의의 사람 이름을 홍길동이라고 하다 보니 임의의 회사 이름은 무엇으로 할까 하다가...</em>)의 본사에서 일어나는 일을 이야기해보고자 한다. 이 회사는 인디 게임계에서 떠오르고 있는 회사이고, 다음 블록버스터 타이틀인 <em>흔해빠진 새들(Banal Birds)</em> 의 발매를 앞두고 있다.</p>\n<p>올해는 2019년이고, 루비 3는 세배나 빠르고, 놀랍게도 모든 문제를 해결할 수 있는 동적 타입을 가지고 있다! 조금 향수에 젖은 결정이긴 하지만 당신은 리드 개발자로서 루비를 이 프로젝트에 사용하기로 결정했다.</p>\n<p>당신은 관리자인 제인에게 최종 코드 리뷰를 부탁했다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">Game</span>\n  <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>bird<span class="token punctuation">:</span> <span class="token constant">Bird</span><span class="token punctuation">)</span>\n    <span class="token variable">@bird</span> <span class="token operator">=</span> bird\n  <span class="token keyword">end</span>\n\n  <span class="token keyword">def</span> play\n    <span class="token variable">@bird</span><span class="token punctuation">.</span>fly\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>아이디어는 간단하지만 혁명적이었다: 플레이어는 <strong>어떤</strong> 종류의 새라도 고를 수 있고 그 새가 날아가는 것을 볼 수 있다. 이건 엄청날거야!(This is gonna be kickass!)</p>\n<p>당신은 유명한 루비 젬 <code>acts_as_a_bird</code>(새처럼 행동하라)를 재사용했다. 이 젬은 <code>Bird</code> 를 완벽하게 구현하였다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">Bird</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>많은 새들 가운데서 우리는 올빼미나 벌새도 구현했다:</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">Owl</span> <span class="token operator">&lt;</span> <span class="token constant">Bird</span>\n  <span class="token keyword">def</span> fly\n    puts <span class="token string">"I\'m a flying owl"</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Hummingbird</span> <span class="token operator">&lt;</span> <span class="token constant">Bird</span>\n  <span class="token keyword">def</span> fly\n    puts <span class="token string">"I\'m a flying hummingbird"</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>소프트웨어 공학의 참으로 놀라운 부분 아닌가? 글쎄, 이 게임에 엄청난 투자를 했음에도 불구하고 문제가 하나 남아있었다: 제인이 \'그러면 펭귄은요?\' 라고 물었다. 그렇다, 펭귄은 새지만 날 수 없다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">class</span> <span class="token class-name">Penguin</span> <span class="token operator">&lt;</span> <span class="token constant">Bird</span>\n  <span class="token comment"># LOL I\'m a penguin (ㅋㅋㅋ 난 펭귄인데?)</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>오늘은 게임 발매 당일이고 당신은 버그를 수정하기 위한 여력이 없다. 그래도 발매는 되어야 한다(The show must go on). 그래서 당신은 게임을 발매하고 사용자들이 펭귄을 고르지 않기를 기도할 수 밖에 없다.</p>\n<p>당신은 기분이 별로다. 그리고 자기 자신에게 묻기 시작한다: <em>왜 내가 루비를 골랐지? 왜 동적 타입을 쓴걸까?</em></p>\n<p>제인은 "당신이 정말 사용해야 했던 것은 타입이 아니라 인터페이스에요." 라고 말했다. 당신은 그 말을 듣자마자 "맙소사, 자바 말인가요!?(OMG, Java!)"  라고 말했지만, 그녀는 찬찬히 시간을 들여 그 개념은 <a href="http://golangtutorials.blogspot.kr/2011/06/interfaces-in-go.html">Go(GoLang)</a>에서 빌려온 것이라고 설명하였다.</p>\n<blockquote>\n<p>"루비같이 동적 타입을 가지고 있는 언어에서, 당신이 정말 신경써야 하는 것은 <strong>행동(behavior)</strong>이에요. 당신은 객체에 <em>메세지를 보낼 수 있도록</em> 해야합니다. 그게 객체 지향 프로그래밍의 핵심이에요."</p>\n</blockquote>\n<p>그녀는 계속 설명했다: "타입을 사용하는 것은, 당신이 수행하고자 하는 일보다 과하게 많은 일을 수행하려는 객체를 받아들인다는 것과 같아요. 그리고 그건 <a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4_%EB%B6%84%EB%A6%AC_%EC%9B%90%EC%B9%99">인터페이스 분리 원칙</a>을 무너뜨립니다."</p>\n<blockquote>\n<p>"차이점은 미묘해요: 당신은 <code>Bird</code> 클래스가 <code>fly</code> 메서드에 반응할 것이라(respond to) 추측했지요. 하지만 언제나 그렇진 않아요. 대신 프로그래밍 언어 측에서<em>(역주: 문맥 상 프로그래머가 작성한 코드를 말하는 것으로 보입니다)</em> 주어진 객체가 특정 메서드(혹은 메서드의 모음)를 구현하고 있는 지 확인하는 도구를 제공해야 합니다."</p>\n</blockquote>\n<p>이 시점에서 당신은 충격을 받았다. 당신은 루비가 행동의 모음을 정의할 수 있는 특별한 모듈을 제공했으면 정말 좋겠다고 생각했다<em>(역주: wished라는 동사를 사용했지만 문맥상 희망하다라고 쓰기엔 딱딱해 보입니다)</em>.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code>interface <span class="token class-name">Flying</span>\n  <span class="token keyword">def</span> fly\n    puts <span class="token string">"I\'m a flying <span class="token interpolation"><span class="token delimiter tag">#{</span> name <span class="token delimiter tag">}</span></span>"</span>\n  <span class="token keyword">end</span>\n\n  <span class="token keyword">def</span> name\n    <span class="token string">"bird"</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Falcon</span>\n  include <span class="token constant">Flying</span>\n\n  <span class="token keyword">def</span> name\n    <span class="token string">"falcon"</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Game</span>\n  <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>bird<span class="token punctuation">:</span> <span class="token constant">Flying</span><span class="token punctuation">)</span>\n    <span class="token variable">@bird</span> <span class="token operator">=</span> bird\n  <span class="token keyword">end</span>\n\n  <span class="token keyword">def</span> play\n    <span class="token variable">@bird</span><span class="token punctuation">.</span>fly\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>또한 가상머신(VM)이 \'펭귄은 날 수 없다\' 같은 당황스러운 에러를 내뿜기 전에 당신을 막아주었으면 좋겠다고 생각했다. </p>\n<hr>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>예전에 RORLAB 슬랙의 질문 채널에서 이런 내용의 대화를 주고받은 적이 있습니다.</p>\n<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 544px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 87.86764705882352%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAACoklEQVQ4y51USa7TQBT8N+ISnII7sGHDgg1ixwI2XIILfCEhJAQ7Fh9+QElsx4lndybHYzwlzuPVSxwIYQORWt3pobqqXrVvtmVLb9/dk6viL0T0Bm2/37dVVRP39K+/m6wo6emL16RbKpzNZne+H9x5ntfpukGu61IYhrRYLInnpGHOdhwZHw6Ha8B+kCQpRVHEAIosy6IgCBhoQb7v03w+J497h4Ewl2UZA/pyEfZ7smdB2+32F2BVVbIJYEVRiNyu66QHkz/7rjvQbrc7/+/bGRAguA3MIJOlS79crmS82WxkLeA5MFVKiarlcin7giAUjAtAHLpk0Z1vxg+M2rY9z2G937M/9TeK0V89f0LDH19pMjGprhv2ovyvCktRIOPls8c0uP9G0+mMVqujRJgMC0xzKnIgTam5+IwzqHLIslE0FGe1Wh8lg2bTNFK5vqrwZDazpLo4jKgArI8PwHHmrwwNQ6dHDx/Q54/vaTAYUBzHDJ5L1RGDuq5px741TSvjsixlDYAFr5dlJczwXzwEs08fbqVy47EmDBBqDjkNhyO2gSXbHGqbA23b1Ace4Xa4BwFUHGm4iA1uh+Q0TmQxSRJac9DTNJUxvI2ijdgga+u1rOEc2PUWnAGxiFtDl03nZtsOmcwOrKypRcoPJfSappNhGNJPWYVhTMTfPM8vAeGbzhtRudFozNU15SCkmxwn13Kk4kgCbNB0XS6AKmTz6i2DMmJSZgUVm5RyvgDepGlGZVqIRBxGPGAJvFuvI4kXHsQ1IH+u1NSh2JuT/n1Irn1kBMk+FwTZHGuasMIcmKKQKBIYw1/I/u3pbcUX+HH8ZC1OQfakRwMzvKC+9R8PPMmrjwOyheD2IACFLARbnV4Exqg2YoM9yGSeF/Jc+99PtUBNJ1KbsKwAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="slack_conversation"\n        title=""\n        src="/static/2016-12-31-sc1-a13427f93ee2f60a5107ed26df13cfdc-959a9.png"\n        srcset="/static/2016-12-31-sc1-a13427f93ee2f60a5107ed26df13cfdc-5510e.png 198w,\n/static/2016-12-31-sc1-a13427f93ee2f60a5107ed26df13cfdc-f5670.png 395w,\n/static/2016-12-31-sc1-a13427f93ee2f60a5107ed26df13cfdc-959a9.png 544w"\n        sizes="(max-width: 544px) 100vw, 544px"\n      />\n    </span>\n  </span>\n  </p>\n<p>마침 이 글을 읽은 직후라 비유를 <code>fly</code> 로 사용했었던 것이 기억나네요. 보통 동적 타입을 사용하는 언어들의 단점으로 여러가지가 거론되지만 \'실행하기 전에는 무슨 일이 일어날 지 바로 알 수 없다\' 라는 단점을 본 적이 있습니다.</p>\n<p>하지만 본문에서 설명한 개념으로 그런 단점을 최소화하는게 가능하겠지요. 핵심은 프로그래머가 자신의 프로그램이 어떻게 동작할지를 면밀하게 설계할 필요가 있다는 것입니다.</p>\n<p>위 개념을 조금 더 적극적으로 활용하고자 하시는 루비 프로그래머분들은 <a href="http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=49317754">루비로 배우는 객체지향 디자인</a>의 5, 6, 7장을 찬찬히 살펴보시면 많은 도움이 될 것입니다.</p>\n<p>2016년의 마지막 날, 이 글을 읽는 분들에게 조그마한 새해 선물이 되었이 되었으면 좋곘고 새해에도 많은 분들과 더 좋은 내용의 글을 주고받을 수 있도록 개발자로서의 역량을 갈고 닦고 싶습니다 :)</p>',id:"/Users/rinae/Dev/blog/src/pages/posts/2016-12-31-the-penguin-that-cannot-fly-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2016-12-31",path:"/posts/the-penguin-that-cannot-fly-kor",title:"[번역] 펭귄은 날 수 없다(The Penguin That Can't Fly)",tags:["Ruby","OOP","Translation"],category:"Translation"}},{excerpt:"본 포스트는  Luca Guidi의 포스팅을  번역한 글입니다 문제를 설명하는데 나온 하나미(Hanami…",html:'<ul>\n<li><strong>본 포스트는 <a href="https://lucaguidi.com/2016/12/27/isolate-global-state.html">Luca Guidi의 포스팅을</a> 번역한 글입니다</strong></li>\n<li><strong>문제를 설명하는데 나온 하나미(Hanami)에 대해서는 <a href="https://emaren84.github.io/blog/archivers/hanami-introduction">이 포스팅</a>을 참조해주세요</strong></li>\n<li><strong>전문 번역이 아니기에 부족한 표현이나 오역은 언제든지 지적해주세요</strong></li>\n</ul>\n<hr>\n<p>소프트웨어 프로그램에서 전역 상태를 사용하는건 개발하기엔 쉽지만 유지보수 할 때는 악몽이 된다. 예상치 못한 상황에서 발생하여 추적하기도 어려운 버그가 되기 쉽상이다.</p>\n<p>왜 그렇게 되는지, 그리고 어떻게 그 문제를 완화할 수 있을지 살펴보자.</p>\n<p><em>역주: 이 글에서 전역 상태는 전역 변수와 거의 동일한 의미로 사용되는 것으로 추정됩니다.</em></p>\n<h2 id="문제의-예시"><a href="#%EB%AC%B8%EC%A0%9C%EC%9D%98-%EC%98%88%EC%8B%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>문제의 예시</h2>\n<p>예를 들자면 하나미의 코드 베이스 안에서 우리는 환경 변수에 따라 어떻게 프레임워크가 설정되는지 테스트 할 필요가 있다.</p>\n<p>우리<em>(역주: 하나미 개발팀으로 보입니다)</em>는 보통 테스트를 이런 식으로 작성한다:</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token constant">RSpec</span><span class="token punctuation">.</span>describe <span class="token constant">Hanami</span><span class="token punctuation">:</span><span class="token symbol">:Environment</span> <span class="token keyword">do</span>\n  before <span class="token keyword">do</span>\n    <span class="token constant">ENV</span><span class="token punctuation">[</span><span class="token string">\'HANAMI_ENV\'</span><span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token keyword">nil</span>\n    <span class="token constant">ENV</span><span class="token punctuation">[</span><span class="token string">\'RACK_ENV\'</span><span class="token punctuation">]</span>    <span class="token operator">=</span> <span class="token keyword">nil</span>\n    <span class="token constant">ENV</span><span class="token punctuation">[</span><span class="token string">\'HANAMI_HOST\'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nil</span>\n    <span class="token constant">ENV</span><span class="token punctuation">[</span><span class="token string">\'HANAMI_PORT\'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nil</span>\n\n    <span class="token comment"># ...</span>\n  <span class="token keyword">end</span>\n\n  context <span class="token string">"when HANAMI_ENV is set"</span> <span class="token keyword">do</span>\n    before <span class="token keyword">do</span>\n      <span class="token constant">ENV</span><span class="token punctuation">[</span><span class="token string">\'HANAMI_ENV\'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">\'production\'</span>\n      <span class="token variable">@env</span> <span class="token operator">=</span> described_class<span class="token punctuation">.</span><span class="token keyword">new</span>\n    <span class="token class-name">end</span>\n\n    <span class="token comment"># ...</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>우리는 보통 각각의 테스트를 실행하기 전에 모든 환경 변수를 초기화해왔다. 그리고 우리가 필요로 하는 특별한 상황(the edge case)에서만 하나씩 설정했다.</p>\n<p>이러한 접근 방식을 사용할 때의 <strong>문제는</strong> 이 방법이 루비 프로세스의 전역 상태를 <strong>더럽힌다는</strong> 것이다. 우리가 테스트 파일을 단독으로 실행할 때는  <code>before</code> 블록이 환경 변수를 리셋하기 때문에 잘 작동한다.</p>\n<p>그러나 모든 테스트를 한번에 실행할 때, 테스트는 꼬이게 될 것이다. 환경 변수 초기화가 언제나 작동하진 않기 때문이다.</p>\n<p>만약 한 테스트가 <code>ENV</code> 속성을 변환하고 나서 뒷정리를 하지 않으면, 그 다음 테스트는 기존의 <code>ENV</code> 값의 변화를 <strong>물려받아서</strong> 우리가 기대하던대로 작동하지 않을 수 있다.</p>\n<p>때때로 위의 예시 처럼 눈에 띄는 부분에서 변화를 준 경우에는 우리가 <code>after</code> 블록을 설정하여 뒷정리를 할 수 있다. 그러나 다른 때엔 변환한 것(the mutation)이 우리 눈에 보이지 않는 부분에서 부작용을 초래할 수 있다.</p>\n<p>이건 소스의 버그다. 그리고 이 버그는 엉킨 실타래처럼 되어 디버그하기 힘들다.</p>\n<p><strong>오랜 시간동안, 여러 가지 전역 상태의 조합하는 것은 하나미를 지속적 통합 개발(<a href="https://ko.wikipedia.org/wiki/%EC%A7%80%EC%86%8D%EC%A0%81_%ED%86%B5%ED%95%A9">CI builds</a>)이 힘들도록 만들고 여러 버그를 일으켰다.</strong></p>\n<p>개발자로서의 내 경험으로 미루어보아(<em>역주: Luca Guidi는 숙련된 웹 개발자입니다</em>) 이런 형태의 문제를 완화할 수 있는 유일한 방법은 <strong>전역 상태를 격리하거나, 전역 상태를 사용하는 것을 아예 피하는 것이다.</strong> 우리는 <strong>가능한한 전역 상태를 사용하는 것을 줄이도록</strong> 하나미의 내부 구현을 바꾸고 있다.</p>\n<h2 id="문제의-해법"><a href="#%EB%AC%B8%EC%A0%9C%EC%9D%98-%ED%95%B4%EB%B2%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>문제의 해법</h2>\n<p>앞서 이야기한 특별한 경우를 위해 우리는 환경 변수를 격리할 수 있는 새로운 객체를 선보였다. 이는 <code>Hanami::Env</code> 라고 불린다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">module</span> <span class="token constant">Hanami</span>\n  <span class="token keyword">class</span> <span class="token class-name">Env</span>\n    <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>env<span class="token punctuation">:</span> <span class="token constant">ENV</span><span class="token punctuation">)</span>\n      <span class="token variable">@env</span> <span class="token operator">=</span> env\n    <span class="token keyword">end</span>\n\n    <span class="token keyword">def</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>\n      <span class="token variable">@env</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>\n    <span class="token keyword">end</span>\n\n    <span class="token keyword">def</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>\n      <span class="token variable">@env</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value\n    <span class="token keyword">end</span>\n\n    <span class="token comment"># ...</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>구현 자체는 별 것 아니다: <code>ENV</code> 에 접근하는 것을 캡슐화하는 것이다.</p>\n<p>우리는 환경 변수를 관리하기 위해 자체 인터페이스를 정의했다. 우리는 명시적인 구현(concrete implementation)을 사용하기보다(<code>ENV</code>) 추상화(<code>Hanami::Env</code>)에 의존하고 있다(<a href="https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84_%EC%97%AD%EC%A0%84_%EC%9B%90%EC%B9%99">의존관계 역전 원칙 참고</a>). </p>\n<p><code>Hanami::Environment</code> 는 프로젝트의 환경 변수를 설정하는 책임을 가지고 있는데, 우리는 이런 방식으로 사용한다:</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token keyword">module</span> <span class="token constant">Hanami</span>\n  <span class="token keyword">class</span> <span class="token class-name">Environment</span>\n    <span class="token keyword">def</span> <span class="token function">initialize</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>\n      opts <span class="token operator">=</span> options<span class="token punctuation">.</span>to_h<span class="token punctuation">.</span>dup\n      <span class="token variable">@env</span> <span class="token operator">=</span> <span class="token constant">Hanami</span><span class="token punctuation">:</span><span class="token symbol">:Env</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>env<span class="token punctuation">:</span> opts<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token symbol">:env</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token constant">ENV</span><span class="token punctuation">)</span>\n\n      <span class="token comment"># ...</span>\n    <span class="token keyword">end</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<p>우리가 하나미 프로젝트를 사용할 때, <code>:env</code> 옵션은 설정되지 않은 상태이다. 이로 인해 <code>@env</code> 는 <code>ENV</code> 를 참조하여 루비 프로세스의 진짜 환경 변수를 읽거나 쓰게 된다.</p>\n<p>이렇게 우리는 <code>Hanami::Environment</code> 의 테스트 중에 많은 양의 코드를 단순화하고, <strong>공유되고 변화 가능한 상태(shared mutable state, 즉 <code>ENV</code> 말이다)의 사용을 피할 수 있었다.</strong> 아래 코드에서 우리는 <code>ENV</code> 와 유사하게 동작하는 <code>:env</code> 를 객체의 옵션으로 전달하지만, 이 것은 실제로 <code>ENV</code>가 아니다: 그냥 <code>Hash</code> 이다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ruby"><code><span class="token constant">RSpec</span><span class="token punctuation">.</span>describe <span class="token constant">Hanami</span><span class="token punctuation">:</span><span class="token symbol">:Environment</span> <span class="token keyword">do</span>\n  context <span class="token string">"when HANAMI_ENV is set"</span> <span class="token keyword">do</span>\n    <span class="token function">let</span><span class="token punctuation">(</span><span class="token symbol">:env</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token builtin">Hash</span><span class="token punctuation">[</span><span class="token string">"HANAMI_ENV"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"production"</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n\n    it <span class="token string">"tests something interesting"</span>\n      <span class="token variable">@env</span> <span class="token operator">=</span> described_class<span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span>env<span class="token punctuation">:</span> env<span class="token punctuation">)</span>  \n    <span class="token keyword">end</span>\n\n    <span class="token comment"># ...</span>\n  <span class="token keyword">end</span>\n<span class="token keyword">end</span>\n</code></pre>\n      </div>\n<h2 id="결론"><a href="#%EA%B2%B0%EB%A1%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>결론</h2>\n<p><a href="https://ko.wikipedia.org/wiki/%EC%BA%A1%EC%8A%90%ED%99%94">캡슐화</a>와 <a href="http://solnic.eu/2013/12/17/the-world-needs-another-post-about-dependency-injection-in-ruby.html">의존성 주입</a>을 적절하게 사용하여, 각각의 테스트에서 발생할 수 있는 변화는 나머지 테스트에서는 보이지 않게 되었다. 결과적으로 안정적인 테스트 수행을 할 수 있게 되었고, 하나미 내부를 <a href="https://ko.wikipedia.org/wiki/SOLID">SOLID 디자인</a>에 맞게 구성할 수 있었다. </p>\n<hr>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>보통 루비 프로젝트에서 <code>dotenv</code> 같은 젬으로 환경 변수를 관리합니다. 사실 이 환경 변수라는 개념도 저에게 아직 모호한 개념이지만, 객체지향 프로그래밍의 핵심적인 주제인 캡슐화와 의존성 주입을 어떤 식으로 활용하는지 좋은 예를 보여준 것 같아 한번 번역해보게 되었습니다.</p>\n<p>특히 제가 요즘에야 테스트를 작성해보기 시작했는데, 테스트를 개별로 실행할 때는 몰라도 전체 테스트를 실행할 때 원인을 알 수 없는 오류가 생길 때가 종종 있었습니다. 이 글을 통해 약간의 힌트를 얻었다는 생각도 듭니다. </p>',id:"/Users/rinae/Dev/blog/src/pages/posts/2016-12-30-isolate-global-state-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2016-12-30",path:"/posts/isolate-global-state-kor",title:"[번역] 전역 상태를 격리하라",tags:["Ruby","Hanami","Testing","Translation"],category:"Translation"}},{excerpt:"이 포스팅은  Justin Weiss의 블로그 포스팅 을 허가 아래 번역한 글입니다 본 번역물의 저작권은 따로 없으며 인용하실 때 출처를 밝혀주신다면 무척 고맙겠습니다 표현이 부족한 부분이나 오타를 발견하시면 댓글이나 트위터를 통해 알려주세요 Thom Parkin…",html:'<ul>\n<li><strong>이 포스팅은 <a href="https://www.justinweiss.com/articles/the-easiest-way-to-get-into-open-source/">Justin Weiss의 블로그 포스팅</a>을 허가 아래 번역한 글입니다</strong></li>\n<li><strong>본 번역물의 저작권은 따로 없으며 인용하실 때 출처를 밝혀주신다면 무척 고맙겠습니다</strong></li>\n<li><strong>표현이 부족한 부분이나 오타를 발견하시면 댓글이나 트위터를 통해 알려주세요</strong></li>\n</ul>\n<hr>\n<p>Thom Parkin이 <a href="http://www.justinweiss.com/blog/2014/10/28/how-to-go-beyond-documentation-and-learn-a-new-library/#comment-1657912979">제 지난번 글에 아주 중요한 지적을 해 주었습니다.</a></p>\n<blockquote>\n<p>좋은 조언입니다. 그러나 당신은 아주 중요하고 결정적인 포인트를 하나 놓쳤어요. 지금 하고 있는 이야기는 오픈 소스에 관한 이야기이기 때문에 당신이 한번 어떤 기능이나 함수가 문서화가 잘 안되어있다는 것을 발견한다면, <strong>당신은 그 문서를 업데이트 하고 풀 리퀘스트(Pull Request)를 제출해야 합니다.</strong> 그렇게 전체 커뮤니티가 도움을 받게 되고 더불어 당신은 그런 참여를 통해 어느 정도의 "코더 평판(coder cred)"을 얻게 됩니다.</p>\n</blockquote>\n<p><strong>나는 Thom이 이 점을 언급해주어서 기뻤습니다. 이는 아주 중요한 것이기 때문입니다.</strong> 문서를 수정하는 것은 당신이 사용하고 좋아하는 프로젝트에 기여를 시작할 수 있는 가장 쉬운 방법입니다.</p>\n<p>제가 Rails, Rubinus, Elixir에 처음 기여했던 것들은 모두 문서 수정이었습니다. 저는 작은 수정들을 가해왔습니다. 문장을 더 명확하게 하고, 코드를 직접 읽어야만 발견할 수 있는 부분들을 설명하는 작업을 하거나, 심지어 단지 포맷이 잘못된 부분을 수정하기도 했습니다. 이 모든 것들은 좀 커다란 오픈 소스 프로젝트들을 돕는 가장 빠르고 쉬운 방법들입니다. 비록 이 일들이 제가 프로젝트에 유일하게 기여한 것들이지만, 여전히 미래의 사용자들을 돕고 있습니다. 심지어 미래의 제 자신도요. 그게 바로 오픈소스죠(And that’s what open source is all about).</p>\n<h2 id="왜-문서를-수정하는-것이-그렇게-좋은-방법인가"><a href="#%EC%99%9C-%EB%AC%B8%EC%84%9C%EB%A5%BC-%EC%88%98%EC%A0%95%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EA%B7%B8%EB%A0%87%EA%B2%8C-%EC%A2%8B%EC%9D%80-%EB%B0%A9%EB%B2%95%EC%9D%B8%EA%B0%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>왜 문서를 수정하는 것이 그렇게 좋은 방법인가</h2>\n<p>Rails같이 거대한 프로젝트에선 문서를 수정하는 것이 가장 부담이 덜 되는 기여 방법입니다.</p>\n<ul>\n<li><strong>당신은 버그를 수정하기 위해 프로젝트를 세팅할 필요가 없습니다.</strong> 당신은 그저 문서를 업데이트 하는 것이기 때문에 테스트를 돌리거나 앱을 돌릴 필요가 없습니다. 심지어 당신은 자신의 컴퓨터에 프로젝트를 클론할 필요도 없습니다 - Github에서 바로 수정할 수 있어요!</li>\n<li><strong>관리자(Maintainer)가 당신의 풀 리퀘스트에 수정을 요청한다면, 보통 어법(wording)이나 취향 때문일 겁니다.</strong> 이런 변경점은 당신의 코드가 비판받는 것 보다 받아들이기 쉽습니다. 그리고 만들기도 쉽습니다. 왜냐면 당신은 테스트나 코드를 업데이트 할 필요가 없으니까요. 단지 단어들만 업데이트하면 됩니다.</li>\n<li><strong>문서화(Documentation)는 프로젝트 관리자에게는 힘든 일입니다. 그래서 업데이트는 큰 도움이 됩니다.</strong> 종종 코드의 작성자들은 자신의 코드와 너무 밀접해 있어서, 어느 부분이 혼란스러운 부분인지 잘 이해하지 못합니다. 그들은 다른, 혹은 뉴비 개발자들이 어느 부분의 문서에 도움이 필요한지 말해주길 원합니다. 당신의 프로젝트를 초보자의 시점으로 보는 건 연습이 필요합니다. 모두가 그런 기술을 가진 것은 아니거든요.</li>\n<li><strong>마지막으로, 당신은 프로젝트에 부담없는 변화를 주면서도 관리자와 관계를 형성할 수 있습니다.</strong> 당신은 프로젝트의 방향을 바꾸는 게 아닙니다. 예를 들면 당신이 전체 기능에 기여하는 것 처럼요. 그래서 당신의 변경점은 관리자가 리뷰하기 쉽고, 그들은 보통 당신에게 더 빠르게 답변 할 것입니다. 당신의 머지 요청은 "이게 정말 좋은 생각일까요?" 같은 말에 가로막히지 않을 것입니다.</li>\n</ul>\n<p>당신은 그 관계를 유지하면서 점차 신뢰받는 기여자로 보이기 시작할 것입니다. 당신의 풀 리퀘스트는 더 빠르게 리뷰될 것이고, 당신들이(당신과 관리자) 더 복잡한 기능 요청이나 버그 수정에 대해 자세하게 이야기를 나누기도 쉬워집니다.</p>\n<p>당신의 첫 기여를 <strong>시작하기도 쉽고, 하기도 쉽고, 머지도 더 빠르게 되는</strong> 문서 수정으로 해 보시는 게 어떨까요?</p>\n<h2 id="업데이트-된-문서에-다시-기여하는-방법"><a href="#%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%90%9C-%EB%AC%B8%EC%84%9C%EC%97%90-%EB%8B%A4%EC%8B%9C-%EA%B8%B0%EC%97%AC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>업데이트 된 문서에 다시 기여하는 방법</h2>\n<p>버그 수정과 마찬가지로 문서 업데이트에 기여하는 데는 유의할 점이 있습니다: <strong>둘 다 공통적으로 \'잘못되었다고 느껴지는 것들(things that feel wrong)\'에 많이 신경을 써야 한다는 점입니다.</strong> 당신은 주의를 기울여야 합니다.</p>\n<p>보통 코드가 당신이 기대하던대로 동작하지 않을 때가 문서를 업데이트 해야 할 시기입니다. 만약 당신이 코드를 직접 수정하여 문제를 해결한다면, 마찬가지로 다른 사람들에게 이에 대해 알려야 할 겁니다. 혹은 당신이 읽고 있는 문서의 잘못된 형식이나 오타가 신경쓰일 수도 있습니다. 당신이 고치지 않는다면 누가 할까요?</p>\n<p>당신이 어디를 변경하고 어떻게 말로 표현해야하는지 좋은 아이디어가 떠올랐다면, 그 부분을 변경하고 한번 Github에 풀 리퀘스트를 올려보세요.</p>\n<p>만약 당신이 문서를 업데이트 하는 가장 좋은 방법을 계속 구상중이라면 Github에 이슈를 열어보세요. 이런 식으로요:</p>\n<blockquote>\n<p>"저기요, 이건 제가 보기에 좀 헷갈리네요. 제가 이런 식으로 업데이트하는 걸 생각해 봤는데요: ... 어떻게 생각하세요? 제가 더 넣어야 할 내용이 있을까요?"</p>\n</blockquote>\n<p>이렇게 당신은 모두를 만족시키는 표현법을 함께 제안할 수 있습니다.</p>\n<p>마지막으로 당신이 답변을 얻지 못하더라도 주눅들지 마세요. 큰 프로젝트는 여러 일들이 진행됩니다. 그래서 당신의 기여는 그 사이 어딘가로 쏙 빠져버리기 쉽지요. <strong>일주일 안팎으로 당신이 아무런 답변을 듣지 못한다면, 관리자에게 다시 물어보세요.</strong></p>\n<p>보통 당신이 라이브러리를 사용하게 되면 무엇보다 먼저 마주치는 것이 문서입니다. 그러므로 문서를 자세하고 명료하게 만드는 것은 중요합니다.</p>\n<p>그러니 당신이 쓰는 코드가 혼란스러울 때나 직접 소스를 들여다 보아야 할 때, 다음 사람을 위해 보기 쉽게 만들어주세요. 간단한 업데이트를 작성하고 다시 기여하세요. 이것이 제가 알고있는 오픈 소스 기여자가 되는 가장 쉬운 방법입니다.</p>\n<hr>\n<h2 id="번역-후기"><a href="#%EB%B2%88%EC%97%AD-%ED%9B%84%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>번역 후기</h2>\n<p>첫 번역이라 부족한 점이 아주 많았습니다. 영어로 된 글을 읽는 것이 그래도 어느 정도는 읽을만 하다고 생각했는데, 다른 사람이 한글로 된 번역문을 읽으려면 훨씬 번역을 잘 해야하고, 우리말 문장도 매끄럽게 작성하도록 온 신경을 기울여야 한다는 점을 깨닫는 계기가 되었습니다.</p>\n<p>사실 번역을 시작해보게 된 계기는 단순합니다. 본 글의 저자인 <a href="http://www.justinweiss.com">Justin Weiss</a>의 블로그 포스팅들이 마음에 들어서 책(Practicing Rails)도 구매하고, 뉴스레터도 구독하면서 최근 뉴스레터의 내용들이 참 도움이 많이 된다고 생각하였습니다. 그래서 메일로 최근에 온 뉴스레터를 한글로 번역하여 공유해도 되겠냐고 물어보았지요.</p>\n<p>그는 조만간 그 뉴스레터를 블로그로 포스팅할 예정이고 그 포스팅이 첫 번째로 공개되는 포스팅이었으면 한다고 답변을 주었습니다. 즉 아직은 올릴 수 없다는 말이겠지요. 메일을 조금 더 주고받다가 저는 그의 좋은 포스팅들 중 첫 번역을 이 글로 시작하기로 협의했습니다.</p>\n<p>차차 Justin의 포스팅 이외에도 괜찮은 글들을 제가 번역할 기회가 주어진다면 조금씩 올려볼 예정입니다. 감사합니다.</p>',
id:"/Users/rinae/Dev/blog/src/pages/posts/2016-12-19-the-easiest-way-to-get-into-open-source-kor/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2016-12-09",path:"/posts/the-easiest-way-to-get-into-open-source-kor",title:"[번역] 오픈 소스에 참여하는 가장 쉬운 방법",tags:["Translation","Rails","OSS"],category:"Translation"}}],tagName:"Translation"}}}});
//# sourceMappingURL=path---tags-translation-21f697eae879958d241c.js.map