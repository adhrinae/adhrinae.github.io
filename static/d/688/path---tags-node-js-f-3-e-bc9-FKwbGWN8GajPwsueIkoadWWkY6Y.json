{"pageContext":{"postsByTag":[{"excerpt":"제가 처음 신입 웹 개발자로 모 회사에 들어갔을 때는 정말 아는게 전혀 없다시피 했습니다. 국비지원 교육과정에서 보낸…","html":"<p><img src=\"https://cl.ly/7aa4bdfc2d2f/node-js-textbook-cover.jpg\" alt=\"Node.js 교과서 표지\"></p>\n<p>제가 처음 신입 웹 개발자로 모 회사에 들어갔을 때는 정말 아는게 전혀 없다시피 했습니다. 국비지원 교육과정에서 보낸 6 개월의 시간을 제대로 활용하지 못했기 때문에(일부는 교육과정 탓을 하고 싶지만 본질적으론 저의 문제였지요) 루비 온 레일즈(이하 레일즈)로 웹 개발을 하기 위해 무엇을 알아야 할지 전혀 감이 잡히지 않았습니다. 루비는 책으로 기본적인 문법을 꾸역꾸역 익혔지만, 이후에 무언가 본격적으로 만들어보려고 문서를 들여다보면 온갖 어려운 용어들이 튀어나왔습니다. 당장은 HTTP 부터 막혔고 RESTful 은 무엇이며, 라우트를 어떻게 구성하는지, XSRF 등등 모르는게 너무 많았습니다. 아마 레일즈가 아닌 다른 웹 프레임워크 기반의 개발을 한다고 해도 똑같이 막혔을겁니다. 개발 뿐 아니라 Git 으로 버전 관리는 어떻게 해야할지도 모르겠고 터미널의 명령어들은 어렵기만 했습니다. 국내에 출간된 레일즈 관련 도서는 너무 오래되어 별로 도움이 되지 않았기 때문에 저는 직접 학습할 자료를 찾을 수 밖에 없었습니다. 그 때 발견한 것이 <a href=\"https://www.railstutorial.org/\">M.Hartl 의 Rails Tutorial(이하 레일즈 튜토리얼)</a> 이었습니다. 지금도 ‘레일즈를 배울 때 가장 좋은 책/튜토리얼이 무엇이냐’ 라는 질문이 올라오면 가장 많은 추천을 받는 책 중에 하나입니다. 레일즈 뿐 아니라 웹 개발 자체를 처음 접하는 사람들을 대상으로 삼은 것으로 보이며 트위터 클론 앱을 만들면서 루비 개발 환경 설정 및 루비의 기초를 익힌 뒤 레일즈로 웹 개발을 할 때 필요한 요소를 차근차근 익혀나갈 수 있는 아주 좋은 책입니다. 왜 노드 책 리뷰를 하는데 전혀 엉뚱한 책을 소개하는지 궁금하실겁니다. 이번에 감상평을 남길 조현영님의 ‘Node.js 교과서’가 이와 견줄만큼 충분히 좋은 내용을 담고 있기 때문입니다.</p>\n<p>제가 리액트 기반 프론트엔드 개발에 역량을 집중해보기로 하고 백엔드 개발과 담을 쌓고 지낸지 1 년이 넘는 시간이 흘렀고, 제 자신도 자바스크립트에는 어느정도 익숙해졌지만 Node.js 를 활용하여 백엔드 개발을 할 일은 거의 없었습니다. 지난번에 Express 를 잠깐 만질 때 기본적인 부분도 파악하지 못한 상태로 코드에 손을 댔다가 문제 해결을 위해 꽤나 고생했었던 기억이 납니다. <a href=\"https://www.zerocho.com/\">Zerocho</a> 라는 닉네임으로 자바스크립트 &#x26; 개발 전반에 걸쳐 유용한 글을 공유하고 계신 조현영님의 Node.js 책이 나온다고 했을 때 제가 아쉽게 느꼈던 노드 사용법에 대한 많은 부분을 익힐 수 있으리라 기대했습니다. 그리고 그 기대는 잘 들어맞았습니다.</p>\n<p>이 책은 제목답게 Node.js 의 기본적인 설명부터 시작하여 개발환경 설정 부터 Express 와 Pug 를 활용한 웹 서비스를 구축하는 과정을 거쳐 마지막에는 배포 및 서버리스에 대한 개념까지 다루고 있는 하나의 ‘교과서’ 입니다. 특히 마음에 들었던 부분은 기초 내용을 다루고 있는 책의 앞부분이었습니다. Node.js 란 무엇인지, 그리고 어떠한 특성을 가지고 있는지 초보 개발자들에게 이벤트 루프와 싱글 스레드 기반 비동기 I/O 를 몇 페이지만에 명쾌하게 설명하는 내용을 보고 감탄했습니다. 시작부터 감탄했지만 이렇게 짧으면서 핵심을 잘 짚은 설명들이 책 전반에 걸쳐 나옵니다. 그래서 핵심을 파악하기에 아주 좋습니다. 초보 개발자들이 어렵사리 여러 책과 웹페이지를 뒤져서 간신히 익혀 정리할 수 있는 내용을 미리니름(스포일러) 하는 느낌이 들 정도입니다. Express 를 본격적으로 다루기 이전까지의 내용이 전반적으로 괜찮았습니다. Node.js API 에 대해서 보통 자세히 살펴보지 않은 채 Express 다루는 것만 찾아보게 되는데 그러다 보면 반드시 막히는 구간이 생기게 됩니다. 하지만 책의 앞부분에서 설명한 API 를 숙지해두면 문제의 지엽적인 부분보다 핵심에 다가가기 훨씬 쉬워지고, 각종 오픈소스 코드도 훨씬 이해하기 수월해집니다. 다만 자바스크립트의 기초를 습득하고 있어야 이 책의 내용을 수월하게 따라갈 수 있습니다. 저는 <a href=\"http://www.hanbit.co.kr/store/books/look.php?p_code=B2328850940\">러닝 자바스크립트</a> 라는 책을 먼저 보시길 추천합니다.</p>\n<p>초반을 넘어가면 모든 백엔드 개발은 Express 를 활용하는데, Express 가 Node.js 진영에서 압도적으로 높은 점유율을 차지하고 있는 프레임워크이기 때문에 별 문제는 없습니다. SQL, NoSQL 을 각각 다루면서 템플릿 엔진으로 Pug 까지 활용하고 있다보니 일반적인 웹 애플리케이션을 다루는데 필요한 내용은 다 다루고 있습니다. 챕터마다 구현에 필요하거나 반드시 알고 있어야 하는 개념들을 간단하고 핵심적인 내용만 잘 추려 설명하고 있기 때문에, 초보 Node.js 개발자라면 이 책에서 익힌 내용을 기반으로 삼아 지식을 점진적으로 확장한다면 별로 무리없이 개발을 할 수 있으리라 생각합니다. 대부분의 예제 코드를 직접 따라 쳐보면서 별로 지루한 내용은 없었습니다. 프론트엔드쪽 코드는 일부러 호환성을 고려해서 조금 옛날 방식으로 작성하긴 했지만 오히려 초심자들에게 기본적인 개념을 잘 심어주기 위한 저자의 고민이 엿보였습니다.</p>\n<p>보통 Node.js 를 다루면서 빠지기 힘든 기술이 웹소켓입니다. 저도 직접 웹소켓으로 뭘 구현해본적은 없었기 때문에 특히 재밌게 해당 챕터의 내용을 따라갈 수 있었습니다. 마냥 다른 서비스를 보면서 신기해하던 채팅 기능은 이런식으로 이루어질 수 있다는데 감탄했고, 의외로 구현하기 어렵지도 않아서 한번 더 놀랐습니다. 프론트엔드 부분에서 최적화 할 요소들은 더 많겠지만 어디까지나 백엔드 위주로 다루는 책이기 때문에 별로 신경쓰이진 않았습니다. 만약에 어딘가 아쉬워서 더 개량을 하는 방식으로 자율학습을 하고 싶으시다면 대부분의 챕터 마지막에 있는 ‘스스로 해보기’ 단락을 살펴보고 도전해보시면 더 큰 학습 효과를 얻으실 수 있습니다.</p>\n<p>약간 아쉬웠던 점은 트위터 클론을 만드는 챕터에서 카카오톡 OAuth 를 적용하였는데, OAuth 를 설명한 부분을 찾지 못했습니다. OAuth 가 무엇이고 왜 이걸 쓰는지 다른 챕터에서 개념을 설명했던 것처럼 충분히 설명할 수 있었으리라 생각합니다. 그리고 노드 버전 관리자(nvm, n)와 Git 설정을 책의 맨 뒷부분에 배포 설정을 하는 챕터에서 다루고 있는 것도 아쉬웠습니다. 앞서 말씀드린 레일즈 튜토리얼과 비교하면서 특히 아쉬웠던 점인데요. 레일즈 튜토리얼은 루비 개발환경 설정을 하면서 자연스럽게 터미널 명령어와 Git 명령어를 익히고, 각 챕터마다 커밋과 푸시를 하는 방법까지 잘 설명이 되어있습니다. 이 책을 보는사람 입장에서 로컬에서 예제 코드만 따라서 쳐 보는 정도를 넘어 실무에 근접한 경험을 습득하고 싶을 수 있는데 이에 대한 고려가 조금 부족했다고 생각합니다. 또한 책에는 Node.js 10 입문서 라고 써있음에도 딱히 이전버전과 비교하여 버전 10 의 어느 부분이 다른지 그 차이를 실감할 수 없었습니다. 아예 새로 접근하는 사람이었다면 별로 신경쓰지 않을 내용이지만, 이미 노드 개발환경을 접한 사람이 개념 다지기를 위해 이 책을 봤을때 혼란스러울 수 있습니다.</p>\n<p>결과적으로 이 책은 웹 개발자로 입문하고자 하는데 막 JS 기초에 익숙해진 사람들에게 한 번쯤은 반드시 읽어볼만한 책이라고 권하고 싶으며, 프론트엔드 개발에만 신경쓰다가 API 서버쪽에서는 무슨 일이 일어나고 있고, 앞으로 자신이 개발을 할 때 어떤 부분을 더 신경써야할지 알고 싶은 주니어 프론트엔드 개발자들에게도 추천합니다. 이외에 Node.js 웹 개발이 익숙한 개발자들이 개념 복습을 하거나, 다른 언어를 오래 했는데 Node.js 를 해야한다고 하면 이 책을 집어서 빠르게 핵심만 살펴보면 바로 감을 잡을 수 있으리라 생각합니다. 오랜만에 정말 즐겁게 본 교과서였습니다.</p>","id":"d295283f-ec40-5381-887b-207b4d6ff7c7","frontmatter":{"date":"2018-08-28","path":"/posts/nodejs-textbook-review","title":"'Node.js 교과서' 감상평","tags":["Reading","Javascript","Node.js"],"category":"Review"}},{"excerpt":"부제: 시행착오를 거쳐 모듈 로딩 순서를 이해하기 Michel Weststrate 의  How to fix nasty circular dependency issues once and for all in JavaScript & TypeScript 를 번역한 글입니다 제가 관리해왔던 많은 프로젝트들은 빠르거나 늦거나 언제나 같은 문제에 부딪혔습니다. 바로 순환 모듈 의존 문제입니다.  (역주: circular module dependency…","html":"<p>부제: 시행착오를 거쳐 모듈 로딩 순서를 이해하기</p>\n<p><strong><a href=\"https://twitter.com/mweststrate\">Michel Weststrate</a>의 <a href=\"https://medium.com/visual-development/how-to-fix-nasty-circular-dependency-issues-once-and-for-all-in-javascript-typescript-a04c987cf0de\">How to fix nasty circular dependency issues once and for all in JavaScript &#x26; TypeScript</a>를 번역한 글입니다</strong></p>\n<hr>\n<p>제가 관리해왔던 많은 프로젝트들은 빠르거나 늦거나 언제나 같은 문제에 부딪혔습니다. 바로 순환 모듈 의존 문제입니다. <em>(역주: circular module dependency 를 순환 참조로 번역하자니 번역이 조금 이상하게 느껴지는데 일반적으로 많이 사용되고 있는 용어임을 감안하여 앞으로 순환 참조라는 용어를 사용하겠습니다. 피드백 환영합니다.)</em> 순환 참조를 피하는 방법을 설명하는 모범 규약이나 전략들이 많이 있지만, 제대로 지속적이고 예측 가능한 방법으로 문제를 해결하는 방법은 거의 없었습니다. 사람들은 보통 ‘어쩌다 갑자기 작동하기를’ 빌면서 <code class=\"language-text\">import</code> 문이나 코드 블록을 이리저리 움직여봅니다. 사실 아래의 트윗을 보면 저만 고통받은건 아닌가 봅니다.</p>\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">&quot;How to fix nasty circular dependency issues for once and for all in javascript / <a href=\"https://twitter.com/typescriptlang?ref_src=twsrc%5Etfw\">@typescriptlang</a>&quot; is on my to-write list for a long time. Would you be interested in / helped by such a blog post?</p>&mdash; Michel Weststrate (@mweststrate) <a href=\"https://twitter.com/mweststrate/status/1018945541424779264?ref_src=twsrc%5Etfw\">July 16, 2018</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script> \n<blockquote class=\"twitter-tweet\" data-conversation=\"none\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">Yes. Yes. Yes.<br><br>...<br><br>Yes.</p>&mdash; Josh Goldberg 😍 (@JoshuaKGoldberg) <a href=\"https://twitter.com/JoshuaKGoldberg/status/1018964066302189568?ref_src=twsrc%5Etfw\">July 16, 2018</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>저는 이 문제를 일관되게 해결하는 방법을 보여드리겠습니다.</p>\n<h2 id=\"예시the-case\"><a href=\"#%EC%98%88%EC%8B%9Cthe-case\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예시(The case)</h2>\n<p>자바스크립트의 모듈 로딩 순서는 결정적(deterministic)입니다. 여전히 거대한 프로젝트에서는 파악하기가 어렵지요. (간접적으로) 순환 참조 문제가 발생하면 여러분의 코드는 반쯤만 불러와진 모듈 때문에 문제가 발생합니다. 이번 예제로 아직 초기화되지 않은 기본 클래스(base class)를 가져오거나 불러온 변수를 읽어들이려 할 때 생기는 문제를 확인하실 수 있습니다.</p>\n<p>가령 자바스크립트 객체 트리를 YAML 형식으로 바꾸어주는 가상의 애플리케이션이 있다고 해 보겠습니다.</p>\n<p><img src=\"https://cl.ly/30233q260824/fix-circular-dependency-1.png\" alt=\"예제 - 객체 트리를 문자열로 예쁘게 출력하기\"></p>\n<p>예제 코드는 <a href=\"https://codesandbox.io/s/7jp0x7lrjq\">codesandbox</a>에서 직접 실험해보실 수 있습니다. 앱의 구현 방식은 직관적입니다. 기본 클래스 <code class=\"language-text\">AbstractNode</code> 가 있고, 그 클래스에는 기본 구현체와 <code class=\"language-text\">parent</code> 나 <code class=\"language-text\">getDepth()</code> 처럼 공통적으로 사용되는 함수를 제공합니다. 그 다음에는 <code class=\"language-text\">Node</code> 와 <code class=\"language-text\">Leaf</code> 라는 세부 구현체들이 있습니다. 지금은 잘 동작하지만 세 개의 클래스를 한 파일에서 관리하는 것은 이상적인 방법이 아닙니다. 그러니 개선한 뒤에 어떻게 되나 살펴보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractNode</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>parent <span class=\"token operator\">=</span> parent\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">getDepth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span><span class=\"token function\">getDepth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token string\">'abstract; not implemented'</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">static</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>thing<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>thing <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> thing <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> thing<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Leaf</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> thing<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractNode</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> thing<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>children <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>thing<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> AbstractNode<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>thing<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token string\">'\\n'</span> <span class=\"token operator\">+</span>\n      Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>\n          key <span class=\"token operator\">=></span>\n            <span class=\"token template-string\"><span class=\"token string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token string\">''</span><span class=\"token punctuation\">.</span><span class=\"token function\">padStart</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getDepth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>\n              key\n            <span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span>\n        <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\n'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Leaf</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractNode</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"문제\"><a href=\"#%EB%AC%B8%EC%A0%9C\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제</h2>\n<p>일단 클래스들을 각자의 파일로 분리하면, 똑같이 작동할거라 생각했던 애플리케이션이 확 죽어버립니다. 에러 메세지는 <code class=\"language-text\">TypeError: Super expression must either be null or a function, not undefined</code> 라고 나옵니다. 너무 모호한 표현이라 문제를 파악할 수 조차 없습니다 ¯_(ツ)_/¯!</p>\n<p><img src=\"https://cl.ly/1r1k010W3W3S/fix-circular-dependency-2.png\" alt=\"순환 참조로 인해 생긴 예외의 예\"></p>\n<p>아래 코드에서 보시다시피 변경점은 거의 없었습니다. (<a href=\"https://codesandbox.io/s/xjyj0ol3mq\">여기</a>에 들어가 보시면 깨진 상태의 샌드박스를 보실 수 있습니다)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// -- AbstractNode.js --</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Leaf <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./Leaf'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Node <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./Node'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractNode</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* 그대로 */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// -- Node.js --</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> AbstractNode <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./Node'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractNode</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* 그대로 */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// -- Leaf.js --</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> AbstractNode <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./AbstractNode'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Leaf</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractNode</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* 그대로 */</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이정도의 변경만 가해도 애플리케이션은 충분히 고장납니다. <code class=\"language-text\">Node</code> 와 <code class=\"language-text\">Leaf</code> 클래스는 <code class=\"language-text\">AbstractNode.js</code> 파일을 모듈로 불러와서 그 클래스의 <code class=\"language-text\">from</code> 스태틱 메서드를 사용하고 있습니다.</p>\n<p>애플리케이션이 동작하지 않는 이유는 <code class=\"language-text\">AbstractNode</code> 를 <code class=\"language-text\">Leaf</code> 클래스에서 불러오려고 할 때 아직 정의되지 않았기 때문입니다. 신기하게도 우리는 <code class=\"language-text\">Leaf</code> 클래스 파일에 <code class=\"language-text\">import</code> 문을 정확히 써 줬는데도 이런 일이 일어났지요. 실제로 모듈이 로드되는 순서는 이렇습니다.</p>\n<p><img src=\"https://cl.ly/233N0X3A321F/fix-circular-dependency-3.png\" alt=\"모듈 로딩 순서가 순환 참조를 일으킬 수 있는 경우\"></p>\n<ol>\n<li><code class=\"language-text\">index.js</code> 는 <code class=\"language-text\">AbstractNode.js</code> 파일을 불러옵니다(require).</li>\n<li>모듈 로더는 <code class=\"language-text\">AbstractNode.js</code> 파일을 불러오기 시작하고 모듈 코드를 실행합니다. 이 파일에서 처음 맞딱드리는 코드는 <code class=\"language-text\">Leaf</code> 를 <code class=\"language-text\">require(import)</code> 하는 구문입니다.</li>\n<li>그래서 모듈 로더는 <code class=\"language-text\">Leaf.js</code> 파일을 불러들이기 시작합니다. 그런데 이 파일도 <code class=\"language-text\">AbstractNode.js</code> 파일을 불러들이는 일부터 시작합니다.</li>\n<li><code class=\"language-text\">AbstractNode.js</code> 는 이미 로드되었기 때문에 모듈 캐쉬에서 즉시 리턴해줍니다. 하지만 이 모듈은 <code class=\"language-text\">Leaf</code> 를 불러오는 첫 번째 줄의 코드가 실행되지 않은 상태이기 때문에 <code class=\"language-text\">AbstractNode</code> 클래스의 구현부는 실행되지 않았습니다!</li>\n<li>그래서 <code class=\"language-text\">Leaf</code> 클래스는 제대로 된 클래스가 아닌 <code class=\"language-text\">undefined</code> 값을 상속합니다. 그리고 위 그림처럼 예외가 터지겠죠. BAAM!</li>\n</ol>\n<h2 id=\"해결-시도-1\"><a href=\"#%ED%95%B4%EA%B2%B0-%EC%8B%9C%EB%8F%84-1\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해결 시도 1</h2>\n<p>이렇게 우리의 순환 참조가 불쾌한 문제를 일으킨다는게 발견되었습니다. 하지만 자세히 들여다보면 원래 어떻게 파일을 불러와야 할 지 결정하는 것은 매우 쉽습니다.</p>\n<ol>\n<li><code class=\"language-text\">AbstractNode</code> 클래스를 먼저 불러온다.</li>\n<li><code class=\"language-text\">Node</code> 와 <code class=\"language-text\">Leaf</code> 클래스를 그 다음에 불러온다.</li>\n</ol>\n<p>그러니까 먼저 <code class=\"language-text\">AbstractNode</code> 클래스를 먼저 불러온 다음 <code class=\"language-text\">Node</code>, <code class=\"language-text\">Leaf</code> 클래스를 불러오면 되겠네요. <code class=\"language-text\">AbstractNode</code> 클래스가 정의될 때 <code class=\"language-text\">Node</code> 와 <code class=\"language-text\">Leaf</code> 클래스는 아직 알려질 필요가 없기 때문에 잘 작동할겁니다. <code class=\"language-text\">AbstractNode.from</code> 가 처음으로 호출 되기 전에 두 클래스가 정의되어 있는 한 문제없이 작동할겁니다. 이렇게 바꿔보죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractNode</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* 그대로 */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Node <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./Node'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Leaf <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./Leaf'</span></code></pre></div>\n<p>이 방법은 몇 가지 문제가 있습니다.</p>\n<p>먼저 못생긴데다 확장하기 어렵습니다. 거대한 코드베이스에 이 방법을 적용한다면 어쩌다 작동할때까지 <code class=\"language-text\">import</code> 문을 이리저리 움직봐야 할 겁니다. 하지만 어디까지나 임시 방편에 불과한게, 조금만 리팩터링을 하거나 <code class=\"language-text\">import</code> 문의 위치를 바꾸게 되면 미묘하게 모듈 로딩 순서가 바뀌어 또 문제가 일어나게 됩니다.</p>\n<p>두 번째로 이 방법은 모듈 번들러에 크게 의존하는 방법입니다. 예를 들어 codesandbox 에서 Parcel 로 앱을 번들링할 때(아니면 Webpack 이나 Rollup), 제대로 <a href=\"https://codesandbox.io/s/7oxxrqwoq6\">작동하지 않습니다</a>. 하지만 로컬 Node.js 환경에서 commonJS 모듈 방식으로 실행하면 잘 동작합니다.</p>\n<h2 id=\"문제를-피하기\"><a href=\"#%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제를 피하기</h2>\n<p>보아하니 이 문제는 쉽게 해결할 수 없어 보입니다. 문제가 발생하지 않도록 할 순 없을까요? 물론 가능합니다. 몇 가지 방법이 있는데, 먼저 모든 코드를 한 파일에 두는 방법이 있습니다. 예시를 소개할 때 처음 파일처럼요. 모듈 초기화 코드가 실행되는 순서를 완전히 제어할 수 있기 때문에 문제가 해결됩니다.</p>\n<p>두 번째로, 어떤 사람들은 \"클래스를 사용해서는 안된다” 또는 \"상속을 사용하지 말라\" 같은 주장을 펼치기 위해 위와 같은 문제를 예시로 사용합니다. 그러나 이런 논의는 문제를 너무 단순하게 바라보는 겁니다. 저도 프로그래머가 상속에 너무 빨리 손을 대는 경향이 있다는데 동의하지만, 어떤 문제의 경우 상속을 통해 코드 구조, 재사용 또는 성능면에서 큰 이득을 얻을 수 있습니다. 하지만 가장 중요한 것은 이 문제가 클래스 상속에만 국한되지 않는다는 것입니다. 모듈 초기화 중에 실행되는 모듈 변수와 함수 사이에 순환 참조가 생기는 등 똑같은 문제가 발생할 수 있습니다!</p>\n<p><code class=\"language-text\">AbstractNode</code> 를 쪼개서 <code class=\"language-text\">Node</code> 와 <code class=\"language-text\">Leaf</code> 를 의존하지 않도록 만들 수도 있습니다. 이 <a href=\"https://codesandbox.io/s/6z2rkvj8v3\">샌드박스</a>에서 <code class=\"language-text\">from</code> 메서드는 <code class=\"language-text\">AbstractNode</code> 클래스로부터 떨어져 별도의 파일로 분리되었습니다. 문제는 해결되었지만 우리의 프로젝트와 API 구조는 달라졌습니다. 거대한 프로젝트에서는 이 방법을 사용하기 매우 어렵거나 불가능할 수도 있습니다! 예를 들어 추가 구현을 하면서 <code class=\"language-text\">Node#print</code> 메서드가 <code class=\"language-text\">Node</code> 나 <code class=\"language-text\">Leaf</code> 에 의존하는 경우가 생길 수도 있겠죠...</p>\n<p><em>보너스:</em> <a href=\"https://github.com/mobxjs/mobx/commit/f75812355d1529f237f7116ad56a199ae5a90252\">제가 이런 이상한 방법도 사용해봤습니다.</a> 함수에서 기본 클래스를 리턴하고, 함수 호이스팅을 활용하여 원하는 순서대로 호출될 수 있도록 만듭니다. 이걸 어떻게 적절하게 설명해야 할지도 모르겠네요.</p>\n<h2 id=\"내부-모듈-패턴internal-module-pattern으로-해결하기\"><a href=\"#%EB%82%B4%EB%B6%80-%EB%AA%A8%EB%93%88-%ED%8C%A8%ED%84%B4internal-module-pattern%EC%9C%BC%EB%A1%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>내부 모듈 패턴(Internal module pattern)으로 해결하기</h2>\n<p>저는 많은 프로젝트에 걸쳐 순환 참조 문제를 여러 번 겪었습니다. 제가 일하고 있는 <a href=\"https://medium.com/@Mendix\">Mendix</a>나, MobX, MobX-state-tree 를 비롯하여 일부 개인 프로젝트까지 포함해서요. 심지어 저는 몇년 전에 <a href=\"https://github.com/mobxjs/mobx/blob/247c443fcf5210dabf4c850a6312e48c5f1d5d3b/scripts/single-file-build.sh#L17-L29\">스크립트를</a> 짜서 모든 소스 파일을 이어붙인 다음 <code class=\"language-text\">import</code> 문을 없애버리는 방법도 써 봤습니다. 모듈 로딩 순서를 잡기 위한 흙수저판(poor man’s) 모듈 번들러였죠.</p>\n<p>하지만 문제를 몇 번 해결하고 나서 하나의 패턴을 발견했습니다. 프로젝트를 재구성하거나 이상한 트릭을 쓰지 않고도 모듈 로딩 순서를 전부 컨트롤할 수 있는 방법이죠! 이 패턴은 제가 확인해본 어느 환경에서나 잘 동작했습니다. (Rollup, Webpack, Parcel, Node)</p>\n<p>이 패턴의 핵심은 <code class=\"language-text\">index.js</code> 와 <code class=\"language-text\">internal.js</code> 파일입니다. 주요 규칙은 이렇습니다.</p>\n<ol>\n<li><code class=\"language-text\">internal.js</code> 모듈은 프로젝트 전체의 로컬 모듈을 불러모은 다음 전부 내보내는 역할을 합니다.</li>\n<li>다른 모듈들은 모두 반드시 <code class=\"language-text\">internal.js</code> 파일만 불러와서 사용합니다. 다른 모듈을 직접적으로 불러오지 않도록 합니다.</li>\n<li><code class=\"language-text\">index.js</code> 파일은 주요 시작점이 됩니다. <code class=\"language-text\">internal.js</code> 파일에서 내보낸 모든 모듈을 불러온 다음, 외부로 노출하고자 하는 것만 내보냅니다. 이 과정은 다른 사람들이 사용할 라이브러리를 배포할 때만 유효한 방법입니다. 따라서 이번 예제에서는 만들지 않고 넘어가겠습니다.</li>\n</ol>\n<p>위의 규칙은 로컬 모듈에만 적용되어야 합니다. 외부 모듈 <code class=\"language-text\">import</code> 는 순환 참조 문제와 전혀 연관이 없기 때문에 그대로 두시면 됩니다. 우리의 데모 애플리케이션에 적용을 해보면 이렇게 바뀔겁니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// -- app.js --</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> AbstractNode <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./internal'</span>\n\n<span class=\"token comment\">/* 그대로 */</span>\n\n<span class=\"token comment\">// -- internal.js --</span>\n<span class=\"token keyword\">export</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./AbstractNode'</span>\n<span class=\"token keyword\">export</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./Node'</span>\n<span class=\"token keyword\">export</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./Leaf'</span>\n\n<span class=\"token comment\">// -- AbstractNode.js --</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Node<span class=\"token punctuation\">,</span> Leaf <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./internal'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractNode</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* 그대로 */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// -- Node.js --</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> AbstractNode <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./internal'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractNode</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* 그대로 */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// -- Leaf.js --</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> AbstractNode <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./internal'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Leaf</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractNode</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* as is */</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 패턴을 처음 적용하면 굉장히 어색하게 느껴지실겁니다. 하지만 익숙해지기만 하면 몇 가지 큰 이득을 얻을 수 있습니다!</p>\n<ol>\n<li>당연하지만 우리가 머리를 싸매던 문제가 해결되었습니다! <a href=\"https://codesandbox.io/s/oqro83jpk6\">여기</a>에 보이는 대로 우리의 앱은 아주 잘 돌아갑니다.</li>\n<li>문제가 해결된 이유는 <em>이제 우리가 모듈 로딩 순서를 완전히 통제할 수 있기 때문입니다</em>. <code class=\"language-text\">internal.js</code> 가 파일을 불러오는 것은 순서에 관계 없이 우리의 모듈 로딩 구조 안에 포함됩니다. (아래쪽의 그림을 참고하시거나 위에 말씀드린 모듈 로딩 순서에 대한 내용을 다시 살펴봐주세요)</li>\n<li>더 이상 <code class=\"language-text\">require(import)</code> 문을 파일의 바닥으로 옮기는 등 우리가 원치 않는 형태의 리팩터링이나 못생긴 트릭을 쓸 필요가 없습니다. 코드베이스의 설계나 API 를 고민할 때 타협할 필요도 없습니다.</li>\n<li><em>보너스</em> : 더 적은 파일을 불러올수록 <code class=\"language-text\">import</code> 구문도 훨씬 적어집니다. 예를 들어 지금 <code class=\"language-text\">AbstractNode.js</code> 는 오로지 하나의 <code class=\"language-text\">import</code> 문만 가지고 있습니다. 그 전에는 두개였지만요.</li>\n<li><em>보너스</em>: <code class=\"language-text\">index.js</code> 를 통해 우리는 <a href=\"https://en.wikipedia.org/wiki/Single_source_of_truth\">유일한 중앙 자료(Single source of truth)</a>를 확보했습니다. 그리고 이를 이용해 외부로 내보내고자 하는 모듈을 조절할 수 있습니다.</li>\n</ol>\n<p><img src=\"https://cl.ly/0E0A3B44270E/fix-circular-dependency-4.png\" alt=\"internal module pattern을 도입하고 나서 모듈 로딩 순서\"></p>\n<h2 id=\"결론\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>지금까지 제가 최근에 순환 참조 문제를 해결하는 방법을 보셨습니다. 기존에 있는 프로젝트에 적용하시려면 <code class=\"language-text\">import</code> 문을 고치기 위한 작업이 좀 필요하실 겁니다. 하지만 이 단순하고 직관적인 방법을 적용하고 난 뒤에, 여러분들은 모듈 로딩 순서를 완전히 통제하고 앞으로도 발생할 수 있는 어떠한 순환 참조 문제도 해결할 수 있습니다. 위의 방법을 적용하기 위한 리팩터링 예시를 몇 개 보여드리자면</p>\n<ul>\n<li><a href=\"https://github.com/mobxjs/mobx/commit/e7f32aa0c2f6295b84270587285ab793b52d8643\">MobX</a> (큰 변경점이었으나 직관적이라 별 문제가 안됨)</li>\n<li><a href=\"https://github.com/mobxjs/mobx-state-tree/commit/5ae34850f026cab88da826ee97d4e0a623f25108\">MobX-state-tree</a> (파일 마지막의 <code class=\"language-text\">import</code> 문이 어떻게 제거되었는지 봐 주세요)</li>\n<li>작은 <a href=\"https://github.com/mweststrate/remmi/commit/ea3db28dde500e6a61aae330b7abfcbcd5740efb\">개인 프로젝트</a></li>\n</ul>\n<p>아직까진 이 패턴을 라이브러리에만 적용해봤고 더 큰 프로젝트에 적용해보진 않았습니다. 하지만 거대한 프로젝트에는 순환 참조 문제가 발생하는 특정 하위 폴더에 패턴을 적용하여 별도의 라이브러리마냥 다룰 수 있을겁니다.</p>\n<p>이 패턴이 잘 적용된다면 저한테도 알려주세요! 그리고 패턴을 좀 더 쉽게 도입하도록 도와주는 도구가 있다면 소개해주세요(힌트라도 좋습니다) :-)</p>","id":"10c972d4-fa91-5cfe-9127-6640ba354cae","frontmatter":{"date":"2018-07-21","path":"/posts/fix-circular-dependency-kr","title":"[번역] 자바스크립트 & 타입스크립트의 순환 참조를 한방에 해결하는 방법","tags":["Translation","Typescript","Javascript","Node.js"],"category":"Typescript"}}],"tagName":"Node.js"}}