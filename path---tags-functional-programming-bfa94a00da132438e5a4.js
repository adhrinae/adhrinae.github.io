webpackJsonp([0xe93be1ca5c12],{472:function(n,s){n.exports={pathContext:{postsByTag:[{excerpt:"책 링크 일단 자바스크립트 초급자가 읽기 좋은 책은 아니다. 하지만 자바스크립트를 좀 다루면서, Redux 나 RxJS 같은 라이브러리를 접해본 사람들이\n'왜 이런 방식으로 코드를 작성해야하는지' 단서를 얻을 수도 있고, 더 나아가서 함수형 프로그래밍의 기본 개념을 자신에게 익숙한 자바스크립트로 익힐 수 있다. 특히…",html:'<p><img src="https://cl.ly/0w3j30140G45/functional-javascript-cover.jpg" alt="Functional Javascript Cover"></p>\n<p><a href="http://aladin.kr/p/rUEvd">책 링크</a></p>\n<p>일단 자바스크립트 초급자가 읽기 좋은 책은 아니다. 하지만 자바스크립트를 좀 다루면서, Redux 나 RxJS 같은 라이브러리를 접해본 사람들이\n\'왜 이런 방식으로 코드를 작성해야하는지\' 단서를 얻을 수도 있고, 더 나아가서 함수형 프로그래밍의 기본 개념을 자신에게 익숙한 자바스크립트로 익힐 수 있다.</p>\n<p>특히 5 장 때문에 이 책을 활용한 단기 스터디를 진행했는데, 확실히 팀원에게 내가 생각하는 함수 분할 및 조합에 대한 생각을 공유하고 이해시키는데 많은 도움이 되었다.</p>\n<p>번역은 자잘한 오타와 바로 이해가 되기 어려운 내용이 일부 있지만, 최근에 본 다른 책의 번역에 비하면 훨씬 나은 편이다.</p>\n<p>개인적으로 국내 저서 \'함수형 자바스크립트 프로그래밍(유인동 저)\' 보다는 이 책을 먼저 추천하고 싶다.\n국내 저서도 충분히 기본적인 내용을 소개하고 직접 유틸리티 함수를 구현해보는 방식의 접근을 취하고 있지만,\n2017 년에 나오는 책이 ES6 문법을 메인으로 채택하고 있지 않는 이유를 모르겠다.\n또한 정말 본질적으로 궁금했던 Functor 와 Monad 의 개념 및 활용법, 그리고 비동기 함수를 다루는 방법에 대해서는 명시적으로 드러내고 있지 않아서 약간 아쉬웠다.</p>\n<p>다행히도 이 책은 아쉬웠던 부분을 어느 정도 다루고 있기 때문에 나처럼 국내 저서에 그닥 만족스럽지 못했던 사람에게는 그래도 조금 더 나은 책이 될 것이다.</p>\n<hr>\n<p>(2018–03–22 추가) 국내 저서 ‘함수형 자바스크립트 프로그래밍’ 의 저자 유인동님이 지금 읽고 계시는 리뷰에 대해  <a href="http://bit.ly/2HYKHC4">답변을 달아주셨습니다</a>. 꼭 읽어보시길 권합니다. 또한 인동님이 최근에 <a href="https://github.com/Functional-JavaScript/functional.es">Github 에 ES6 에 초점을 맞춘 내용으로 다른 글을 작성하고 계시니</a>  참고하시면 많은 도움이 되리라 생각합니다.</p>',id:"/home/circleci/repo/src/pages/posts/2018-03-14-functional-javascript-review/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2018-03-14",path:"/posts/functional-javascript-review",title:"함수형 자바스크립트(루이스 아텐시오 저) 리뷰",tags:["Functional Programming","Javascript"],category:"Javascript"}},{excerpt:"이 포스트는  Nicholas Kariniemi 의  Fear, trust and JavaScript: When types and functional programming fail…",html:'<ul>\n<li>이 포스트는 <a href="https://twitter.com/nkariniemi">Nicholas Kariniemi</a>의 <a href="https://www.reaktor.com/blog/fear-trust-and-javascript/">Fear, trust and JavaScript: When types and functional programming fail</a>를 번역한 글입니다</li>\n<li>번역에 관한 피드백과 내용에 관한 토론은 환영합니다. 댓글로 남겨주세요 :)</li>\n</ul>\n<hr>\n<p><img src="https://www.reaktor.com/wp-content/uploads/2018/02/reaktor-javascript-reaktor-hero-2800x0-c-default.png"></p>\n<p>개발자로서 우리는 코드 실패에 대한 두려움을 줄이고 코드가 잘 작동한다는 믿음을 더 높이고 싶을 겁니다. 자바스크립트를 사용하는 많은 개발자는 함수형 프로그래밍 및 강타입(Strongly-typed) 언어에서 유용한 아이디어를 빌려 개발자의 도구와 코드로 신뢰를 얻으면서 두려움을 줄입니다. 선택적 타입과, 함수를 통한 변환 및 불변성과 같은 아이디어는 모두 더 나은 자바스크립트 코드 작성에 도움이 될 수 있습니다. 그러나 이러한 아이디어를 자바스크립트로 가져올 때 상충하는 개념 때문에 제대로 맞물려 작동하지 않으며, 궁극적으로 ‘개발자가 코드와 도구로 (코드가 잘 작동한다는) 믿음을 표현한다’는 목표를 달성하지 못합니다.</p>\n<p>이 아이디어를 설명하기 위해 자바스크립트에서 데이터를 처리하는 방법을 두 가지 관점에서 살펴보겠습니다. 하나는 데이터의 모양을 이해하는 것이고, 나머지 하나는 데이터를 변경하는 것입니다.</p>\n<h2 id="데이터의-형태와-두려움"><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%ED%98%95%ED%83%9C%EC%99%80-%EB%91%90%EB%A0%A4%EC%9B%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>데이터의 형태와 두려움</h2>\n<p>자바스크립트같은 동적 언어에서는 데이터가 어떤 모양을 가지고 있는지 알기 어렵습니다. 기본적인 접근 방식은 규약(convention)에 의지하는 겁니다. 다른 개발자나 다른 시스템이 서로 동의한 형식으로 올바른 데이터를 제공하고 코드 내의 특정 규범을 따른다고 믿어야 합니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token function">fetchUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>user <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// user를 가져오는데 성공!</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 그 이후</span>\n<span class="token function">render</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// user는 name이 있을 거야</span></code></pre>\n      </div>\n<p>저는 이 방식을 “내가 원하는 것인 척” 하는 접근 방식이라고 말하고 싶습니다. 상호 신뢰가 높은 환경에서는 이 방법이 충분히 유효합니다.</p>\n<p>하지만 실제로는 여기저기 두려움이 가득 차 있습니다. 코드가 복잡해지면서 여러분은 서로 다른 규칙을 따르는 개발자의 코드와 씨름합니다. 잘못된 형식으로 날아오지만 현재 계층에서는 손댈 수 없는 데이터를 수신하며, 널 포인터(null pointer) 오류가 발생하기 시작합니다. 코드에 대한 신뢰가 깨지고 데이터에 대한 의문을 가질 때 자신감보다는 불안감이 일어나기 시작합니다.</p>\n<ul>\n<li>이 데이터가 정말 가지고 있는 값이 뭐지?</li>\n<li>이 값을 지우면 어디 다른데서 터지지 않을까?</li>\n<li>이 데이터를 저 함수에다 넘겨도 될까?</li>\n</ul>\n<p>위의 두려움을 이런 방식의 코드 베이스에서 발견할 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token function">fetchUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>user <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// user를 가져오는데 성공!</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>user <span class="token operator">||</span> <span class="token operator">!</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">\'뭐 임마\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 그 이후</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">&amp;&amp;</span> user<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>\'자기 자신의 코드가 더 이상 기대되는 데이터를 적절하게 전달해주지 못한다’며 믿음을 잃을 때 이렇게 방어적인 프로그래밍을 하게 됩니다. 여러분의 아름다운 코드는 방어적인 체크 때문에 어수선해지고, 가독성을 잃으며, 유지보수하기 어려워집니다. 두려움이 커지면서 점점 코드가 제대로 동작하는지 믿기 어려워집니다.</p>\n<h3 id="선택적-타입optional-types으로-빡세게-확인하는-척하기"><a href="#%EC%84%A0%ED%83%9D%EC%A0%81-%ED%83%80%EC%9E%85optional-types%EC%9C%BC%EB%A1%9C-%EB%B9%A1%EC%84%B8%EA%B2%8C-%ED%99%95%EC%9D%B8%ED%95%98%EB%8A%94-%EC%B2%99%ED%95%98%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>선택적 타입(Optional types)으로 빡세게 확인하는 척하기</h3>\n<p>두려움을 사전에 차단하는 방법 중 하나는 <a href="https://www.typescriptlang.org">Typescript</a>나 <a href="https://flow.org">Flow</a>의 선택적 타입을 도입하는 겁니다. 사용자를 수신할 때 <code class="language-text">User</code> 타입을 사전에 선언해두고, 이후에 <code class="language-text">User</code> 객체로 다루는 방식입니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>\n  id<span class="token punctuation">:</span> <span class="token builtin">number</span>\n  name<span class="token punctuation">:</span> <span class="token builtin">string</span>\n  email<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">fetchUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>user<span class="token punctuation">:</span> User<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// User를 가져오는데 성공!</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 그 이후</span>\n<span class="token function">render</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 컴파일러가 이 객체는 name 속성이 있다고 보증함</span></code></pre>\n      </div>\n<p>이는 정말 ‘빡세게 확인하는 척’ 하는 겁니다. 당신은 코드에 대한 신뢰를 확인하는 부분을 바꿔 놓았습니다. 여전히 다른 시스템이 올바른 모양의 데이터를 제공한다고 믿지만, 코드 안에서 데이터에 부여한 타입을 믿고 해당 데이터를 잘못 사용하면 컴파일러에서 오류가 나게 됩니다. 개발자가 데이터의 모양을 알고 적절하게 사용하는 것을 믿는 대신 개발자가 올바른 타입을 작성하고 관리하리라 믿고, ‘컴파일러가 해당 형식에 대해 거짓말을 하지 않는다’고 믿게 되었습니다. 이 이야기는 나중에 더 하겠습니다.</p>\n<p>위의 예제에 타입을 추가해도 근본적인 문제는 해결되지 않습니다. 데이터가 일관성있게 사용되도록 보장함으로써 코드의 신뢰도는 향상되었지만 외부로부터 받은 데이터에 대해서는 아무런 말을 하지 않습니다.</p>\n<h3 id="유효성-검사-믿지만-검사는-해볼게"><a href="#%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC-%EB%AF%BF%EC%A7%80%EB%A7%8C-%EA%B2%80%EC%82%AC%EB%8A%94-%ED%95%B4%EB%B3%BC%EA%B2%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>유효성 검사: 믿지만 검사는 해볼게</h3>\n<p>신뢰도가 낮은 환경에서는 여러 지점에서 데이터의 유효성 검사를 해야 할 수도 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token function">fetchUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>user <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> validationErrors <span class="token operator">=</span> <span class="token function">validate</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>validationErrors<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">\'뭐 임마\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// user를 가져오는데 성공!</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 그 이후</span>\n<span class="token function">render</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// user는 이름이 있다</span></code></pre>\n      </div>\n<p>유효성 검사를 직접 작성할 수도 있지만 임시 방편에다 다루기도 어렵고 오류가 나기도 쉽습니다. 아니면 <a href="http://json-schema.org">JSON schema</a> 정의를 작성해서 데이터가 스키마에 맞는지 확인하거나, <a href="https://github.com/epoberezkin/ajv">ajv</a>같은 도구로 유효성 검사를 할 수도 있습니다. 이렇게 하면 임시 방편처럼 보이지도 않고 문서화 등을 할 때 유용하게 쓸 수 있겠지만, 여전히 여러분이 이렇게 직접 스키마를 작성해야 하기 때문에 오류가 날 가능성이 있으며 번거로운 작업이 될 수 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>\n  <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"User"</span><span class="token punctuation">,</span>\n  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"object"</span><span class="token punctuation">,</span>\n  <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"integer"</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"string"</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token property">"age"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"integer"</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token property">"required"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<h3 id="선택적-타입--유효성-검사"><a href="#%EC%84%A0%ED%83%9D%EC%A0%81-%ED%83%80%EC%9E%85--%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>선택적 타입 + 유효성 검사</h3>\n<p>아니면 타입과 유효성 검사를 함께 사용할 수도 있습니다. 타입을 이용해서 코드 속의 두려움을 걷어내고, 유효성 검사를 통해서 외부로부터 들어오는 데이터를 믿을 수 있게 됩니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-ts"><code class="language-ts"><span class="token keyword">interface</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>\n  id<span class="token punctuation">:</span> <span class="token builtin">number</span>\n  name<span class="token punctuation">:</span> <span class="token builtin">string</span>\n  email<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">fetchUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>user<span class="token punctuation">:</span> User<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> validationErrors <span class="token operator">=</span> <span class="token function">validate</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>validationErrors<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">\'뭠마 난 널 믿었는데\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// User를 가져오는데 성공!</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 그 이후</span>\n<span class="token function">render</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 컴파일러가 이 객체는 name 속성이 있다고 보증함</span></code></pre>\n      </div>\n<p>선택적 타입과 유효성 검사에 같은 정의를 하는 번거로운 작업을 피하기 위해서 Typescript 와 Flow 컴파일러를 직접 라이브러리로서 사용하거나(역주: 어떻게 하는지 방법은 모르겠습니다), <a href="https://github.com/pelotom/runtypes">runtypes(TS)</a>, <a href="https://github.com/seanhess/runtime-types">runtime-types(Flow)</a>, <a href="https://github.com/YousefED/typescript-json-schema">typescript-json-schema(TS)</a> 같은 별도의 라이브러리를 사용할 수도 있습니다. 몇 개의 장애물을 넘고 나면 여러분의 데이터를 더 믿을 수 있게 됩니다. 하지만 더 깊은 곳에 깔린 문제가 있습니다. 조금 뒤에 살펴보겠습니다.</p>\n<h2 id="데이터-변경의-두려움"><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%80%EA%B2%BD%EC%9D%98-%EB%91%90%EB%A0%A4%EC%9B%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>데이터 변경의 두려움</h2>\n<p>데이터가 바뀔 때는 어떨까요? 기본적으로 자바스크립트에서 데이터는 아무렇게나(willy-nilly) 바뀔 수 있습니다. 예를 들어 여기 문서를 받는 함수가 있는데 이 함수는 문서의 필드를 적절하게 손보고 새 필드를 삽입합니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">formatDocument</span><span class="token punctuation">(</span>doc<span class="token punctuation">,</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>doc<span class="token punctuation">.</span>creationDate<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    doc<span class="token punctuation">.</span>creationDate <span class="token operator">=</span> <span class="token function">convertTimeToUtc</span><span class="token punctuation">(</span>doc<span class="token punctuation">.</span>creationDate<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    doc<span class="token punctuation">.</span>creationDate <span class="token operator">=</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span>\n  doc<span class="token punctuation">.</span>source <span class="token operator">=</span> source\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>이런 스타일의 코드는 따라가기도 어렵고 곳곳에 두려움이 도사리고 있습니다. 내 데이터가 다른데서 사용된다면? 이미 다른 곳에서 변경되었다면? 이 시점에서 내 데이터가 가지고 있어야 하는 값이 뭐더라? 내가 지금 가지고 있는 데이터와 내가 실제 사용할 때의 데이터가 어떻게 같은 데이터라고 믿을 수 있지? 위의 예는 아주 작은 부분에 불과하지만 높은 동시성이 요구되는 시스템이나 커다란 코드 베이스에서는 훨씬 큰 문제를 야기할 겁니다.</p>\n<p>선택적 타입을 사용해보지만 별로 도움은 되지 않습니다. Typescript 와 Flow 에서 아래 두 함수는 같은 타입을 가리킵니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">formatDocument</span><span class="token punctuation">(</span>doc<span class="token punctuation">:</span> Document<span class="token punctuation">,</span> source<span class="token punctuation">:</span> String<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>doc<span class="token punctuation">.</span>creationDate<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    doc<span class="token punctuation">.</span>creationDate <span class="token operator">=</span> <span class="token function">convertTimeToUtc</span><span class="token punctuation">(</span>doc<span class="token punctuation">.</span>creationDate<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    doc<span class="token punctuation">.</span>creationDate <span class="token operator">=</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span>\n  doc<span class="token punctuation">.</span>source <span class="token operator">=</span> source\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="language-flow"><code class="language-flow"><span class="token keyword">function</span> <span class="token function">formatDocument</span><span class="token punctuation">(</span>doc<span class="token punctuation">:</span> Document<span class="token punctuation">,</span> source<span class="token punctuation">:</span> <span class="token type tag">String</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token type tag">void</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>doc<span class="token punctuation">.</span>creationDate<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    doc<span class="token punctuation">.</span>creationDate <span class="token operator">=</span> <span class="token function">convertTimeToUtc</span><span class="token punctuation">(</span>doc<span class="token punctuation">.</span>creationDate<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    doc<span class="token punctuation">.</span>creationDate <span class="token operator">=</span> <span class="token type tag">null</span>\n  <span class="token punctuation">}</span>\n  doc<span class="token punctuation">.</span>source <span class="token operator">=</span> source\n  child_process<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"sudo rm -rf /"</span><span class="token punctuation">)</span>\n  <span class="token function">launchRocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>이 중 하나는 여러분이 원하는 기능을 수행하지만 나머지 하나는 서비스를 불바다로 만들어버릴 겁니다. 타입 시스템을 통해 바라보면 이 함수는 아무것도 안하는 것이나 마찬가지입니다(역주: 리턴 값이 <code class="language-text">void</code> 라서 그럴까요?).</p>\n<h3 id="불변성을-가장한-규약"><a href="#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EA%B0%80%EC%9E%A5%ED%95%9C-%EA%B7%9C%EC%95%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>불변성을 가장한 규약</h3>\n<p>이제 여러분은 자바스크립트를 더 잘 다룰 수 있고, 팀 안에서 합의를 이루어서 명시적이고(explicit) 묵시적(implicit)으로 불변성을 가지도록 코드를 작성하기 시작합니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">formatDocument</span><span class="token punctuation">(</span>doc<span class="token punctuation">,</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    creationDate<span class="token punctuation">:</span> <span class="token function">sanitizeDate</span><span class="token punctuation">(</span>doc<span class="token punctuation">.</span>creationDate<span class="token punctuation">)</span><span class="token punctuation">,</span>\n    source<span class="token punctuation">:</span> source<span class="token punctuation">,</span>\n    text<span class="token punctuation">:</span> doc<span class="token punctuation">.</span>text\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 데이터 변경하지 않기</span>\n  <span class="token comment">// 루트 폴더 지우지 않기</span>\n  <span class="token comment">// 로켓 쏘지 않기</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">sanitizeDate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> date <span class="token operator">?</span> <span class="token function">convertTimeToUtc</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>점점 <code class="language-text">var</code> 보단 <code class="language-text">const</code> 를 선호하며 값을 직접 변경하기 보다 새로운 값을 리턴하도록 만들기 시작합니다. <code class="language-text">let</code> 은 변경될 수 있는 값을 가리킬 때만 사용하고, 더 짧은 코드를 작성하기 위해 삼항연산자(ternary operator)를 사용하여 <code class="language-text">if</code> 문을 기능적으로 대체할 수 있다는 사실을 새로이 발견했습니다. <code class="language-text">map</code>, <code class="language-text">filter</code>, <code class="language-text">reduce</code> 나 다른 함수를 사용하여 기존의 데이터를 직접 변경하지 않는 새로운 자료구조를 사용하기도 합니다.</p>\n<p>규약에 다른 불변성은 편리하고 자연스러운 자바스크립트 코드를 만들어냅니다. 그리고 자바스크립트 에코시스템과도 잘 맞아떨어집니다. 하지만 이 방식은 개발자의 신뢰와 훈련(discipline)에 크게 의존합니다. 여러분은 객체의 직접 변경을 피하고 어디서 변경이 일어나는지 정확히 표현하는 등의 규약을 개발자들이 잘 따른다고 믿어야 합니다. 이쯤 오면 더 강한 규약이 필요하다 생각하게 됩니다.</p>\n<h3 id="라이브러리를-사용해서-빡세게-강제하는-척-하기"><a href="#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%EB%B9%A1%EC%84%B8%EA%B2%8C-%EA%B0%95%EC%A0%9C%ED%95%98%EB%8A%94-%EC%B2%99-%ED%95%98%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>라이브러리를 사용해서 빡세게 강제하는 척 하기</h3>\n<p>여러분은 데이터 변경이나 불변 자료구조를 위해 라이브러리를 도입해서 오롯이 개발자만 믿어야 하는 부분 일부를 도구 사용에 대한 믿음으로 옮겨올 수 있습니다. 광범위하게 <a href="http://ramdajs.com">Ramda</a>같은 ‘함수형 올인원 팩’ 같은 라이브러리를 도입할 수도 있고 <a href="https://github.com/calmm-js/partial.lenses">partial.lenses</a>, <a href="https://github.com/gcanti/monocle-ts">monocle-ts</a> 같은 렌즈 라이브러리를 도입할 수도 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> <span class="token constant">R</span> <span class="token keyword">from</span> <span class="token string">\'ramda\'</span>\n<span class="token keyword">function</span> <span class="token function">formatDocument</span><span class="token punctuation">(</span>doc<span class="token punctuation">,</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> creationDate <span class="token operator">=</span> <span class="token function">sanitizeDate</span><span class="token punctuation">(</span>creationDate<span class="token punctuation">)</span>\n  <span class="token comment">// 새 데이터를 만들어 반환한다</span>\n  <span class="token keyword">return</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>doc<span class="token punctuation">,</span> <span class="token punctuation">{</span> creationDate<span class="token punctuation">,</span> source <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>이런 종류의 라이브러리의 기본 개념 중 하나는 사용하는 데이터를 마치 불변 데이터인 것 처럼 다룬다는 겁니다. 실제로는 그렇지 않은데도요. <a href="http://ramdajs.com/docs/#assoc">Ramda 는 얕은 복사(shallow clone)만 합니다.</a> 하지만 불변 데이터에 대한 규약이 충분히 강력하다면 모두들 ‘불변 데이터인 척’ 다루게 됩니다. 약간 퍼포먼스 손해를 보긴 하겠지만 일정 수준의 코드 신뢰도는 얻었습니다. 라이브러리를 광범위하게 사용하고 규약이 잘 잡혀있으면 최상의 효과를 발휘하겠지요.</p>\n<p>진정한 불변성을 강제하고 데이터 변경 시 퍼포먼스 손해를 최소화하려면 <a href="https://github.com/facebook/immutable-js">Immutable.js</a>, <a href="https://github.com/rtfeldman/seamless-immutable">seamless-immutable</a>, <a href="http://swannodette.github.io/mori/">Mori</a> 같은 불변 자료구조를 활용할 수도 있습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> <span class="token constant">I</span> <span class="token keyword">from</span> <span class="token string">\'immutablejs\'</span>\n<span class="token keyword">function</span> <span class="token function">formatDocument</span><span class="token punctuation">(</span>doc<span class="token punctuation">,</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> creationDate <span class="token operator">=</span> <span class="token function">sanitizeDate</span><span class="token punctuation">(</span>creationDate<span class="token punctuation">)</span>\n  <span class="token comment">// doc은 직접 수정할 수 없다</span>\n  <span class="token keyword">return</span> doc<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">{</span> creationDate<span class="token punctuation">,</span> source <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>이렇게 하면 데이터를 직접 변경할 수 없게 되며 외부로 드러난 인터페이스로만 변경할 수 있게 됩니다. 하지만 라이브러리에서 제공하는 특정 자료구조에서만 적용되는 데이터에만 한정됩니다. 대부분의 자바스크립트 코드는 기본적인 자바스크립트 자료구조에 의존하기 때문에, 결국에는 이리저리 데이터를 변환하게 되고(역주: ImmutableJS 의 <code class="language-text">toJS</code> 를 떠올려보세요) 기본적인 자료구조를 사용할 때마다 기껏 확보한 믿음을 잃어버리게 됩니다.</p>\n<p>규약을 거는 것과 불변 자료구조를 강제하는 방법 모두 한계가 있지만, 제일 큰 문제는 선택적 타입 시스템과 잘 맞지 않는다는 겁니다.</p>\n<h2 id="자바스크립트를-믿기"><a href="#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EB%AF%BF%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>자바스크립트를 믿기</h2>\n<p>앞서 소개한 예시들은 선택적 타입, 함수를 통한 변형, 불변 데이터 등 더 효과적인 자바스크립트를 작성하기 위한 도구를 꺼내 본 것입니다. 하지만 자바스크립트를 쓰면서 이런 도구들을 도입 할 때 여러가지 한계점이 있으며, 같이 사용하기도 어렵습니다.</p>\n<h3 id="선택적-타입은-잘못된-보안-의식을-제공한다"><a href="#%EC%84%A0%ED%83%9D%EC%A0%81-%ED%83%80%EC%9E%85%EC%9D%80-%EC%9E%98%EB%AA%BB%EB%90%9C-%EB%B3%B4%EC%95%88-%EC%9D%98%EC%8B%9D%EC%9D%84-%EC%A0%9C%EA%B3%B5%ED%95%9C%EB%8B%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>선택적 타입은 잘못된 보안 의식을 제공한다</h3>\n<p>선택적 타입은 말 그대로 자바스크립트에 선택적으로 도입할 수 있도록 설계되었습니다. 말인즉슨 모든 요소가 타입으로 정의된게 아니기 때문에 모두 유효한 타입을 가지고 있다고 믿는게 불가능합니다. Flow 는 타입이 불분명하며(unsound) Typescript 는 <a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html">의도적으로 불분명하게(deliberately unsound)</a> 사용할 수 있습니다. 불분명하다는 의미는 여러 상황에서 타입이 타입이 맞지 않는데도 컴파일러가 알아채지 못하는 것을 뜻합니다.</p>\n<p>자바스크립트에서 선택적 타입을 사용 할 때 다른 이유로 맞지 않는 경우도 있습니다. 자바스크립트로 작성된 것들 중 일부는 Typescript 나 Flow 로 타입을 정의하기 어렵거나 심지어 불가능하기도 합니다.</p>\n<ul>\n<li>\n<p>고차 함수들</p>\n<ul>\n<li>Ramda 의 <a href="http://ramdajs.com/docs/#call"><code class="language-text">call</code></a>, <a href="http://ramdajs.com/docs/#compose"><code class="language-text">compose</code></a>, <a href="http://ramdajs.com/docs/#chain"><code class="language-text">chain</code></a>, <a href="http://ramdajs.com/docs/#lift"><code class="language-text">lift</code></a>, <a href="http://ramdajs.com/docs/#lens"><code class="language-text">lense</code></a> 계열 함수들</li>\n<li>partial.lenses 의 <a href="https://github.com/calmm-js/partial.lenses/issues/55">함수들</a></li>\n</ul>\n</li>\n<li>\n<p>동적 함수들</p>\n<ul>\n<li>Ramda 의 <a href="http://ramdajs.com/docs/#invert"><code class="language-text">invert</code></a>, <a href="http://ramdajs.com/docs/#dissoc"><code class="language-text">dissoc</code></a>, <a href="http://ramdajs.com/docs/#mergeWith"><code class="language-text">mergeWith</code></a></li>\n<li>ImmutableJS 의 <a href="https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts">거의 대부분의 함수</a></li>\n</ul>\n</li>\n<li>\n<p>몽키패칭</p>\n<ul>\n<li>AWS SDK 클라이언트의 <a href="https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/using-promises.html#w2ab1c17c15c14c17">Promise</a></li>\n<li>Bluebird 의 <a href="http://bluebirdjs.com/docs/api/promisification.html">프로미스화 API 들</a></li>\n</ul>\n</li>\n<li>\n<p>아주 동적인 자료구조</p>\n<ul>\n<li>ElasticSearch <a href="https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-get">스키마</a></li>\n<li>winston <a href="https://github.com/winstonjs/winston#creating-your-own-logger">커스텀 로거</a></li>\n</ul>\n</li>\n</ul>\n<p>위의 것들을 Typescript 나 Flow 로 타입을 매기려면 여러분들은 아래 요소들 중 한개 이상은 희생해야 합니다.</p>\n<ol>\n<li><strong>타입을 쓰는 이유인 ‘타입 안정성’ 을 희생한다:</strong> <code class="language-text">any</code> 타입을 매겨서 모든 값을 허용하고 타입 체커가 <code class="language-text">any</code> 가 들어가는 경로에 있는 값을 확인하지 않게 만듭니다.</li>\n<li><strong>재사용성을 희생한다:</strong> 더 특정하고 정확한 타입을 제공하는 대신 함수의 재사용성을 낮춥니다.</li>\n<li><strong>다른 개발자의 시간을 희생한다:</strong> 함수를 사용하는 사람들에게 정확한 타입을 제공하도록 만듭니다. 예를 들자면 이렇게요.</li>\n</ol>\n<div class="gatsby-highlight">\n      <pre class="language-typescript"><code class="language-typescript"><span class="token constant">R</span><span class="token punctuation">.</span>pipe<span class="token operator">&lt;</span>User<span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>선택지에 따라 라이브러리를 추가할 때 들쭉날쭉한 정확도를 가진 타입 정의도 함께 추가하게 됩니다. 이 때 라이브러리의 개발자를 향한 믿음 일부를 라이브러리의 ‘타입 정의’를 한 개발자에 대한 믿음으로 옮겨가게 됩니다. 대부분 이런 라이브러리는 <code class="language-text">any</code> 타입 정의를 포함하고 있고, 이렇게 정의 된 함수를 호출하면 자기도 모르는 새 맞지 않는 타입을 믿는다고 말하는 것이나 다름없습니다. 게다가 Flow 는 <code class="language-text">@flow</code> 어노테이션이 들어있지 않은 파일을 조용히 무시합니다.</p>\n<p>암시적이고 명시적으로 <code class="language-text">any</code> 타입을 허용하지 않도록 하면서, 타입 정의를 광범위하게 적용하고 타입 정의가 없는 파일은 린터가 오류를 뿜어내도록 설정하여 타입 신뢰성 문제를 해결할 수도 있습니다.</p>\n<p>하지만 이는 물이 새는 배의 구멍을 막는 것이나 마찬가지입니다. 진짜 문제는 여러분이 구축한 시스템의 타입 시스템을 믿지 못하는 것이 아니라 <strong>타입 시스템을 믿을 수 있다고 생각하는 겁니다.</strong> 타입에 기대어 뭔가 변화가 일어날 때 어디가 잘못되었는지 알려주도록 만들어보려 하지만, <code class="language-text">any</code> 타입 때문에 조용히 지나가거나, 라이브러리 사용 방법 혹은 타입의 정확성 문제 때문에 제대로 이루어지지 못합니다. 자바스크립트에 타입을 적용하는 것은 다른 언어에 적용되어있는 타입과는 다릅니다. 똑같은 수준의 신뢰를 기대할 수 없다는 뜻입니다.</p>\n<p><img src="https://www.reaktor.com/wp-content/uploads/2018/01/types_and_js2-768x883.png"></p>\n<p>궁극적으로 여러분이 정의한 타입의 강점은 타입을 적용하는 팀의 지식 수준과 신념에 달려 있습니다. 팀이 타입에 대해 높은 수준의 믿음과 지식을 보유하고 있다면, 시스템에 대해 높은 신뢰를 이끌어낼 수 있습니다. 그러나 일정 수준의 신뢰도를 유지하기 위한 팀의 관심과 규율에 의존해야 하며, 두려움은 여러 가지 형태로 그 믿음을 망칠 수 있습니다.</p>\n<h3 id="함수형-프로그래밍-타입-자바스크립트---이-중-두개를-고르세요"><a href="#%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%83%80%EC%9E%85-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8---%EC%9D%B4-%EC%A4%91-%EB%91%90%EA%B0%9C%EB%A5%BC-%EA%B3%A0%EB%A5%B4%EC%84%B8%EC%9A%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>함수형 프로그래밍, 타입, 자바스크립트 - 이 중 두개를 고르세요</h3>\n<p>선택적 타입과 <code class="language-text">map</code>, <code class="language-text">filter</code>, <code class="language-text">reduce</code> 를 활용한 기본적인 함수형 프로그래밍은 자바스크립트와 잘 작동합니다. 하지만 더 깊이 들어가려 하면 문제에 봉착하게 됩니다. 두 가지 예를 보여드리죠.</p>\n<p><a href="https://github.com/facebook/immutable-js">ImmutableJS</a>는 자바스크립트를 위한 영속적인 불변 자료구조 라이브러리입니다. 이 라이브러리는 내부 데이터 수정에 의존하지 않는 공용 자료구조를 제공합니다. <a href="https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts">Typescript</a>와 <a href="https://github.com/facebook/immutable-js/blob/master/type-definitions/immutable.js.flow">Flow</a>를 위한 타입 정의도 포함되어 있습니다만 한번 살펴보시면 타입 체킹을 무효화하는 <code class="language-text">any</code> 타입이 한가득 들어있습니다. 게다가 어떤 타입은 사용자가 정확한 타입을 제공하도록 책임을 떠넘기기도 합니다. 결과적으로 라이브러리를 사용할 때마다 타입을 도입하지 않을 수도 있고 타입을 도입하기 위해 추가적인 노력을 들일 수도 있습니다. 그러다보면 함수형 프로그래밍을 도입하기 어려워집니다.</p>\n<p>Ramda 는 자바스크립트를 위한 함수형 유틸리티 라이브러리입니다. 타입 정의는 <a href="https://github.com/types/npm-ramda#status">여기</a>에서 보실 수 있는데, 아래의 코멘트와 함께 제공됩니다. (중요한 부분은 강조했습니다)</p>\n<blockquote>\n<p>유의사항: Ramda 의 많은 함수들은 주로 부분 함수(partial application), 커링(currying), 조합(composition)을 중심으로 하는 문제들 때문에 정확한 타입을 제공하기 어렵습니다. 특히 제네릭이 있을 때 그렇습니다. <strong>그리고 네, 아마 여러분들이 Ramda 를 처음 사용하고자 했던 이유는 이런 기능을 사용하기 위해서겠지요.</strong> 특히 타입스크립트로 Ramda 의 타입을 적용하고자 할 때 문제가 됩니다. TS 에 관련 된 몇가지 이슈는 아래의 링크에서 확인하실 수 있습니다(역주: 링크가 실제 원하는 곳으로 연결되지 않아서 배제했습니다)</p>\n</blockquote>\n<p><a href="https://github.com/gcanti">Giulio Canti</a>같은 분의 엄청난 작업에도 불구하고, 매번 조금이라도 불변 자료구조나 함수 합성, 커링같은 고급 함수형 프로그래밍 기법을 도입하려고 하면 타입 체커를 비활성화하거나 타입이 제대로 동작하도록 만들기 위해 추가로 노력을 들여야 합니다. 여전히 함수형 프로그래밍을 도입하기 어렵게 만드는 요소입니다.</p>\n<h3 id="왜-우리는-자바스크립트로-고급진-개념을-사용할-수-없는가"><a href="#%EC%99%9C-%EC%9A%B0%EB%A6%AC%EB%8A%94-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EA%B3%A0%EA%B8%89%EC%A7%84-%EA%B0%9C%EB%85%90%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%97%86%EB%8A%94%EA%B0%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>왜 우리는 자바스크립트로 고급진 개념을 사용할 수 없는가</h3>\n<p>불변성은 코드에 골고루 사용될 때 가장 유용합니다. 하지만 자바스크립트라는 언어와 에코시스템 자체가 데이터를 변경하도록 설계되어있고, <a href="http://tagide.com/blog/research/constraints/">라이브러리 수준에서 불변성을 강제할 수 없습니다.</a> 또한 선택적 타입을 도입한다 한들 라이브러리로 불변성을 다룰 때 표현력이 떨어집니다.</p>\n<p>타입도 마찬가지로 골고루 사용될 때 최고의 효과를 발휘합니다. 하지만 자바스크립트에 타입을 사용하는 것은 어디까지나 선택적으로 사용할 수 있도록 설계되었으며, 자바스크립트와의 호환성을 유지하기 위해 극단적인 절충안(역주: <code class="language-text">any</code> 타입 같은 것?)을 취하여 표현력과 유용성을 제한하였습니다.</p>\n<p>타입, 불변성, 그리고 함수형 프로그래밍은 다른 언어에서도 사용되는 것 처럼 서로를 뒷받침할 수 있습니다. 기반 자료구조가 가변적이거나 런타임에는 (타입이) 존재하지 않더라도 타입이 불변성을 강제하는데 사용될 수 있습니다. 타입은 다른 개발자들이 렌즈를 사용하여 함수 합성을 하거나 데이터를 변형할 때 함수들을 제대로 연결하도록 도울 수 있습니다. 함수를 사용한 변형은 타입과 함께 사용할 때 이해하고 유지보수하기 쉬운데다 기반 자료구조가 불변성을 가지고 있는지 알 수 있을 때 더욱 유용합니다.</p>\n<h2 id="두려움을-가지고-코드를-작성하는-법-배우기"><a href="#%EB%91%90%EB%A0%A4%EC%9B%80%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EB%B2%95-%EB%B0%B0%EC%9A%B0%EA%B8%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>두려움을 가지고 코드를 작성하는 법 배우기</h2>\n<p>그렇다면 어떻게 두려움을 가지고 코드를 작성하는 법을 배울 수 있을까요? 더 나은 자바스크립트 코드를 작성하는 겁니다. 여러분 자신의 코드를 거의 믿을 수 없다는 기본 가정에서 시작하여 함수형 자바스크립트를 작성하고 언어 자체의 나쁜 부분을 피하는 수 많은 기술을 배울 수 있습니다. 필요한 부분에는 타입 유효성 검사를 사용하고 꼭 필요한 경우거나 규약으로 명확히 강제할 때 불변 데이터를 사용합니다. 합당한 이유가 있을 때 선택적 타입을 도입하되, 함수형으로 데이터를 다루거나 불변 데이터를 사용하는 것이 더 나은 이득을 제공한다고 판단되면 타입 사용을 포기합니다. 함수 합성이나 렌즈를 사용하기 위해 의도적으로 타입 체킹을 비활성화 할 수 있습니다.</p>\n<p>아니면 아예 <a href="http://www.purescript.org/">PureScript</a>, <a href="https://bucklescript.github.io/">ReasonML</a>, <a href="http://elm-lang.org/">Elm</a>, <a href="https://clojurescript.org/">ClojureScript</a> 등을 사용하여 다른 물에서 노는 방법이 있습니다. 이 언어들은 오늘날 실존하며 실제 프로덕션 앱이 동작하고 있습니다. 필요하다면 자바스크립트 에코시스템과 함께 동작할 수 있습니다. 불변성, 함수형 프로그래밍, 타입(해당되는 경우)이 기본적으로 잘 작동하고, 이 요소들이 함께 작동하는 환경에서 보다 높은 수준의 신뢰를 제공합니다.</p>\n<p>이런 언어들 중 하나를 선택한다고 모든 문제를 해결할 수는 없습니다. 각자의 언어는 또 문제를 가지고 있습니다. 하지만 기본적으로 자바스크립트에 비해 더 높은 신뢰성이 있으며 필요에 따라 그 신뢰 수준을 끌어올리거나 낮추는 더 나은 도구를 제공합니다. 다음 포스트에서 PureScript 를 활용하여 이런 아이디어가 어떻게 적용되는지 이야기해보겠습니다.</p>\n<p><strong><em>하지만 자바스크립트를 쓰는 한, 두려움은 언제나 여러분과 함께합니다</em>.</strong></p>',
id:"/home/circleci/repo/src/pages/posts/2018-03-04-fear-trust-and-javascript-kr/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2018-03-04",path:"/posts/fear-trust-and-javascript-kr",title:"[번역] 두려움, 믿음, 그리고 자바스크립트 - 언제 타입 시스템과 함수형 프로그래밍이 먹히지 않는가",tags:["Functional Programming","Javascript","Typescript","Translation"],category:"Javascript"}},{excerpt:"제가 요즘 프론트엔드 개발을 하면서 주로 관심을 가지고 있는 분야는 CSS로 레이아웃을 더 잘 잡아보기 (without Grid, Flex - 하위호환 때문에…) + 더 사용자 친화적인 UI…",html:'<p>제가 요즘 프론트엔드 개발을 하면서 주로 관심을 가지고 있는 분야는</p>\n<ul>\n<li>CSS로 레이아웃을 더 잘 잡아보기 (without Grid, Flex - 하위호환 때문에…) + 더 사용자 친화적인 UI 고려하기</li>\n<li>타입스크립트의 타입 시스템을 적극적으로 활용해보기</li>\n<li>타입스크립트 뿐 아니라 자바스크립트의 기초에 소홀히 하지 않기</li>\n<li>다양한 프로그래밍 패러다임과 이론을 익히면서 실무에 접목하기 -> 더욱 간결하고 유지보수가 용이한 코드 작성하기</li>\n<li><a href="/posts/what-is-testing-javascript-kr">테스팅</a></li>\n</ul>\n<p>이 정도로 나열해 볼 수 있습니다.</p>\n<p>오늘은 이 중 세 번째와 네 번째 주제에 대해 아주 가벼운 이야기를 해 보려고 합니다. 최근에 자바스크립트 개발과 관련된 담론에서 많이 거론되는 용어가 있습니다. <strong><a href="https://www.reactivemanifesto.org/ko">Reactive Programming</a> - 이 선언에 기반한 RxJS 등의 라이브러리</strong>, <strong>Functional Programming(함수형 프로그래밍)</strong> 입니다. 사실 이 용어들이 등장한 것은 꽤 오래 전 일이라고 합니다만.. 저는 요즘에서야 눈을 돌리게 되었네요.</p>\n<p>그렇게 함수형 프로그래밍에 관심을 가지면서 책이나 강연 등을 살펴보고, 얼마 전에는 함수를 적극적으로 활용하여 CSS 파일을 압축(minify)하는 아주 간단한 함수를 만들었습니다. 이 압축 함수를 만들면서 제가 조금이나마 익힌 함수형 프로그래밍의 개념을 어떻게 활용했는지, 어떻게 발전시킬 수 있을지 함께 고민하는 시간을 마련해보고자 합니다.</p>\n<p>앞으로 제가 선보일 내용은 아주 기초적인데다 심지어 틀릴 수도 있으니 이상한 점이나 잘못된 점이 있다면 댓글이나 메일로 피드백 주시면 대단히 고맙겠습니다.</p>\n<h2 id="함수형-프로그래밍이란"><a href="#%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>함수형 프로그래밍이란</h2>\n<p>제가 아는 한에서 여러가지로 장황하게 설명을 해 보려고 했으나, 다음 번역 글이 아주 좋은 설명을 하고 있다고 생각하여 링크로 대신하고자 합니다.</p>\n<ul>\n<li><a href="https://medium.com/@jooyunghan/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-fab4e960d263">(번역) 함수형 프로그래밍이란 무엇인가? – Jooyung Han (한주영) – Medium</a></li>\n<li><a href="https://medium.com/@jooyunghan/%EC%96%B4%EB%96%A4-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4%EB%93%A4%EC%9D%B4-%ED%95%A8%EC%88%98%ED%98%95%EC%9D%B8%EA%B0%80-fec1e941c47f">(번역) 어떤 프로그래밍 언어들이 함수형인가? – Jooyung Han (한주영) – Medium</a></li>\n</ul>\n<p>제 나름의 정의를 내리자면 “더 안정적인 프로그램을 만들기 위해 입력과 출력이 철저히 통제된 순수 함수 및 부수 효과(Side-effect)를 최소화한 함수 위주로 프로그래밍 하는 것. 이를 통해 간결하고 가독성 높은 프로그램을 작성할 수 있으며 동시성 작업을 더 안전하게 구현할 수 있다.” 라고 말씀드릴 수 있겠습니다. 여기서 한마디 더 얹어보자면 <strong>함수를 특별하게 취급하지 않는 프로그래밍 패러다임</strong> 이라고 말씀드릴 수 있겠습니다.</p>\n<p>사실 자바스크립트는 <strong>함수형 프로그래밍 언어가 아닙니다.</strong> 이 점은 반드시 인지하고 계셔야 합니다. 단순히 자바스크립트에서 함수가 일급 객체(First Class Citizen)이기 때문에 함수형 프로그래밍 언어인 것은 아닙니다. 함수형 프로그래밍이 가능한 정도입니다. 아마 이 주제 때문에 글 하나가 더 나오겠지만.. 언젠가 제가 더 확고한 기반지식을 쌓고 작성할 기회가 있으리라 생각합니다. (사실 이미 다른 분들의 훌륭한 글이나 번역이 많아서요)</p>\n<h2 id="css-압축-함수-만들기---초기-버전"><a href="#css-%EC%95%95%EC%B6%95-%ED%95%A8%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0---%EC%B4%88%EA%B8%B0-%EB%B2%84%EC%A0%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSS 압축 함수 만들기 - 초기 버전</h2>\n<p>리액트 프로젝트를 하면서 외부 CSS나 미리 설정된 CSS를 HTML 헤더에 삽입할 일이 있는데, 저는 이 CSS 파일이 고스란히 노출되기보다 최소한 공백이나 개행 등을 제거하여 용량을 줄이고, 사용자가 조금이라도 빠르게 컨텐츠를 볼 수 있기를 원했습니다. 예를 들면 최상단에 페이지의 기본 설정을 위해 다음과 같은 CSS를 설정하였습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-css"><code class="language-css"><span class="token comment">/* page-setup.css */</span>\n<span class="token selector">html</span> <span class="token punctuation">{</span>\n  <span class="token property">font-size</span><span class="token punctuation">:</span> 62.5%<span class="token punctuation">;</span>\n  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">html, body</span> <span class="token punctuation">{</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">div, p, h1, h2, h3, h4, h5, h6, ul, ol, li, dl, dt, dd,\ntable, th, td, form, fieldset, legend, input, textarea, blockquote, button</span> <span class="token punctuation">{</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">*, *:before, *:after</span> <span class="token punctuation">{</span>\n  <span class="token property">box-sizing</span><span class="token punctuation">:</span> inherit<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">li</span> <span class="token punctuation">{</span>\n  <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>사실 CSS는 중괄호(<code class="language-text">{}</code>) 만 제대로 열고 닫히고, 세미콜론을 지켜주는 등 기본적인 문법 요소만 충족하면 정상적으로 동작합니다. 다만 <code class="language-text">margin: 0 auto;</code>  같이 작성되어 있을 때는 <code class="language-text">0</code> 과 <code class="language-text">auto</code> 사이의 공백은 유지해야합니다. 그래서 제가 만들려는 함수의 필요 구현 조건은 이랬습니다.</p>\n<ul>\n<li>CSS 파일 앞 뒤에 불필요한 공백과 개행이 없어야한다.</li>\n<li>CSS 파일 내부에도 개행이 없어야한다.</li>\n<li>CSS 파일 내부에서 다음 문자 주위의 공백은 불필요하다 -> <code class="language-text">,</code>, <code class="language-text">;</code>, <code class="language-text">:</code>, <code class="language-text">{</code>, <code class="language-text">}</code></li>\n</ul>\n<p>그래서 CSS파일 자체를 문자열로 읽어들여서 이를 <code class="language-text">string#trim</code>, <code class="language-text">string#replace</code> 메서드로 수정하는 함수를 만들었습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">cssMinifierNormal</span><span class="token punctuation">(</span>cssString<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> cssString\n    <span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// -> CSS 전후 공백 및 개행 삭제</span>\n    <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/[\\r\\n]/g</span><span class="token punctuation">,</span> <span class="token string">\'\'</span><span class="token punctuation">)</span> <span class="token comment">// -> 개행 삭제</span>\n    <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\\s*,\\s*/g</span><span class="token punctuation">,</span> <span class="token string">\',\'</span><span class="token punctuation">)</span>  <span class="token comment">// -> 해당 문자열 주위의 공백을 삭제</span>\n    <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\\s*;\\s*/g</span><span class="token punctuation">,</span> <span class="token string">\';\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\\s*:\\s*/g</span><span class="token punctuation">,</span> <span class="token string">\':\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\\s*{\\s*/g</span><span class="token punctuation">,</span> <span class="token string">\'{\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\\s*}\\s*/g</span><span class="token punctuation">,</span> <span class="token string">\'}\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>아직까진 너무 간단한 함수입니다. 만약에 이 함수가 300개 이상의 규칙을 가지고 있다고 한다면 이렇게 작성하는게 옳은 방법일까요? 300개 이상의 규칙을 가지고 있는 함수에 새로운 규칙을 추기해야한다면 어디에 어떻게 추가해야 문제가 없을까요? 아마 당장은 이런 문제에 부딪힐 일이 없겠지만 약간의 고민 끝에 다른 방식으로 구현해 보았습니다.</p>\n<h2 id="함수로-풀어보자"><a href="#%ED%95%A8%EC%88%98%EB%A1%9C-%ED%92%80%EC%96%B4%EB%B3%B4%EC%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>함수로 풀어보자</h2>\n<p>이번에는 서로 다른 함수를 조합하는 방식으로 또 다른 <code class="language-text">cssMinifier</code> 함수를 만들어보겠습니다. 먼저 조금씩 각기 다른 공백 제거 함수를 분리해보겠습니다.</p>\n<ul>\n<li><code class="language-text">trim</code>: 전후 공백 및 개행 삭제</li>\n<li><code class="language-text">replace</code>: 특정 정규표현식에 해당하는 문자열 교체</li>\n</ul>\n<p>어? 방금 우리가 위에서 사용한 메서드 아닌가요? 하지만 이 메서드를 함수로 표현한다면 약간 이야기가 달라집니다. 함수를 평소와는 약간 다르게 구현해보겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">trim</span> <span class="token operator">=</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">=></span> str<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// function trim(str) {</span>\n<span class="token comment">//   return str.trim();</span>\n<span class="token comment">// }</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">replace</span> <span class="token operator">=</span> <span class="token punctuation">(</span>regExp<span class="token punctuation">,</span> newSubStr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">=></span>\n  str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>regExp<span class="token punctuation">,</span> newSubStr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n\n<span class="token comment">// function replace(regExp, newSubStr) {</span>\n<span class="token comment">//   return function replacer(str) {</span>\n<span class="token comment">//     return str.replace(regExp, newSubStr);</span>\n<span class="token comment">//   }</span>\n<span class="token comment">// }</span></code></pre>\n      </div>\n<p>화살표 함수(Arrow Function)는 보신적이 있어도 화살표가 이중으로 쓰여진 부분은 익숙지 않으신 분들이 계실지도 모르겠습니다. 그래서 아래에 일반 함수 표현식으로 작성하는 법도 따로 표기했습니다. <code class="language-text">replace</code> 는 일종의 부분 함수입니다. 첫 번째로 인자를 입력해 두면 그 다음에는 <code class="language-text">string#replace</code> 메서드를 적용할 문자열의 입력을 기다리는 함수가 리턴됩니다. (커링이라고 말씀드리려 했으나 엄밀히 따지면 커링은 여러 개의 인자를 받는 함수를 각각 한개씩 받을 수 있도록 만들어주는 기법이라고 이해하고 있어서 부분 함수라고 표현합니다)</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token comment">// 콤마 주변의 공백을 제거하는 함수 할당</span>\n<span class="token keyword">const</span> removeSpaceAroundComma <span class="token operator">=</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\\s*,\\s*/g</span><span class="token punctuation">,</span> <span class="token string">\',\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">removeSpaceAroundComma</span><span class="token punctuation">(</span><span class="token string">\'One , Two , Three , Four\'</span><span class="token punctuation">)</span>\n<span class="token comment">// => \'One,Two,Three,Four\'</span></code></pre>\n      </div>\n<p>위의 <code class="language-text">replace</code> 함수를 이런 식으로 활용할 수 있습니다. 조금만 손을 보면 어떤 문자 주변의 공백이든 손쉽게 제거해주는 함수를 만들 수 있겠네요. </p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">removeSpaceAroundChar</span> <span class="token operator">=</span> <span class="token punctuation">(</span>char<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`\\\\s*</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>char<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">\\\\s*`</span></span><span class="token punctuation">,</span> <span class="token string">\'g\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> char<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> removeSpaceAroundSemi <span class="token operator">=</span> <span class="token function">removeSpaceAroundChar</span><span class="token punctuation">(</span><span class="token string">\';\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">removeSpaceAroundSemi</span><span class="token punctuation">(</span><span class="token string">\'; undefined is not a function ; \'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// => \';undefined is not a function;\'</span></code></pre>\n      </div>\n<p>아까 작성한 메서드 체인처럼 원하는 모든 문자열 주변의 공백을 제거하는 함수를 준비해보겠습니다. <code class="language-text">Array#map</code>  함수를 쓰고자 하지만 이번에는 <code class="language-text">map</code> 함수조차 직접 만들어봤습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">map</span> <span class="token operator">=</span> <span class="token punctuation">(</span>iteratee<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token operator">=></span> list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>iteratee<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// function map(iteratee) {</span>\n<span class="token comment">//   return function mapped(list) {</span>\n<span class="token comment">//     return list.map(iteratee);</span>\n<span class="token comment">//   }</span>\n<span class="token comment">// }</span></code></pre>\n      </div>\n<p>사실 이번 글에서는 새롭게 작성한 <code class="language-text">map</code> 함수를 별로 사용할 일이 없을지 모르지만, 인자를 나중에 받는 방식으로 구현하면 함수끼리 조합이 용이해지는 이점이 있기 때문에 시험삼아 만들어봤습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> shrinkers <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span>removeSpaceAroundChar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\',\'</span><span class="token punctuation">,</span> <span class="token string">\';\'</span><span class="token punctuation">,</span> <span class="token string">\':\'</span><span class="token punctuation">,</span> <span class="token string">\'{\'</span><span class="token punctuation">,</span> <span class="token string">\'}\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>이렇게 특정 문자열 주변의 공백을 제거해주는 함수의 배열을 만들었습니다. 그러면 이제 익숙한 <code class="language-text">Array#forEach</code> 함수나 <code class="language-text">Array#reduce</code> 로 문자열을 수정하면 되겠지요. 이렇게요.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">shrinkCss</span><span class="token punctuation">(</span>cssString<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> shrinkers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> shrinker<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">shrinker</span><span class="token punctuation">(</span>cssString<span class="token punctuation">)</span><span class="token punctuation">,</span> cssString<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>오늘의 목표는 여기서 끝내는게 아닙니다. 함수를 만드는 것 까지 해봤으니 만든 함수를 <strong>조합</strong>해서 문제를 한번에 해결해보겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">pipe</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>fns<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=></span> fns<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">fn</span><span class="token punctuation">(</span>acc<span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">pipe</span><span class="token punctuation">(</span>\n  x <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">,</span>\n  x <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">,</span>\n  x <span class="token operator">=></span> x <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">,</span>\n<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// => 3000</span></code></pre>\n      </div>\n<p>보시는대로 <code class="language-text">pipe</code> 함수는 인자로 받은 함수를 모아놨다가 적용할 값을 받아서 왼쪽에서 오른쪽으로(위에서 아래로) 순차적으로 연산합니다. 보통 반대로 <code class="language-text">compose</code> 함수를 쓰는 경우도 있는데, 저는 가독성 측면에서 아직은 <code class="language-text">pipe</code>  를 선호합니다.</p>\n<p>그럼 여태 만든 함수를 저 파이프라인에 쌓아두고 CSS 문자열을 넣기만 하면 우리가 원하는 문자열이 나오겠군요? 한번 최종 결과물을 만들어 보겠습니다.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'fs\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nfs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">\'./page-setup.css\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> encoding<span class="token punctuation">:</span> <span class="token string">\'utf-8\'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">cssMinifier</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">cssMinifier</span><span class="token punctuation">(</span>cssString<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token function-variable function">removeSpaceAroundChar</span> <span class="token operator">=</span> char <span class="token operator">=></span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`\\\\s*</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>char<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">\\\\s*`</span></span><span class="token punctuation">,</span> <span class="token string">\'g\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> char<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> removeNewLine <span class="token operator">=</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/[\\r\\n]/g</span><span class="token punctuation">,</span> <span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> shrinkers <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span>removeSpaceAroundChar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\',\'</span><span class="token punctuation">,</span> <span class="token string">\';\'</span><span class="token punctuation">,</span> <span class="token string">\':\'</span><span class="token punctuation">,</span> <span class="token string">\'{\'</span><span class="token punctuation">,</span> <span class="token string">\'}\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token function">pipe</span><span class="token punctuation">(</span>trim<span class="token punctuation">,</span> removeNewLine<span class="token punctuation">,</span> <span class="token operator">...</span>shrinkers<span class="token punctuation">)</span><span class="token punctuation">(</span>cssString<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>구문 자체는 약간 복잡해졌을지 몰라도 코드 줄 수는 확연히 줄었으며 만약에 규칙을 추가해야 할 때는 어느 부분에 무엇을 추가해야하는지가 조금 더 간편해지고 명확해졌습니다. 각자 역할을 나타내는 이름을 가진 함수니까요. 지금은 <code class="language-text">shrinkers</code> 오른편에 있는 배열에 원하는 글자만 추가해주면 새로운 공백 제거 규칙이 생성됩니다.</p>\n<p><code class="language-text">shrinkers</code> 는 함수의 배열인지라 <code class="language-text">pipe</code> 함수에 넣을 때는 전개 연산자(Spread Operator)로 풀어헤쳐서 인자로 적용하였습니다. 아마 <code class="language-text">pipe</code> 함수를 고도화하면 배열로 된 인자에도 대응할 수 있겠지요. 이번 시간에는 작게나마 제가 이해하고 있는 부분만 말씀드렸습니다.</p>\n<h2 id="이렇게도-해-보고-저렇게도-해-보고"><a href="#%EC%9D%B4%EB%A0%87%EA%B2%8C%EB%8F%84-%ED%95%B4-%EB%B3%B4%EA%B3%A0-%EC%A0%80%EB%A0%87%EA%B2%8C%EB%8F%84-%ED%95%B4-%EB%B3%B4%EA%B3%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>이렇게도 해 보고, 저렇게도 해 보고</h2>\n<p>저도 요즘에야 이렇게 함수를 적극적으로 활용하여 주어진 문제를 풀어나가는 법을 연습하고 있습니다. 머리로 아무리 알고만 있어도 실제로 써먹지 않는다면 사용 가능한 지식이 아니겠지요. 위에 작성한 <code class="language-text">replace</code>, <code class="language-text">map</code>, <code class="language-text">pipe</code> 함수는 원래대로라면 훨씬 고려해야 할 요소들이 많을지도 모릅니다. 제대로 된 인자가 들어왔는지, 더 재사용 가능한 방법이 있는지 등등... 저는 일단 실무에서 <a href="http://ramdajs.com">Ramda.js</a> 를 활용하고 있습니다. 위에 작성한 함수 모두 <code class="language-text">R.replace</code>, <code class="language-text">R.map</code>, <code class="language-text">R.pipe</code> 로 대체 가능합니다.</p>\n<p>가능한 부분에 적극적으로 함수를 활용한 프로그래밍을 하자니 아직 모르는 점이 많습니다.</p>\n<ul>\n<li>비동기 작업(Promise 등)을 일으키는 함수를 다른 함수와 조합하려면 어떻게 해야할까?</li>\n<li>아무 생각없이 작성하는 클래스 상속도 함수의 조합만으로 해결 할 수 있어보이는데, 어떻게 해야할까?</li>\n<li>함수만으로 코드를 작성하자니 어색하다. 뭔가 Class 같이 공통된 역할을 하는 함수를 모으는 일도 해야할까? 한다면 어떻게 해야할까?</li>\n<li>재사용 가능한 함수를 어떻게 만들 수 있을까? 이 함수를 조합하는 방법은 더 다양할 것 같은데 어떤 게 있을까?</li>\n</ul>\n<p>이미 제가 했던 고민을 거쳐온 분들이라면 조금이라도 조언을 부탁드리고 싶고, 위의 문제를 해결하는 방식이 생소한 분들이라면 한번 기존에 작성했던/앞으로 작성하실 코드에 저처럼 다양한 시도를 해 보시길 권하고 싶습니다. 반드시 함수형 프로그래밍이라는 개념을 익힐 필요는 없습니다. 기존의 틀을 벗어나 새로운 시각을 받아들이고 적용하고자 할 때, 더 좋은 프로그램을 만들 수 있는 가능성이 열린다고 생각합니다.</p>\n<h2 id="참고-자료"><a href="#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>참고 자료</h2>\n<ul>\n<li><a href="http://ramdajs.com">Ramda Documentation</a></li>\n<li><a href="http://merong.city">merong님의 함수형 자바스크립트 프로그래밍 강좌</a></li>\n<li><a href="https://www.gitbook.com/book/mostly-adequate/mostly-adequate-guide">Frisby 교수님의 함수형 적절한 함수형 프로그래밍 가이드 · GitBook</a></li>\n<li><a href="https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript">Professor Frisby Introduces Composable Functional JavaScript from @drboolean on @eggheadio</a></li>\n<li><a href="http://aladin.kr/p/rUEvd">함수형 자바스크립트 - 모던 웹 개발에 충실한 실전 함수형 프로그래밍 안내서</a></li>\n</ul>',id:"/home/circleci/repo/src/pages/posts/2018-02-19-functional-js-tutorial/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2018-02-19",path:"/posts/functional-js-tutorial",title:"자바스크립트로 함수형 프로그래밍 아주 살짝 맛보기",tags:["Functional Programming","Javascript"],category:"Functional Programming"}}],tagName:"Functional Programming"}}}});
//# sourceMappingURL=path---tags-functional-programming-bfa94a00da132438e5a4.js.map